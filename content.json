{"meta":{"title":"Guzhz's House","subtitle":"Simply to do something.","description":null,"author":"Guzhz","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-10-27T04:33:56.905Z","updated":"2019-03-26T17:19:54.435Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-26T17:13:23.652Z","updated":"2019-03-26T12:47:50.243Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2020-08-04T10:03:21.000Z","updated":"2020-08-04T10:04:01.477Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"canvas的使用","slug":"canvas的使用","date":"2021-04-10T03:30:00.000Z","updated":"2021-04-10T06:40:46.000Z","comments":true,"path":"2021/04/10/canvas的使用/","link":"","permalink":"http://yoursite.com/2021/04/10/canvas的使用/","excerpt":"","text":"一、基本使用1 、两个属性，width和height，建议直接设置在标签上，如果用css设置，则会拉伸&lt;canvas width=\"500\" height=\"400\" id=\"mycanvas\"&gt; 当前浏览器不支持，请升级浏览器 &lt;/canvas&gt; 2、通过js获得画布上下文对象var canvas = document.getElementById(\"mycanvas\") //获得的画布对象有两个上下文对象，2d、3d //所有设置都是通过这个ctx设置，和canvas标签没有关系了 var ctx = canvas.getContext(\"2d\") //先设置颜色 ctx.fillStyle = \"green\" //再绘制 ctx.fillRect(100,100,200,50) 二、Canvas的思想一旦绘制成功，canvas就像素化了它们，canvas没有能力从画布上再次得到这个图形，也就是说无法更改画出来的内容了。这就是为啥canvas轻量的原因，而flash重的原因是因为它可以存在对应的api，可以得到画布的内容进行修改。 动画思想：如果我们想要canvas移动，就需要按照【清屏-&gt;更新-&gt;重绘】的逻辑进行编程 var canvas = document.getElementById(\"mycanvas\") var ctx = canvas.getContext(\"2d\") ctx.fillStyle = \"green\" ctx.fillRect(100,100,600,50) //信号量 var left = 100 setInterval(function() &#123; ctx.clearRect(0, 0, 600, 600) left++ ctx.fillRect(left, 100, 100, 100) &#125;,10) console.log(ctx) 三、面向对象思想//把操作封装成对象 var canvas = document.getElementById(\"mycanvas\") var ctx = canvas.getContext(\"2d\") //矩形对象 function Rect(x, y, w, h, color) &#123; this.x = x this.y = y this.w = w this.h = h this.color = color &#125; //移动更新 Rect.prototype.update = function() &#123; this.x++ &#125; //绘制 Rect.prototype.render = function() &#123; ctx.fillStyle = this.color ctx.fillRect(this.x, this.y, this.w, this.h) &#125; //实例化 var r1 = new Rect(100,100,50,50,\"purple\") //动画过程 setInterval(function() &#123; //清屏 ctx.clearRect(0, 0, canvas.width, canvas.height) //更新 r1.update() //绘制 r1.render() &#125;) 四、绘制功能（非填充）1、绘制边框 ctx.strokeStyle = “red” ctx.strokeRect(300, 100, 100, 100)绘制一个矩形边框 2、绘制路径 为了绘制不规则多边形的形态 路径是闭合的 如果路径不闭合不会自动填充，而fill会自动填充 //创建路径 ctx.beginPath() //移动到开始绘制的那个点 ctx.moveTo(100,100) //开始画线 ctx.lineTo(200,200) ctx.lineTo(400,180) ctx.lineTo(380,50) //闭合路径：最后一次线的末端点连接绘制点（间接的画线） ctx.closePath() //给路径上色 ctx.strokeStyle = \"red\" //绘制 ctx.stroke(); //注意，这个只是简单的绘制方法 3、绘制圆弧 arc(x, y, radius, startAngle, endAngle, anticlockwise) - x,y为圆心坐标 radius为半径 startAngle 开始角度，一般为0 endAngle 结束角度，2π为一个圆，2*Math.PI，数字的话为0-7为一个圆 anticlockwise 默认为false(顺时针)，反之逆时针 ctx.beginPath() ctx.arc(200,200,0,1,false) ctx.stroke() //画圆 ctx.beginPath() ctx.arc(200,200,0,2*Math.PI,false) ctx.stroke() ctx.fillStyle = \"orange\" ctx.fill() 4、透明度 ctx.globalAlpha = 0.2 //0-1之间 5、线型 ctx.lineWidth设置线的粗细，默认是1，没有单位 ctx.lineCap =&gt; 末端的样式 = “butt” 向线条的每个末端添加平直的边缘。 -&gt; 默认 = “round” 向线条的每个末端添加圆形线帽，多出一些长度 = “square” 向线条的每个末端添加正方形线帽，多出一些长度 ctx.lineJoin =&gt; 交点的样式 = “miter” 内外都是尖角（原理为填充菱形），默认 = “round” 内尖外圆（原理为填充扇形） = “bevel” 底部平滑（原理为填充三角形） 6、虚线 线宽：ctx.setLineDash([线宽，间隔]) ，数组也可以传多组数据ctx.strokeRect(20,20,200,200) 起始偏移量 ctx.lineDashOffset = 2 五、绘制文本 ctx.font = “30px 微软雅黑” ctx.textAlign = “center” //right left ctx.fillText(“你好,我的文本”, 100, 100) 六、渐变1、线性渐变//左上角到右下角开始渐变 var linear = ctx.createLinearGradient(0, 0, 200, 200) linear.addColorStop(0, \"red\") linear.addColorStop(0.5, \"blue\") linear.addColorStop(1, \"purple\") ctx.fillStyle = linear ctx.fillRect(10, 10, 200, 100) 2、径向渐变var linear = ctx.createRadialGradient(95, 25, 25, 102, 20, 40) //参数：第一个圆的坐标和半径，第二个圆的坐标和半径 linear.addColorStop(0, \"red\") linear.addColorStop(0.5, \"blue\") linear.addColorStop(1, \"purple\") ctx.fillStyle = linear ctx.fillRect(10, 10, 200, 100) 七、阴影ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1; ctx.shadowBlur = 20; //模糊量 ctx.shadowColor = \"red\" ctx.font = \"30px 宋体\" ctx.fillText(\"我是文字\", 100 ,100) 八、使用图片//1、创建image元素 var image = new Image() //2、用src设置图片地址 image.src = \"image/1.jpg\" //3、进行图片加载，然后绘制 image.onLoad = function() &#123; ctx.drawImage(image, x, y [,width,height]) //8个参数的含义：切片,切下来移动后，缩放后，再渲染出来 ctx.drawImage(image, x, y, slice_width, slice_height, slice_result_position_x, slice_result_position_y, slice_result_scale_x, slice_result_scale_y) &#125; 九、变形1、定义：canvas是可以变形的，但变形的不是元素，而是画布本身2、基本属性 save() =&gt; 用来保存状态 restore() =&gt; 用来恢复状态 3、可保存的属性：strokeStyle, fillStyle, blobalAiphp, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX,shadowOffsetY, shadowBlur, shadowColor, globalComposite, font,textAlign, textBaseLine,direction, imageSmoothingEnabled","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"重温JS（四）","slug":"重温JS（四）","date":"2021-04-09T01:37:00.000Z","updated":"2021-04-10T06:40:46.000Z","comments":true,"path":"2021/04/09/重温JS（四）/","link":"","permalink":"http://yoursite.com/2021/04/09/重温JS（四）/","excerpt":"","text":"一、浏览器的BOM对象 Window 代表的是整个浏览器的窗口，同时也是网页的全局对象 Navigator 代表的当前浏览器的信息，通过改对象可以识别不同的浏览器 Location 代表当前浏览器的地址栏信息，也可以操作浏览器跳转页面 History 代表历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私问题，不能获取具体的历史纪录 只能操作页面向前后者向后操作 该操作只在档次访问时有效（不关闭浏览器） Screen 获得显示器相关的信息 这些对象都是window的属性，因为是全局的，所以可以直接调用 二、navigator用于识别不同的浏览器var ua = navigator.userAgent console.log(ua) if (/firefox/i.test(ua)) &#123; alert(\"火狐\") &#125; else if (/chrome/i.test(ua)) &#123; alert(\"你是chrome\") &#125; else if (/msie/i.test(ua)) &#123; alert(\"你是IE\") &#125; else if (\"ActiveXObject\" in window)) &#123; //IE11，window.activeXObject =&gt; false alert(\"你是IE11\") &#125; 三、History用来操作浏览器向前或向后 history.length =&gt; 获取到访问链接数量 history.back() =&gt; 退回上一个页面 history.forward() =&gt; 前进一个页面 history.go(num) =&gt; -1，1，2跳转 四、Location封装了地址栏信息 alert(location)如果直接将使用，则打印当前页面的完整路径。 location = “http://www.baidu.com&quot;修改为别的完整路径/相对路径，页面会自动条状，并且生成相应的历史记录 location.assign(“http://www.baidu.com&quot;)和直接修改一样 location.reload([true])用于重新加载页面，作用和刷新按钮一样，可选参数，强制清空缓存true location.replace(“http://www.baidu.com&quot;)不会生成历史记录，不能使用回退按钮 五、定时器 定时调用 var timer = setInterval(function() &#123; count.innerHTML = num++ &#125;, 1000) //返回一个唯一标识（数字），用这个数字来清除定时器 //参数可以接收任何参数，如果不是一个有效的标识，则什么也不做 clearInterval(timer) 延时调用，只执行一次 var timer = setTimeout(function() &#123; console.log(\"test\") &#125;, 2000) //关闭延时调用 clearTimeout(timer) 六、JSON1、json只允许的值 字符串 数值 布尔值 null 对象 数组 不能是函数 2、json字符串转化为JS对象var obj = JSON.parse(json字符串) 3、JS对象转字符串化var str = JSON.stringify(obj) 4、eval()函数 IE7不支持JSON 可以执行字符串代码 但是性能差，不建议使用，有安全隐患 对象的{}会当成代码块，提示需要加“；”var str = \"&#123;'name': 'hh'&#125;\" var obj = eval(\"(\"+str+\")\");","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"重温JS（三）","slug":"重温JS（三）","date":"2021-04-08T06:45:00.000Z","updated":"2021-04-09T06:40:46.000Z","comments":true,"path":"2021/04/08/重温JS（三）/","link":"","permalink":"http://yoursite.com/2021/04/08/重温JS（三）/","excerpt":"","text":"一、查找DOM1、document对象获得元素（方法） 通过id属性 document.getElementById 获得元素并修改值 通过标签名 document.getElementsByTagName 获得标签数组 通过name属性 document.getElementsByName 获得标签数组 通过class属性 document.getElementsByClassName 获得标签数组（IE8以下不支持）var btn = document.getElementById(\"btn\") btn.innerHTML = \"I'm a button\" //获得的标签对象数组，可直接使用元素.属性名获取属性 for(var i = 0; i &lt; inputs.length; i++) &#123; alert(inputs[i].name) alert(inputs[i].value) //但是获得class属性不能直接.class，因为class是js保留字。 //需要用className来获取 alert(inputs[i].className) &#125; 2、元素对象获得子元素同样适用（方法） getElementById =&gt; 唯一 getElementsByTagName =&gt; 数组 getElementsByName =&gt; 数组 3、元素获得子节点（属性）（1）e.childNodes =&gt; 不推荐使用 获得的是数组 主流浏览器DOM标签左右空白部分也会当成文本结点，IE8不会 （2）e.children =&gt; 推荐使用 获得的是数组 只获得元素结点，不包括空白 （3）元素获得第一个/最后一个子节点 e.firstChild / e.lastChild 包括空白 （4）元素获得第一个/最后一个子节点 e.firstElementChild / e.lastElementChild 不包括空白 不兼容IE8及以下 4、元素获得父节点 parentNode（属性）5、元素获得前一个兄弟节点（属性） previousSibling （空格有影响） previousElementSibling（直接获得元素） 6、获得文本节点 pn.innerHTML：获得内部节点的所有HTML元素 pn.innerText：获得内部节点的所有Text文本（过滤标签) pn.firstChild.nodeValue：第一个文本节点（也就是文本） 7、获得其他节点 body节点：document.body html节点：document.documentElement 获得所有节点-方法一：document.all =&gt; 是undefined，但是有长度，可以遍历 获得所有节点-方法二：document.getElementsByName(“*”) =&gt; 不是undefined，有长度，可以遍历 8、样式选择器 document.querySelector() 如果结果是数组，则只取第一个 支持IE8 document.querySelectorAll() 始终是数组 支持IE8 8、绑定监听事件btn.onclick = function() &#123; alert(\"点击了~\") &#125; 9、文档的加载 逐行加载 如果js放在html头部，会出现没有dom就操作dom错误 onload 页面加载完成后再执行window.onload = function() &#123; alert(\"hello\") &#125; 二、操作DOM1、创建 元素 document.createElement(“li”) 创建文本节点 document.createTextNode(“广州”)2、添加 尾部添加：ul.appendChild(li) 任意插入：在指定子节点前插入新的子节点 city.insertBefore(新节点, 旧节点) HTML添加：ul.innerHTML += “&lt;li&gt;广州&lt;/li&gt;“ =&gt; 直接追加HTML也可以3、修改 替换：新节点替换旧节点 city.replaceChild(新节点, 旧节点) 4、删除 直接：city.removeChild(bj) 间接：bj.parentNode.removeChild(bj) 方便，不需要提前获取父节点 缺点，改动太大不建议使用 5、结合使用var li = document.createElement(\"li\") li.innerHTML = \"广州\" city.appendChild(li) 6、样式 -&gt; 内联样式box1.style.width = \"300px\" box2.style.height = \"300px\" box2.style.backgroudColor = \"yellow\" //改为驼峰 //读取和设置，都是内联样式 获得当前样式（IE专属）box1.currentStyle.width 获得当前样式（window方法，浏览器通用），如果没有设置值，获得的是真实值，而不是默认值，该方法不支持IE8getComputedStyle(box1, null).width //参数二为微元素 兼容性方案function getStyle(obj, name) &#123; if(window.getComputedStyle) &#123; //如果不加window，依然在这里判断的时候，会查找getComputedStyle方法，所以加window.属性的方式，才是返回undefined //正常浏览器 return getComputedStyle(obj, null)[name] &#125; else &#123; //IE8方式，没有getComputedStyle() return obj.currentStyle[name] &#125; &#125; 7、其他属性 box.clientWidth =&gt; 内容+内边距 box.offsetWidth =&gt; 内容+内边距+边框 box.offsetParent =&gt; 返回最近的开启了定位的祖先元素（找不到则为body） box.offsetLeft =&gt; 当前元素相对于其定位父元素的水平偏移量 box.offsetTop =&gt; 当前元素相对于其定位父元素的垂直偏移量 box.scrollHeight =&gt; 滚动高度 box.scrollLeft =&gt; 水平滚动条滚动的距离 //滚动条到底：scrollHeight - scrollTop == clientHeight//监听滚动 box.onscoll = function() {}… 8、事件对象 鼠标滚动事件areaDiv.onmousemove = function(event) &#123; //IE8中event事件不存在，而是存在window中 //解决兼容性 event = event || window.event var x = event.clientX var y = event.clientY &#125; 9、事件冒泡 event.cancelBubble = true 10、事件的委派 指的是将事件统一绑定给元素的共同祖先元素，这样当后代元素上的事件触发时，使用的是祖先的事件（原理是冒泡） 然后利用 event.target 获得目标事件，从而实现点击父节点作用子节点。 11、事件监听1、addEventListener(“click”, function(){}, false) 参数一：事件字符串，不需要on 参数二：回调函数 参数三：是否在捕获时触发，一般都为false 使用同事件监听，可以同时为一个元素的相同事件绑定多个响应函数，当事件被触发时，响应函数会顺序执行 this 指的是绑定事件btn01.addEventListener(\"click\", function() &#123;alert(\"1\")&#125;, false); btn01.addEventListener(\"click\", function() &#123;alert(\"2\")&#125;, false); btn01.addEventListener(\"click\", function() &#123;alert(\"3\")&#125;, false); 2、IE8及以下使用attachEvent(“onclick”,function() {}) 不同的是，它的执行顺序是倒叙的 this 指的是window 3、统一成一个bind函数（兼容性） 解决不同浏览器兼容性问题 解决不同的this指向问题 bind(btn, \"click\", function() &#123; alert(this) &#125;) function bind(obj, eventStr, callback) &#123; if (obj.addEventListener) &#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr, callback, false) &#125; else &#123; //IE8及以下 //this是谁，由调用者决定 //解决方案，使用匿名函数，来调用这个回调函数，就可以把默认的的Window替换掉了 obj.attachEvent(\"on\"+eventStr, function() &#123; callback.call(obj) &#125;) &#125; &#125; 4、事件的传播 关于事件的传播，网景公司和微软公司有不同的理解 微软公司认为事件应该是由内向外传播，也就是事件的冒泡阶段。 网景公司认为事件应该由外向内传播。 W3C整合了两种方案，将事件传播分成了三个阶段 捕获阶段：在捕获阶段，从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此事不会触发事件。 目标阶段：事件捕获到目标元素，捕获结束开始在目标事件上触发事件。 冒泡阶段：事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件。 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true，不过一般都是false IE8及以下不存在事件的捕获。 12、元素拖拽 box1按下事件：box1.onmousedown() document绑定移动事件：onmousemove() 修改box1的坐标 document绑定事件松开事件，onmouseup()box1.onmousedown = function() &#123; //document监听，防止覆盖 document.onmousemove = function(event) &#123; event = event || window.event; var left = event.clientX var top = event.clientY //修改box1的位置 box1.style.left = left + \"px\" box2.style.top = top + \"px\" &#125;; //document绑定一个鼠标松开事件 document.onmouseup = function() &#123; document.onmousemove = null document.onmouseup = null //自杀掉 &#125; &#125; 13、滚轮事件window.onload = function () &#123; /* 当鼠标滚轮向下滚动时，box1变长，向上变短 */ var box1 = document.getElementById(\"box1\") /* 火狐浏览器不兼容 */ box1.onmousewheel = function() &#123; event = event || window.event //判断鼠标滚轮的方向，向上滚120，向下滚-120，我们只看正负不看大小。 if (event.wheelDelta &gt; 0 || event.detail &lt; 0) &#123; box1.style.height = box1.clientHeight - 10 + \"px\" &#125;else &#123; box1.style.height = box1.clientHeight + 10 + \"px\" &#125; /* * 使用addEventListener()方法绑定响应函数，不能使用return false * 需要event采用取消默认行为 */ event.preventDefault(); /* 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动。 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为。 */ return false &#125; /* 火狐浏览器需要搭配addEventListener使用 */ bind(box1, \"onmousewheel\", box1.onmousewheel) &#125; function bind(obj, eventStr, callback) &#123; if (obj.addEventListener) &#123; //大部分浏览器兼容的方式 obj.addEventListener(eventStr, callback, false) &#125; else &#123; //IE8及以下 //this是谁，由调用者决定 //解决方案，使用匿名函数，来调用这个回调函数，就可以把默认的的Window替换掉了 obj.attachEvent(\"on\"+eventStr, function() &#123; callback.call(obj) &#125;) &#125; &#125; 5、键盘事件window.onload = function() &#123; //如果一直按着，则事件会一直被触发 //连续触发时，第一次和第二次会有一点点间隔时间，其他时间会非常的快。 //为了防止误操作 document.onkeydown = function (event) &#123; event = event || window.event //可以通过它可以判断哪个按键被按下 console.log(event.keyCode) //按键的编码 if (event.keyCode === 89 &amp;&amp; event.ctrlKey) &#123;//altKey ctrlKey shiftKey console.log(\"同时按下了\") &#125; &#125; document.onkeyup = function() &#123; console.log(\"按键被松开\") &#125; //特点 input.onkeydown = function() &#123; console.log(\"按键被按下了，但是没有内容\"); return false //这个操作可以阻止文本框输入 -&gt; 过滤 &#125; &#125;","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"重温JS（二）","slug":"重温JS（二）","date":"2021-03-27T07:53:57.814Z","updated":"2021-03-27T07:53:23.685Z","comments":true,"path":"2021/03/27/重温JS（二）/","link":"","permalink":"http://yoursite.com/2021/03/27/重温JS（二）/","excerpt":"","text":"一、数组1、arr.length的值 是根据下标最大那个决定的，如果中间没有元素则为空（,,,,) 2、修改length的值产生的影响 变大，没有值的为空（,,,,) 变小，相当于删除尾部元素 3、构造函数创建数组的细节 //多个参数，则创建的是这些参数的数组var arr = new Array(10,20,30)=&gt; “10,20,30” //一个参数时，创建的是开辟这么大空间的数组var arr = new Array(10)=&gt; “,,,,,,,,,,,,,” 4、数组遍历arr.forEach((value,index,arr) =&gt; {})的三个参数分别是当前项的值，当前项的下标和当前遍历的对象IE8一下不兼容 5、常用方法 arr.push(…x) =&gt; 向尾加元素 =&gt; 返回长度 arr.pop() =&gt; 向尾删元素 =&gt; 返回被删元素 arr.unshift(…x) =&gt; 向头加元素 =&gt; 返回长度 arr.shift() =&gt; 向头删元素 =&gt; 返回长度 arr.slice(start[,end]) =&gt; 切片，取左不取右，end不写默认为全部，可以为负值 =&gt; 不影响原数组，返回新数组 arr.splice(start_index, count [,…newElement]) =&gt; 两个参数就是删除，三个参数就是删除后添加，count可为0 =&gt; 返回新数组 arr.concat(newArr) =&gt; 拼接数组 =&gt; 不会对元数组产生影响 arr.join(“,”) =&gt; 参数是连接符，默认是逗号 =&gt; 不会对元数组产生影响 arr.reverse =&gt; 反转 =&gt; 会修改原数组 arr.sort() =&gt; 默认Unicode的编码排序//自定排序规则：根据回调函数的返回值设置 arr.sort(function(a, b) &#123; //a始终是b的前一个元素，返回值大于1则交换，等于0不交换，小于1不交换 //这里a-b为升序 return a - b &#125;) 二、函数的call和apply方法作用：修改函数的this指向 两个都是函数的方法，需要通过函数对象去调用 当对函数调用call()和apply()都会调用函数执行 在调用call()和apply()时，可以将一个对象作为参数传递进去，那个这个参数（对象）将成为函数的this var obj1 = &#123; name: \"我是obj1\" &#125; var obj2 = &#123; name: \"我是obj2\" &#125; function fun() &#123; console.log(this.name) &#125; ======================== fun() =&gt; //打印undefined，因为没有全局变量name fun.call(obj1) =&gt; //打印“我是obj1” fun.apply(obj2) =&gt; //打印“我是obj2” 区别： call()方法可以将实参在对象之后依次传递 apply()方法需要将实参封装到一个数组中统一传递（也就是只有两个参数位置）function fun(a, b) &#123; console.log(\"a = \",a) console.log(\"b = \",b) console.log(this.name) &#125; var obj = &#123; name: \"我是obj\" &#125; fun.call(obj, 1, 2) fun.apply(abj, [1,2]) =&gt; 会自动解构 三、函数的另一个隐式参数：arguments在调用函数时，浏览器每次都会传递两个隐式参数：1、函数的上下文对象this2、封装实参的对象arguments arguments是一个类数组 arguments.length可获得它的长度 但它不是数组（argumentsinstanceof array =&gt; false) 即使不定义形参，也可用通过arguments来使用实参 用法类似数组arguments[0]，arguments[1] arguments存在一个属性callee，该属性指向当前正在执行的函数 arguments.callee == fun 四、new Date()1、创建方式//直接new对象 var d = new Date() =&gt; 当前时间 //指定日期格式：月/日/年(需要4位，2位的话ie可能歧义) 时:分:秒 var d = new Date(\"12/02/2021 11:20:22\") =&gt; 指定时间 2、相关方法d.getFullYear() =&gt; 取代getYear，这里返回正常4位的年份 d.getMonth() =&gt; 获得月份（0-11），需要+1 d.getDate() =&gt; 获得日期是几日 d.getDay() =&gt; 获得周几（0-6） d.getHours() =&gt; 0-23 d.getMinutes() =&gt; 0-59 d.getSeconds() =&gt; 0-59 d.getMiliseconds() =&gt; 获得毫秒 0-999 //时间戳，计算机底层保存时间就是用时间戳 d.getTime() =&gt; 获得从格林威治标准时间的1970-1-1至今的毫秒数 //另一种方式直接获取时间戳 Date.now() 3、关于时间戳的细节var d = new Date(\"1/1/1970 0:0:0\") var timestamp = d.getTime() console.log(timestamp) =&gt; \"-28800000\" 解释：当前系统时间为中国北京时间，位于时区的东八区，刚好比格林威治时间早8小时 五、基本数据类型的包装类 基本数据类型变量是无法使用属性和方法的 但是用它定义属性的时候不会报错，是因为浏览器临时把变量封装成对象然后进行调用对象的方法，但是调用完之后又自动销毁了 然后使用刚刚定义的属性又会自动装箱封装成一个新的对象来进行读取操作，因为是新对象，所以刚刚定义的属性不存在，所以打印是undefined var a = 123 //不报错，自动装箱，封装对象并定义该属性，定义完了又销毁了 a.name = \"hello\" //不报错，只是在读取的时候，也会自动装箱进行封装对象 //然后读取完了（undefined）了，又销毁了 console.log(a.name) =&gt; undefined 六、字符串详讲字符串在在底层是以数组的形式保存的 str.charAt(index) =&gt; 指定位置的字符 str.charCodeAt(index) =&gt; 指定位置的字符的编码（Unicode） String.fromCharCode(72) =&gt; “H” str.concat(“拼接字符”) =&gt; 同+号 str.indexOf(“h”[,startIndex]) =&gt; 第一个h的index，没有找到则返回-1 str.lastIndexOf(“h”[,startIndex]) =&gt; 从后往前找 str.slice =&gt; 切片，取左不取右 str.substring =&gt; 类似切片，也是取左不取右（参数位置会自动交换为正序） str.split(“x”) =&gt; 根据参数拆分数组，支持传入正则对象 str.toUpperCase() =&gt; 大写 str.toLowerCase() =&gt; 小写 七、正则表达式详讲1、创建方式：构造函数、字面量//最简单的正则表达式，构造函数创建正则对象 var reg = new RegExp(\"ab\", \"i/g\") //第二个参数为匹配模式，i为忽略大小写，g为全局匹配 reg.test(\"Abcd\") =&gt; true 开发中常用的方式为，字面量的方式直接创建 var reg = /ab/i reg.test(\"abc\") =&gt; true 2、基本语法 “|”、[ ] 表示或关系 [abcd] == a|b|c|d [A-Z] =&gt; 大写字母 [a-z] =&gt; 小写字母 [A-z] =&gt; 忽略大小写的字母 [0-9] =&gt; 数字 /a[bde]c/ =&gt; 检查字母中含有abc或者adc或者aec ^ 表示非关系 [^abc] =&gt; 查找任何不在中括号以内的字符 {} 量词 /a{n}/ =&gt; 出现n次a /ab{n}/ =&gt; 出现n次b /(ab){n}/ =&gt; 出现n次ab /ab{m,n}/ =&gt; b出现m到n次即可 /a{m,}/ =&gt; a出现m次以上 /abc/ =&gt; 表示0次或多次 =&gt; {0,} /ab?c/ =&gt; ?表示0次或1次 =&gt; {0,1} /ab+c/ =&gt; +表示至少出现一次 =&gt; {1,} 匹配头尾 /^abc/ =&gt; 只能以a开头 /abc$/ =&gt; 只能以c结尾 /^a$/ =&gt; 这个a既是匹配头又是匹配尾 =&gt; ‘a’才是true 通配符 . 点 任意字符，除了换行符和结束符 纯粹匹配.这个字符，需要转义，加反斜杠“\\.” ==&gt; 引申“\\\\” 在构造函数中，字符串需要两个反斜杠才等同于一个反斜杠 =&gt; new RegExp(“\\\\.”)才等同于/\\./ \\w 任意字母、数字、下划线_ &lt;==&gt; [A-z0-9] \\W w的取反 =&gt; [^A-z0-9] \\d 任意数字 &lt;==&gt; [0-9] \\D 非数字 =&gt; [^0-9] \\s 空格 \\S 除了空格 \\b 单词边界 =&gt; 识别是不是一个单词 /\\bchild\\b/ =&gt; “hello child “ 3、搭配字符串的方法使用 str.split(正则) str.search(reg/str) =&gt; 返回第一次出现的下标，没有则返回-1 如果传字符串则同理与str.indexOf() 如果传正则对象，则比较灵活 只能搜索一个，不能设置全局 str.match(正则) =&gt; 返回数组 提取内容 默认只会匹配第一次，匹配到就结束。可以全局匹配/g，同时可以忽略大小写/ig str.replace(reg,”替换的内容”) =&gt; 可以全局替换 /g","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"重温JS（一）","slug":"重温JS（一）","date":"2021-03-27T07:53:57.772Z","updated":"2021-03-27T07:53:02.659Z","comments":true,"path":"2021/03/27/重温JS（一）/","link":"","permalink":"http://yoursite.com/2021/03/27/重温JS（一）/","excerpt":"","text":"js数据类型 基本数据类型：String、Number、Boolean、Null、Undefined、Symbol(ES6)。 引用数据类型：Object、Array、Function。 一、Unicode编码 js使用 console.log(“\\u2620) - 16进制数 html直接使用 &lt;h1&gt;&amp;#9760;&lt;/h1&gt; (2620-&gt;9760) 10进制数 二、立即调用函数 一次性函数 立即调用(function() {console.log(“立即调用”)})() 三、浏览器全局对象window 创建的变量作为全局变量都会作为window对象的属性保存 var a = 10 console.log(a) &lt;=&gt; console.log(window.a) 变量不存在前提下使用会报错，对象属性不存在则是undefined console.log(window.a) =&gt; undefined console.log(a) =&gt; 报错 四、创建对象的五种方式 第一种：Object构造函数创建 var Person = new Object(); Person.name = 'Nike'; Person.age = 29; 第二种：使用对象字面量表示法 var Person = &#123;&#125;;//相当于var Person = new Object(); var Person = &#123; name:'Nike'; age:29; &#125; 第三种：使用工厂模式创建对象 function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; var person1 = createPerson('Nike',29,'teacher'); var person2 = createPerson('Arvin',20,'student'); 第四种：使用构造函数创建对象（类） function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125; var person1 = new Person('Nike',29,'teacher'); var person2 = new Person('Arvin',20,'student'); 第五种：原型创建对象模式 function Person()&#123;&#125; Person.prototype.name = 'Nike'; Person.prototype.age = 20; Person.prototype.jbo = 'teacher'; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; var person1 = new Person(); person1.sayName(); 五、变量/函数的声明提前1、变量的声明提前 先声明后使用的变量，不使用var也不会报错，直接相当于window.a = 10使用 先使用后声明的变量，如果不使用var，则会报错 x is not undefined 先使用后声明的变量，如果使用var，则不会报错，变量会在所有代码执行前声明，但是没有被赋值，所以是undefined。console.log(a) a = 123 =======等价于======= var = a console.log(a) a = 123 2、函数的声明提前 使用函数声明的方式创建的函数function 函数() {}，会提前被提前创建，函数在任何位置调用都不会报错 使用函数表达式的方式创建的函数不会提前声明。相当于函数指向一个变量，但是变量值为undefined，所以提前运行该方法则会报错“undefined is not a function” fun() var fun() = function() &#123; console.log(\"我是使用函数表达式的方式创建的函数，我会报错\") &#125; 六、this 解析器在调用函数，每次都会向函数内部传递一个隐含参数 这个隐含参数就是this，this指向的是一个对象 我们称之为上下文对象，根据函数的调用方式不同，this会指向不同的对象 1、以函数的方式直接调用，this就是window，相当于window调用了该函数 2、以方法的方式调用，this就是调用方法的那个对象 3、以类的方式调用时，this就是该类对象var name = \"我的window的name\" function fun() &#123; console.log(this.name) &#125; var obj1 = &#123; name: 'obj1的name', sayName: fun &#125; var obj1 = &#123; name: 'obj2的name', sayName: fun &#125; console.log(fun) =&gt; \"我的window的name\" console.log(obj1.sayName()) =&gt; \"obj1的name\" console.log(obj2.sayName()) =&gt; \"obj2的name\" 七、构造函数（类） 执行流程，new后所做的事 1、立刻创建一个新的对象 2、将自身设置为函数中的this，this可以引用自身 3、逐行执行函数中的代码 4、将新建的对象作为返回值返回 function Person(name, age, gender) &#123; this.name = name this.age = age this.gender = gender this.sayHello = function() &#123; console.log(this.name) &#125; &#125; var p = new Person('小明', 10, '男') console.log(p instanceof Person) 八、构造函数（类）中的原型对象function Person() &#123; &#125; var p1 = new Person() var p2 = new Person() 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype（原型对象） 如果函数作为普通函数调用prototype没有任何作用 实例调用原型则是：p1.__proto__ 当函数以构造函数（类）的方式调用时，它所创建的每一个对象都会隐含该属性（原型对象），并且这原型对象是单例的，任何该类的实例访问的都是同一个原型对象 作用：可往原型中注入共用的属性/方法Person.prototype.a = '123' console.log(p1.a) =&gt; '123' console.log(p2.a) =&gt; '123' 如果：实例中有该属性，则优先使用自己的，只有没有的时候才去原型中找p1.a = '我是自己的a' console.log(p1.a) =&gt; '我是自己的a' 九、原型链 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true 可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性 原型到头的判定是直到找到Object对象的原型，又因为Object对象的原型没有原型，如果在Object中依然没有找到，则返回undefined（针对想找的那个属性则是undefined） 原型链一般两层就没了function MyClass() &#123; &#125; var mc = new MyClass(); ================================= console.log(mc.name) =&gt; undefined //自身没有原型也没有则为undefined ================================= MyClass.prototype.name=\"我是原型中的name\" //使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true console.log(\"name\" in mc) =&gt; true ================================= //可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性 console.log(mc.hasOwnProperty(\"name\")) =&gt; false mc.age = 18 console.log(mc.hasOwnProperty(\"age\")) =&gt; true 引出问题：hasOwnProperty()哪来的？自身没有？那是不是在原型里？ //自身没有 =&gt; 可能存在原型里？ console.log(mc.hasOwnProperty(\"hasOwnProperty\")) =&gt; false //原型里还是没有 =&gt; 那原型对象也是对象，会不会在原型的原型里（第二层）？ console.log(mc.__proto__.hasOwnProperty(\"hasOwnProperty\")) =&gt; false //原型的原型里找着了（第二层） console.log(mc.__proto__.__proto__.hasOwnProperty(\"hasOwnProperty\")) =&gt; true //原型到头的判定是直到找到Object对象的原型，又因为Object对象的原型没有原型，如果在object中依然没有找到，则返回undefined（针对想找的那个属性则是undefined） mc.（Object）.（Object的原型）.（Object的原型没有原型） console.log(mc.__proto__.__proto__.__proto__) =&gt; null prototype和proto的区别 prototype是（构造）函数才有的属性 proto是每个对象都有的属性 prototype属性，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象; 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）; proto 是原型链查询中实际用到的，它总是指向 prototype，换句话说就是指向构造函数的原型对象，它是对象独有的。注意，为什么Foo构造也有这个属性呢，因为再js的宇宙里万物皆对象，包括函数； 结论： 1、proto 是原型链查询中实际用到的，它总是指向 prototype； 2、prototype 是函数所独有的，在定义构造函数时自动创建，它总是被 proto 所指。 3、所有对象都有proto属性，函数这个特殊对象除了具有proto属性，还有特有的原型属性prototype。prototype对象默认有两个属性，constructor属性和proto属性。prototype属性可以给函数和对象添加可共享（继承）的方法、属性，而proto是查找某函数或对象的原型链方式。constructor，这个属性包含了一个指针，指回原构造函数。 十、垃圾回收机制定义：当没有属性或者变量对它进行引用的时候，这个对象就变成了垃圾 js自己有垃圾回收机制，无法认为操控 能做的只是将对象设置为null即可","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"uni-app基础","slug":"uni-app基础","date":"2021-03-25T08:40:35.000Z","updated":"2021-04-22T08:40:35.880Z","comments":true,"path":"2021/03/25/uni-app基础/","link":"","permalink":"http://yoursite.com/2021/03/25/uni-app基础/","excerpt":"","text":"一、搭建环境 全局安装脚手架 3 npm install -g @vue/cli 创建项目 vue create -p dcloudio/uni-preset-vue [项目名] 启动项目 微信小程序：npm run dev:mp-weixin 微信开发者工具 在 dist 文件夹中导入项目 二、基础知识1、像素单位rpx：小程序中的单位 750rpx = 屏幕的宽度 vm：h5单位，100vw = 屏幕的宽度 vh：h5单位 100vh = 屏幕的高度 2、使用 sass 安装依赖：npm install sass-loader@8.0.2 node-sass(高版本容易出错) vue css 使用：lang=”scss” 引入阿里巴巴字体 iconfont 3、基础语法 v-if || v-show v-for=”(item,index) in list” v-key=”index” 4、data数据data() &#123; return &#123; title: 'Hello' &#125; &#125; 5、计算属性computed: &#123; // &#125; 6、方法methods: &#123; // &#125; 7、事件传参 集成小程序和vue&lt;view data-index=\"111\" @click=\"handleClick(1,$event)\"&gt;点击&lt;/view&gt; handleClick(index, event) &#123; console.log(index); console.log(event.currentTarget.dataset.index); &#125; 三、组件化1、组件的使用和vue一样：定义-&gt;引入-&gt;注册-&gt;使用 在src目录下新建文件夹components来存放组件 在components的目录下新建组件 *.vue 在使用页面进行导入 import imgBorder from “@/components/img-border”;(导入和注册时名称不能有-号) 注册使用components: &#123; imgBorder &#125; 建议用-号 &lt;image-border&gt;&lt;/image-border&gt; 2、组件传参 父传子 同VUE props: &#123; src: String &#125; 子传父：this.$emit 同VUE methods: &#123; handleClick() &#123; this.$emit(\"toFatherEvent\",参数) 参数直接写 &#125; &#125; &lt;ul-com @toFatherEvent=\"handleClick\"/&gt; 兄弟组件通信：兄弟组件注册到uni原型，父组件调用//A组件注册监听 created() &#123; uni.$on('updateNum', num =&gt; &#123; this.num += num &#125;) &#125; //B组件发射 created() &#123; uni.$emit('updateNum',10) &#125; 3、组件的生命周期created() &#123; // 在这个里面初始化数据 console.log('实例创建完成后被立即调用') console.log(this.num) this.intId = setInterval(() =&gt; &#123; console.log('执行定时器') &#125;, 1000) &#125;, mounted() &#123; // 在这个里面操作dom console.log('挂载已完成', document.getElementById('myview')) &#125;, 四、全局共享数据（两种方法）1、vue原型 定义main.js Vue.prototype.baseUrl = “www.baidu.com&quot; 使用 组件方法 this.baseUrl (this指向为vue的时候) 2、小程序思想 定义App.vue globalData: &#123; baseUrl: \"www.360.com\" &#125; 使用 getApp().globalData.baseUrl 五、插槽（VUE）六、常用生命周期 全局App中使用onLaunch表示应用启动时 页面中使用onLoad或者onShow表示页面加载完成或者页面展示 组件使用mounted组件挂载完毕时 七、条件编译八、uni-ui九、请求封装到全局 /util/api.js const BASE_URL = 'http://localhost:8080' export const myRequest = ( options ) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; uni.request(&#123; url: BASE_URL + options.url, method: options.method || 'GET', data: options.data || &#123;&#125;, success: res =&gt; &#123; if (res.data.status !== 0) &#123; return uni.showToast(&#123; title: '获取数据失败' &#125;) &#125; resolve(res) &#125;, fail: err =&gt; &#123; uni.showToast(&#123; title: '请求接口失败', &#125;) reject(err) &#125; &#125;) &#125;) &#125; 注册到main.js里，挂载到原型上 import &#123; myRequest &#125; from './util/api.js' Vue.prototype.$myRequest = myRequest 页面使用 async getSwiper() &#123; const res = await this.$myRequest(&#123; url: '/api/getlunbo' &#125;) console.log(res) &#125;","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"http://yoursite.com/tags/uni-app/"}]},{"title":"微信小程序自定义头部胶囊","slug":"微信小程序自定义头部胶囊","date":"2021-01-19T07:42:32.303Z","updated":"2021-01-19T08:17:07.281Z","comments":true,"path":"2021/01/19/微信小程序自定义头部胶囊/","link":"","permalink":"http://yoursite.com/2021/01/19/微信小程序自定义头部胶囊/","excerpt":"","text":"需求：有时候需要自定义微信小程序的头部，而不使用默认的样式。 1、关闭使用头部信息对想要自定义的页面进行设置：xx.json，关闭之后页面内容为铺满屏幕\"navigationStyle\": \"custom\", \"enablePullDownRefresh\": false 2、获得屏幕头部信息存到globalData//app.json globalData: &#123; systeminfo: &#123;&#125;, // 系统信息 headerBtnPosi: &#123;&#125; // 胶囊按钮位置信息 &#125;, setHeaderBtn() &#123; // 获取设备信息 wx.getSystemInfo(&#123; success: (res) =&gt; &#123; this.globalData.systeminfo = res &#125;, &#125;) // 获得胶囊按钮位置信息 this.globalData.headerBtnPosi = wxgetMenuButtonBoundingClientRect() &#125;, 3、定义组件headerNavBar.jsconst app = getApp(); Component(&#123; properties: &#123; navbarData: &#123; // 由父页面传递的数据 type: Object, value: &#123;&#125;, observer: function (newVal, oldVal) &#123; &#125; &#125; &#125;, data: &#123; haveBack: true, // 是否有返回按钮，true 有 false 没有 若从分享页进入则为 false statusBarHeight: 0, // 状态栏高度 navbarHeight: 0, // 顶部导航栏高度 navbarBtn: &#123; // 胶囊位置信息 height: 0, width: 0, top: 0, bottom: 0, right: 0 &#125; &#125;, // 微信7.0.0支持wx.getMenuButtonBoundingClientRect()获得胶囊按钮高度 attached: function () &#123; let statusBarHeight = app.globalData.systeminfo.statusBarHeight // 状态栏高度 let headerPosi = app.globalData.headerBtnPosi // 胶囊位置信息 /** * wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点 * 菜单按键宽度： 87 * 菜单按键高度： 32 * 菜单按键左边界坐标： 278 * 菜单按键上边界坐标： 26 * 菜单按键右边界坐标： 365 * 菜单按键下边界坐标： 58 */ let btnPosi = &#123; // 胶囊实际位置，坐标信息不是左上角原点 height: headerPosi.height, width: headerPosi.width, // 胶囊top - 状态栏高度 top: headerPosi.top - statusBarHeight, // 胶囊bottom - 胶囊height - 状态栏height （现胶囊bottom 为距离导航栏底部的长度） bottom: headerPosi.bottom - headerPosi.height - statusBarHeight, // 屏幕宽度 - 胶囊right right: app.globalData.systeminfo.screenWidth - headerPosi.right &#125; let haveBack; if (getCurrentPages().length === 1) &#123; // 当只有一个页面时 haveBack = false; &#125; else &#123; haveBack = true; &#125; this.setData(&#123; haveBack: haveBack, // 获取是否是通过分享进入的小程序 statusBarHeight: statusBarHeight, navbarHeight: headerPosi.bottom + btnPosi.bottom, // 原胶囊bottom + 现胶囊bottom navbarBtn: btnPosi &#125;) &#125;, methods: &#123; _goBack: function () &#123; wx.navigateBack(&#123; delta: 1 &#125;); &#125;, _goHome: function () &#123; wx.switchTab(&#123; url: '/pages/home/home', &#125;); &#125; &#125; &#125;) headerNavBar.wxml&lt;!-- 自定义导航栏 --&gt; &lt;view class=\"navbar-wrap &#123;&#123;navbarData.bgc?'bgc':''&#125;&#125; &#123;&#123;navbarData.float?'float':''&#125;&#125;\" style='height:&#123;&#123;navbarHeight&#125;&#125;px;padding-top:&#123;&#123;statusBarHeight&#125;&#125;px;'&gt; &lt;view class=\"navbar-text\" style='line-height:&#123;&#123;navbarBtn.height + navbarBtn.top&#125;&#125;px;'&gt; &#123;&#123;navbarData.title ? navbarData.title : \"\"&#125;&#125; &lt;/view&gt; &lt;view class=\"navbar-icon\" wx:if='&#123;&#123;navbarData.showCapsule === 1 ? true : false&#125;&#125;' style=\"top:&#123;&#123;navbarBtn.top + statusBarHeight&#125;&#125;px;left:&#123;&#123;navbarBtn.right&#125;&#125;px;height:&#123;&#123;navbarBtn.height&#125;&#125;px;\"&gt; &lt;image wx:if='&#123;&#123;haveBack&#125;&#125;' bindtap=\"_goBack\" class=\"floatL\" src=\"/assets/images/icon/navbar_back.png\"&gt;&lt;/image&gt; &lt;view wx:if='&#123;&#123;haveBack&#125;&#125;' class=\"line\"&gt;&lt;/view&gt; &lt;view wx:if='&#123;&#123;haveBack&#125;&#125;' class=\"floatL\"&gt;&lt;/view&gt; &lt;image bindtap=\"_goHome\" src=\"/assets/images/icon/navbar_home.png\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 手写loading --&gt; &lt;view wx:if=\"&#123;&#123;navbarData.showLoading&#125;&#125;\" class=\"navbar-loading &#123;&#123;navbarData.float?'float':''&#125;&#125;\" style='height:&#123;&#123;navbarHeight&#125;&#125;px;line-height:&#123;&#123;navbarHeight&#125;&#125;px;'&gt; &lt;text&gt;···&lt;/text&gt; &lt;/view&gt; headerNavBar.wxss.navbar-wrap &#123; position: fixed; width: 100%; top: 0; z-index: 9999999; box-sizing: border-box; &#125; .bgc &#123; background-color: #B0E028; &#125; .float &#123; float: left &#125; .navbar-text &#123; position: relative; top: 6rpx; text-align: center; font-size: 36rpx; color: #fff; &#125; .navbar-icon &#123; position: fixed; display: flex; border-radius: 70rpx; border: 0.5px solid rgba(255,255,255, 0.4); box-sizing: border-box; background-color: rgba(0, 0, 0, 0.2); &#125; .navbar-icon image &#123; height: 20px; width: 20px; padding: 5px 10px 10px; display: inline-block; overflow: hidden; &#125; .navbar-icon view &#123; height: 18px; border-left: 0.5px solid rgba(255,255,255, 0.3); margin-top: 6px; &#125; .navbar-loading &#123; background: #fff; text-align: center; &#125; .line &#123; height: 36rpx; width: 1rpx; background: rgba(255,255,255, 0.4); &#125; 4、使用1、对应页面引入组件 “searchbar”: “/components/searchbar/searchbar” 2、页面js定义变量navbarData: &#123; showCapsule: 1, // 是否显示左上角胶囊按钮 1 显示 0 不显示 title: '普菲洛云购', // 导航栏 中间的标题 bgc: true, showLoading: true, float: false &#125;, 3、页面wxml引入&lt;headerNavbar navbar-data=\"&#123;&#123;navbarData&#125;&#125;\"&gt;&lt;/headerNavbar&gt;","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"微信小程序嵌入腾讯地图","slug":"微信小程序嵌入腾讯地图","date":"2021-01-12T06:54:49.388Z","updated":"2021-01-19T07:29:10.753Z","comments":true,"path":"2021/01/12/微信小程序嵌入腾讯地图/","link":"","permalink":"http://yoursite.com/2021/01/12/微信小程序嵌入腾讯地图/","excerpt":"","text":"需求：在微信小程序添加地址或者获取用户定位的时候要用到定位功能，获取用户坐标并逆向解析为实际地址 实现原理 1、获取用户定位权限 2、使用腾讯位置服务提供的插件 3、拿到结果 准备工作 申请腾讯地图账号：参考 https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview 1、拿到账号支持的密钥 2、开通webserviceAPI服务 3、下载微信小程序JavaScriptSDK 4、配置安全域名 使用一、直接解析成地址 1、导入qqmap-wx-jssdk.js //在要使用服务的页面 var QQMapWX = require('../../untils/qqmap-wx-jssdk.js'); var qqmapsdk; Page(&#123; onLoad: function () &#123; // 实例化API核心类 qqmapsdk = new QQMapWX(&#123; key: '你在腾讯位置服务申请的key' &#125;); &#125;, &#125;) 2、获取定位权限 地图选点插件需要小程序提供定位授权才能够正常使用定位功能： // app.json &#123; \"permission\": &#123; \"scope.userLocation\": &#123; \"desc\": \"你的位置信息将用于小程序定位\" &#125; &#125; &#125; getAuthorize () &#123; wx.authorize(&#123; scope: 'scope.userLocation', success: function () &#123; console.log('有定位授权') //授权成功，此处调用获取定位函数 &#125;, fail() &#123; wx.showModal (&#123; cancelColor: 'cancelColor', title: '没有授权无法获取位置信息', content: '是否前往设置页面手动开启', success: function (res) &#123; if (res.confirm) &#123; wx.openSetting(&#123; withSubscriptions: true, &#125;) &#125; else &#123; wx.showToast(&#123; icon: 'none', title: '您取消了定位授权', &#125;) &#125; &#125;, fail: function (e) &#123; console.log(e) &#125; &#125;) &#125; &#125;) &#125;, 3、直接解析成地址 //此函数在用户定位授权成功后调用 function () &#123; wx.getLocation(&#123; type: 'gcj02', success: function (res) &#123; qqmapsdk.reverseGeocoder(&#123; location: &#123; latitude: res.latitude, longitude: res.longitude &#125;, success: function (addressRes) &#123; //成功后的回调 console.log(addressRes); console.log(addressRes.result.address) &#125;, fail: function (error) &#123; app.showTips(\"定位获取失败，请手动输入地址\",\"none\", 2000) &#125;, complete: function (addressRes) &#123; console.log(addressRes); &#125; &#125;) &#125; &#125;) &#125; 使用二、地图选址插件的使用 优点：自带选图界面，点击选中后直接返回地址，少去自己写样式的烦恼 1、添加插件：登录微信公众号后台选择设置-第三方服务-插件管理，搜索 “腾讯位置服务地图选点” 申请，审核通过后，小程序开发者可在小程序内使用该插件。 2、配置插件 参考：https://mp.weixin.qq.com/wxopen/pluginbasicprofile?action=intro&amp;appid=wx76a9a06e5b4e693e&amp;token=1620811584&amp;lang=zh_CN 3、使用 一、引入插件包：地图选点appId： wx76a9a06e5b4e693e // app.json &#123; \"plugins\": &#123; \"chooseLocation\": &#123; \"version\": \"1.0.5\", \"provider\": \"wx76a9a06e5b4e693e\" &#125; &#125; &#125; 二、授权配置：地图选点插件需要小程序提供定位授权才能够正常使用定位功能： // app.json &#123; \"permission\": &#123; \"scope.userLocation\": &#123; \"desc\": \"你的位置信息将用于小程序定位\" &#125; &#125; &#125; 三、使用：插件页面调用示例： const chooseLocation = requirePlugin('chooseLocation'); Page(&#123; // 从地图选点插件返回后，在页面的onShow生命周期函数中能够调用插件接口，取得选点结果对象 onShow () &#123; const location = chooseLocation.getLocation(); // 如果点击确认选点按钮，则返回选点结果对象，否则返回null console.log(location) &#125;, onUnload () &#123; // 页面卸载时设置插件选点数据为null，防止再次进入页面，geLocation返回的是上次选点结果 chooseLocation.setLocation(null); &#125;, function() &#123; wx.getLocation(&#123; type: 'gcj02', success: function (res) &#123; const key = MAPKEY; //使用在腾讯位置服务申请的key const referer = '普菲洛云购'; //调用插件的app的名称 const location = JSON.stringify(&#123; latitude: res.latitude, longitude: res.longitude &#125;); const category = '生活服务,娱乐休闲'; wx.navigateTo(&#123; url: `plugin://chooseLocation/index?key=$&#123;key&#125;&amp;referer=$ &#123;referer&#125;&amp;location=$&#123;location&#125;&amp;category=$&#123;category&#125;` &#125;); &#125; &#125;) &#125; &#125;)","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"},{"name":"地图","slug":"地图","permalink":"http://yoursite.com/tags/地图/"}]},{"title":"浅谈微信小程序组件生命周期","slug":"浅谈微信小程序组件生命周期","date":"2021-01-08T09:36:46.983Z","updated":"2021-01-19T07:29:36.497Z","comments":true,"path":"2021/01/08/浅谈微信小程序组件生命周期/","link":"","permalink":"http://yoursite.com/2021/01/08/浅谈微信小程序组件生命周期/","excerpt":"","text":"组件本身的生命周期组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。最重要的生命周期是 created attached detached ，包含一个组件实例生命流程的最主要时间点。 1、created 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。 2、attached 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。 3、detached 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。 使用Component(&#123; lifetimes: &#123; attached: function() &#123; // 在组件实例进入页面节点树时执行 &#125;, &#125;, &#125;) 组件所在的页面的生命周期还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括： Component(&#123; pageLifetimes: &#123; show: function() &#123; // 页面被展示 &#125;, hide: function() &#123; // 页面被隐藏 &#125;, resize: function(size) &#123; // 页面尺寸变化 &#125; &#125; &#125;)","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"微信小程序组件observers监听数据变动","slug":"微信小程序组件observers监听属性变动","date":"2021-01-08T09:20:28.630Z","updated":"2021-01-19T07:30:25.890Z","comments":true,"path":"2021/01/08/微信小程序组件observers监听属性变动/","link":"","permalink":"http://yoursite.com/2021/01/08/微信小程序组件observers监听属性变动/","excerpt":"","text":"属性监听 properties: &#123; num1: &#123; type: Number, value: false &#125;, num2: &#123; type: Number, value: null &#125;, num3: &#123; type: Number, value: 0 &#125;, num4: &#123; type: Number, value: 0 &#125;, title: &#123; type: String, value: \"我是默认的标题\", observer: function(newValue, oldValue) &#123; //观察者 console.log(newValue, oldValue); &#125; &#125; &#125;, data: &#123; sum: 0 &#125;, //可以监听properties和data observers: &#123; //一个新的值 'num1': function (newVal) &#123; this.setData(&#123; sum: sum + newVal &#125;) &#125;, //同时监听两个，按顺序 'num2, num3': function (num1, num2) &#123; this.setData(&#123; sum: num + num2 &#125;) &#125;, //可以获得新的值和老的值 'num4': function (newVal, oldVal) &#123; this.setData(&#123; sum: oldVal + newVal &#125;) &#125; //注意：不能同时监听data值和setData，会死循环 &#125;,","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"},{"name":"属性监听","slug":"属性监听","permalink":"http://yoursite.com/tags/属性监听/"}]},{"title":"微信小程序使用wxParse解析HTML","slug":"微信小程序使用wxParse解析HTML","date":"2021-01-08T08:39:21.793Z","updated":"2021-01-19T07:30:01.399Z","comments":true,"path":"2021/01/08/微信小程序使用wxParse解析HTML/","link":"","permalink":"http://yoursite.com/2021/01/08/微信小程序使用wxParse解析HTML/","excerpt":"","text":"需求：微信小程序解析后端请求过来的HTML代码，默认小程序不支持解析HTML 结果办法：利用WxParse插件（封装好的模板库）进行替换/解析 下载：https://github.com/icindy/wxParse 使用1、拷贝：目录下的wxParse文件夹，把他拷贝到我们的项目目录下，如果emoji表情库没有用到，可以不拷贝（这玩意占用内存挺大） 2、引入wxss：在app.wxss全局样式文件或者指定加载的页面样式文件中，需要引入wxParse的样式表 @import “/page/wxParse/wxParse.wxss”; 3、引入wxParse.js：在需要加载html内容的页面对应的js文件里引入wxParse.js var WxParse = require(‘../../wxParse/wxParse.js’); data: &#123; content: '' //定义一个变量 &#125; 使用： /** * WxParse.wxParse(bindName , type, data, target,imagePadding) * 1.bindName绑定的数据名(必填) * 2.type可以为html或者md(必填) * 3.data为传入的具体数据(必填) * 4.target为Page对象,一般为this(必填) * 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选) * * 1的数据名用于wxml中 */ WxParse.wxParse('content', 'html', this.data.content, this, 0); 4、wxml中引入页面模板&lt;import src=\"../../../../utils/wxParse/wxParse.wxml\" /&gt; &lt;template is=\"wxParse\" data=\"&#123;&#123;wxParseData:content.nodes&#125;&#125;\" /&gt; &lt;!-- wxParseData:content.nodes中的content就是js里面5个参数中的第1个 --&gt;","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"},{"name":"wxParse","slug":"wxParse","permalink":"http://yoursite.com/tags/wxParse/"}]},{"title":"使用CryptoJS解决微信小程序用户信息解密","slug":"使用CryptoJS解决微信小程序用户信息解密","date":"2021-01-08T08:21:18.609Z","updated":"2021-01-19T07:29:24.334Z","comments":true,"path":"2021/01/08/使用CryptoJS解决微信小程序用户信息解密/","link":"","permalink":"http://yoursite.com/2021/01/08/使用CryptoJS解决微信小程序用户信息解密/","excerpt":"","text":"前言：正常情况来说，微信小程序前端获取用户手机号是敏感操作，前端需要获得登录态后，把登录态的结果参数配合后端解码后返回解码后的结果。但是也存在纯前端解码的技术，纯前端解码原理就是把解码过程在前端js里面完成。但是不能用在实际开发中，因为请求域名不是合法配置的域名。这里只能用做前端测试用，实际开发还是需要后端请求返回。 插件下载：https://github.com/gwjjeff/cryptojs/archive/master.zip 问题描述：wx.getUserInfo(OBJECT) 微信官方的这个获取用户信息的方法，需要对接口返回的加密数据( encryptedData )进行对称解密。 微信官方有提供加密数据解密算法接口如果涉及敏感数据（如wx.getUserInfo当中的 openId 和unionId ），接口的明文内容将不包含这些敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptedData )进行对称解密。解密算法如下： 1.对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。2 对称解密的目标密文为 Base64_Decode(encryptedData)。3.对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。4.对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。 纯前端解密使用方法1、下载包，将 CryptoJS 的包放入 小程序的 utils 中 2、封装 RdWXBizDataCrypt.js/** * Created by rd on 2017/5/4. */ // 引入CryptoJS var Crypto = require('cryptojs/cryptojs.js').Crypto; var app = getApp(); function RdWXBizDataCrypt(appId, sessionKey) &#123; this.appId = appId this.sessionKey = sessionKey &#125; RdWXBizDataCrypt.prototype.decryptData = function (encryptedData, iv) &#123; // base64 decode ：使用 CryptoJS 中 Crypto.util.base64ToBytes()进行 base64解码 var encryptedData = Crypto.util.base64ToBytes(encryptedData) var key = Crypto.util.base64ToBytes(this.sessionKey); var iv = Crypto.util.base64ToBytes(iv); // 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充 var mode = new Crypto.mode.CBC(Crypto.pad.pkcs7); try &#123; // 解密 var bytes = Crypto.AES.decrypt(encryptedData, key, &#123; asBpytes:true, iv: iv, mode: mode &#125;); var decryptResult = JSON.parse(bytes); &#125; catch (err) &#123; console.log(err) &#125; if (decryptResult.watermark.appid !== this.appId) &#123; console.log(err) &#125; return decryptResult &#125; module.exports = RdWXBizDataCrypt 3、使用 import &#123; APPID, SECRET &#125; from '../../../../common/const'; var WXBizDataCrypt = require('../../../../utils/RdWXBizDataCrypt.js'); //先登录 login() &#123; var that = this; wx.login(&#123; success(res) &#123; //拿到登录态的code var code = res.code wx.request(&#123; url: 'https://api.weixin.qq.com/sns/jscode2session?appid=' + APPID + '&amp;secret=' + SECRET + '&amp;js_code=' + code + '&amp;grant_type=authorization_code', method: \"post\", data: &#123; code &#125;, success: function (res) &#123; that.setData(res.data); &#125; &#125;) &#125; &#125;) &#125; //再获得手机号 getPhoneNumber(e) &#123; var that = this; if (e.detail.errMsg == \"getPhoneNumber:ok\") &#123; //传入appid和session_key var pc = new WXBizDataCrypt(APPID, this.data.session_key) var data = pc.decryptData(e.detail.encryptedData, e.detail.iv) console.log('解密后 data: ', data) &#125; &#125;,","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"省市区三级联动area.js","slug":"省市区三级联动area.js","date":"2021-01-08T07:54:49.746Z","updated":"2021-01-08T07:55:38.162Z","comments":true,"path":"2021/01/08/省市区三级联动area.js/","link":"","permalink":"http://yoursite.com/2021/01/08/省市区三级联动area.js/","excerpt":"","text":"area.js 代码如下：export default &#123; province_list: &#123; 110000: '北京市', 120000: '天津市', 130000: '河北省', 140000: '山西省', 150000: '内蒙古自治区', 210000: '辽宁省', 220000: '吉林省', 230000: '黑龙江省', 310000: '上海市', 320000: '江苏省', 330000: '浙江省', 340000: '安徽省', 350000: '福建省', 360000: '江西省', 370000: '山东省', 410000: '河南省', 420000: '湖北省', 430000: '湖南省', 440000: '广东省', 450000: '广西壮族自治区', 460000: '海南省', 500000: '重庆市', 510000: '四川省', 520000: '贵州省', 530000: '云南省', 540000: '西藏自治区', 610000: '陕西省', 620000: '甘肃省', 630000: '青海省', 640000: '宁夏回族自治区', 650000: '新疆维吾尔自治区', 710000: '台湾省', 810000: '香港特别行政区', 820000: '澳门特别行政区', 900000: '海外' &#125;, city_list: &#123; 110100: '北京市', 120100: '天津市', 130100: '石家庄市', 130200: '唐山市', 130300: '秦皇岛市', 130400: '邯郸市', 130500: '邢台市', 130600: '保定市', 130700: '张家口市', 130800: '承德市', 130900: '沧州市', 131000: '廊坊市', 131100: '衡水市', 140100: '太原市', 140200: '大同市', 140300: '阳泉市', 140400: '长治市', 140500: '晋城市', 140600: '朔州市', 140700: '晋中市', 140800: '运城市', 140900: '忻州市', 141000: '临汾市', 141100: '吕梁市', 150100: '呼和浩特市', 150200: '包头市', 150300: '乌海市', 150400: '赤峰市', 150500: '通辽市', 150600: '鄂尔多斯市', 150700: '呼伦贝尔市', 150800: '巴彦淖尔市', 150900: '乌兰察布市', 152200: '兴安盟', 152500: '锡林郭勒盟', 152900: '阿拉善盟', 210100: '沈阳市', 210200: '大连市', 210300: '鞍山市', 210400: '抚顺市', 210500: '本溪市', 210600: '丹东市', 210700: '锦州市', 210800: '营口市', 210900: '阜新市', 211000: '辽阳市', 211100: '盘锦市', 211200: '铁岭市', 211300: '朝阳市', 211400: '葫芦岛市', 220100: '长春市', 220200: '吉林市', 220300: '四平市', 220400: '辽源市', 220500: '通化市', 220600: '白山市', 220700: '松原市', 220800: '白城市', 222400: '延边朝鲜族自治州', 230100: '哈尔滨市', 230200: '齐齐哈尔市', 230300: '鸡西市', 230400: '鹤岗市', 230500: '双鸭山市', 230600: '大庆市', 230700: '伊春市', 230800: '佳木斯市', 230900: '七台河市', 231000: '牡丹江市', 231100: '黑河市', 231200: '绥化市', 232700: '大兴安岭地区', 310100: '上海市', 320100: '南京市', 320200: '无锡市', 320300: '徐州市', 320400: '常州市', 320500: '苏州市', 320600: '南通市', 320700: '连云港市', 320800: '淮安市', 320900: '盐城市', 321000: '扬州市', 321100: '镇江市', 321200: '泰州市', 321300: '宿迁市', 330100: '杭州市', 330200: '宁波市', 330300: '温州市', 330400: '嘉兴市', 330500: '湖州市', 330600: '绍兴市', 330700: '金华市', 330800: '衢州市', 330900: '舟山市', 331000: '台州市', 331100: '丽水市', 340100: '合肥市', 340200: '芜湖市', 340300: '蚌埠市', 340400: '淮南市', 340500: '马鞍山市', 340600: '淮北市', 340700: '铜陵市', 340800: '安庆市', 341000: '黄山市', 341100: '滁州市', 341200: '阜阳市', 341300: '宿州市', 341500: '六安市', 341600: '亳州市', 341700: '池州市', 341800: '宣城市', 350100: '福州市', 350200: '厦门市', 350300: '莆田市', 350400: '三明市', 350500: '泉州市', 350600: '漳州市', 350700: '南平市', 350800: '龙岩市', 350900: '宁德市', 360100: '南昌市', 360200: '景德镇市', 360300: '萍乡市', 360400: '九江市', 360500: '新余市', 360600: '鹰潭市', 360700: '赣州市', 360800: '吉安市', 360900: '宜春市', 361000: '抚州市', 361100: '上饶市', 370100: '济南市', 370200: '青岛市', 370300: '淄博市', 370400: '枣庄市', 370500: '东营市', 370600: '烟台市', 370700: '潍坊市', 370800: '济宁市', 370900: '泰安市', 371000: '威海市', 371100: '日照市', 371300: '临沂市', 371400: '德州市', 371500: '聊城市', 371600: '滨州市', 371700: '菏泽市', 410100: '郑州市', 410200: '开封市', 410300: '洛阳市', 410400: '平顶山市', 410500: '安阳市', 410600: '鹤壁市', 410700: '新乡市', 410800: '焦作市', 410900: '濮阳市', 411000: '许昌市', 411100: '漯河市', 411200: '三门峡市', 411300: '南阳市', 411400: '商丘市', 411500: '信阳市', 411600: '周口市', 411700: '驻马店市', 419000: '省直辖县', 420100: '武汉市', 420200: '黄石市', 420300: '十堰市', 420500: '宜昌市', 420600: '襄阳市', 420700: '鄂州市', 420800: '荆门市', 420900: '孝感市', 421000: '荆州市', 421100: '黄冈市', 421200: '咸宁市', 421300: '随州市', 422800: '恩施土家族苗族自治州', 429000: '省直辖县', 430100: '长沙市', 430200: '株洲市', 430300: '湘潭市', 430400: '衡阳市', 430500: '邵阳市', 430600: '岳阳市', 430700: '常德市', 430800: '张家界市', 430900: '益阳市', 431000: '郴州市', 431100: '永州市', 431200: '怀化市', 431300: '娄底市', 433100: '湘西土家族苗族自治州', 440100: '广州市', 440200: '韶关市', 440300: '深圳市', 440400: '珠海市', 440500: '汕头市', 440600: '佛山市', 440700: '江门市', 440800: '湛江市', 440900: '茂名市', 441200: '肇庆市', 441300: '惠州市', 441400: '梅州市', 441500: '汕尾市', 441600: '河源市', 441700: '阳江市', 441800: '清远市', 441900: '东莞市', 442000: '中山市', 445100: '潮州市', 445200: '揭阳市', 445300: '云浮市', 450100: '南宁市', 450200: '柳州市', 450300: '桂林市', 450400: '梧州市', 450500: '北海市', 450600: '防城港市', 450700: '钦州市', 450800: '贵港市', 450900: '玉林市', 451000: '百色市', 451100: '贺州市', 451200: '河池市', 451300: '来宾市', 451400: '崇左市', 460100: '海口市', 460200: '三亚市', 460300: '三沙市', 460400: '儋州市', 469000: '省直辖县', 500100: '重庆市', 500200: '县', 510100: '成都市', 510300: '自贡市', 510400: '攀枝花市', 510500: '泸州市', 510600: '德阳市', 510700: '绵阳市', 510800: '广元市', 510900: '遂宁市', 511000: '内江市', 511100: '乐山市', 511300: '南充市', 511400: '眉山市', 511500: '宜宾市', 511600: '广安市', 511700: '达州市', 511800: '雅安市', 511900: '巴中市', 512000: '资阳市', 513200: '阿坝藏族羌族自治州', 513300: '甘孜藏族自治州', 513400: '凉山彝族自治州', 520100: '贵阳市', 520200: '六盘水市', 520300: '遵义市', 520400: '安顺市', 520500: '毕节市', 520600: '铜仁市', 522300: '黔西南布依族苗族自治州', 522600: '黔东南苗族侗族自治州', 522700: '黔南布依族苗族自治州', 530100: '昆明市', 530300: '曲靖市', 530400: '玉溪市', 530500: '保山市', 530600: '昭通市', 530700: '丽江市', 530800: '普洱市', 530900: '临沧市', 532300: '楚雄彝族自治州', 532500: '红河哈尼族彝族自治州', 532600: '文山壮族苗族自治州', 532800: '西双版纳傣族自治州', 532900: '大理白族自治州', 533100: '德宏傣族景颇族自治州', 533300: '怒江傈僳族自治州', 533400: '迪庆藏族自治州', 540100: '拉萨市', 540200: '日喀则市', 540300: '昌都市', 540400: '林芝市', 540500: '山南市', 540600: '那曲市', 542500: '阿里地区', 610100: '西安市', 610200: '铜川市', 610300: '宝鸡市', 610400: '咸阳市', 610500: '渭南市', 610600: '延安市', 610700: '汉中市', 610800: '榆林市', 610900: '安康市', 611000: '商洛市', 620100: '兰州市', 620200: '嘉峪关市', 620300: '金昌市', 620400: '白银市', 620500: '天水市', 620600: '武威市', 620700: '张掖市', 620800: '平凉市', 620900: '酒泉市', 621000: '庆阳市', 621100: '定西市', 621200: '陇南市', 622900: '临夏回族自治州', 623000: '甘南藏族自治州', 630100: '西宁市', 630200: '海东市', 632200: '海北藏族自治州', 632300: '黄南藏族自治州', 632500: '海南藏族自治州', 632600: '果洛藏族自治州', 632700: '玉树藏族自治州', 632800: '海西蒙古族藏族自治州', 640100: '银川市', 640200: '石嘴山市', 640300: '吴忠市', 640400: '固原市', 640500: '中卫市', 650100: '乌鲁木齐市', 650200: '克拉玛依市', 650400: '吐鲁番市', 650500: '哈密市', 652300: '昌吉回族自治州', 652700: '博尔塔拉蒙古自治州', 652800: '巴音郭楞蒙古自治州', 652900: '阿克苏地区', 653000: '克孜勒苏柯尔克孜自治州', 653100: '喀什地区', 653200: '和田地区', 654000: '伊犁哈萨克自治州', 654200: '塔城地区', 654300: '阿勒泰地区', 659000: '自治区直辖县级行政区划', 710100: '台北市', 710200: '高雄市', 710300: '台南市', 710400: '台中市', 710500: '金门县', 710600: '南投县', 710700: '基隆市', 710800: '新竹市', 710900: '嘉义市', 711100: '新北市', 711200: '宜兰县', 711300: '新竹县', 711400: '桃园县', 711500: '苗栗县', 711700: '彰化县', 711900: '嘉义县', 712100: '云林县', 712400: '屏东县', 712500: '台东县', 712600: '花莲县', 712700: '澎湖县', 712800: '连江县', 810100: '香港岛', 810200: '九龙', 810300: '新界', 820100: '澳门半岛', 820200: '离岛', 900400: '阿富汗', 900800: '阿尔巴尼亚', 901000: '南极洲', 901200: '阿尔及利亚', 901600: '美属萨摩亚', 902000: '安道尔', 902400: '安哥拉', 902800: '安提瓜和巴布达', 903100: '阿塞拜疆', 903200: '阿根廷', 903600: '澳大利亚', 904000: '奥地利', 904400: '巴哈马', 904800: '巴林', 905000: '孟加拉', 905100: '亚美尼亚', 905200: '巴巴多斯', 905600: '比利时', 906000: '百慕大', 906400: '不丹', 906800: '玻利维亚', 907000: '波黑', 907200: '博茨瓦纳', 907400: '布韦岛', 907600: '巴西', 908400: '伯利兹', 908600: '英属印度洋领地', 909000: '所罗门群岛', 909200: '英属维尔京群岛', 909600: '文莱', 910000: '保加利亚', 910400: '缅甸', 910800: '布隆迪', 911200: '白俄罗斯', 911600: '柬埔寨', 912000: '喀麦隆', 912400: '加拿大', 913200: '佛得角', 913600: '开曼群岛', 914000: '中非', 914400: '斯里兰卡', 914800: '乍得', 915200: '智利', 916200: '圣诞岛', 916600: '科科斯群岛', 917000: '哥伦比亚', 917400: '科摩罗', 917500: '马约特', 917800: '刚果（布）', 918000: '刚果（金）', 918400: '库克群岛', 918800: '哥斯达黎加', 919100: '克罗地亚', 919200: '古巴', 919600: '塞浦路斯', 920300: '捷克', 920400: '贝宁', 920800: '丹麦', 921200: '多米尼克', 921400: '多米尼加', 921800: '厄瓜多尔', 922200: '萨尔瓦多', 922600: '赤道几内亚', 923100: '埃塞俄比亚', 923200: '厄立特里亚', 923300: '爱沙尼亚', 923400: '法罗群岛', 923800: '马尔维纳斯群岛（ 福克兰）', 923900: '南乔治亚岛和南桑威奇群岛', 924200: '斐济群岛', 924600: '芬兰', 924800: '奥兰群岛', 925000: '法国', 925400: '法属圭亚那', 925800: '法属波利尼西亚', 926000: '法属南部领地', 926200: '吉布提', 926600: '加蓬', 926800: '格鲁吉亚', 927000: '冈比亚', 927500: '巴勒斯坦', 927600: '德国', 928800: '加纳', 929200: '直布罗陀', 929600: '基里巴斯', 930000: '希腊', 930400: '格陵兰', 930800: '格林纳达', 931200: '瓜德罗普', 931600: '关岛', 932000: '危地马拉', 932400: '几内亚', 932800: '圭亚那', 933200: '海地', 933400: '赫德岛和麦克唐纳群岛', 933600: '梵蒂冈', 934000: '洪都拉斯', 934800: '匈牙利', 935200: '冰岛', 935600: '印度', 936000: '印尼', 936400: '伊朗', 936800: '伊拉克', 937200: '爱尔兰', 937600: '以色列', 938000: '意大利', 938400: '科特迪瓦', 938800: '牙买加', 939200: '日本', 939800: '哈萨克斯坦', 940000: '约旦', 940400: '肯尼亚', 940800: '朝鲜 北朝鲜', 941000: '韩国', 941400: '科威特', 941700: '吉尔吉斯斯坦', 941800: '老挝', 942200: '黎巴嫩', 942600: '莱索托', 942800: '拉脱维亚', 943000: '利比里亚', 943400: '利比亚', 943800: '列支敦士登', 944000: '立陶宛', 944200: '卢森堡', 945000: '马达加斯加', 945400: '马拉维', 945800: '马来西亚', 946200: '马尔代夫', 946600: '马里', 947000: '马耳他', 947400: '马提尼克', 947800: '毛里塔尼亚', 948000: '毛里求斯', 948400: '墨西哥', 949200: '摩纳哥', 949600: '蒙古国', 949800: '摩尔多瓦', 949900: '黑山', 950000: '蒙塞拉特岛', 950400: '摩洛哥', 950800: '莫桑比克', 951200: '阿曼', 951600: '纳米比亚', 952000: '瑙鲁', 952400: '尼泊尔', 952800: '荷兰', 953300: '阿鲁巴', 953500: '荷兰加勒比区', 954000: '新喀里多尼亚', 954800: '瓦努阿图', 955400: '新西兰', 955800: '尼加拉瓜', 956200: '尼日尔', 956600: '尼日利亚', 957000: '纽埃', 957400: '诺福克岛', 957800: '挪威', 958000: '北马里亚纳群岛', 958100: '美国本土外小岛屿', 958300: '密克罗尼西亚联邦', 958400: '马绍尔群岛', 958500: '帕劳', 958600: '巴基斯坦', 959100: '巴拿马', 959800: '巴布亚新几内亚', 960000: '巴拉圭', 960400: '秘鲁', 960800: '菲律宾', 961200: '皮特凯恩群岛', 961600: '波兰', 962000: '葡萄牙', 962400: '几内亚比绍', 962600: '东帝汶', 963000: '波多黎各', 963400: '卡塔尔', 963800: '留尼汪', 964200: '罗马尼亚', 964300: '俄罗斯', 964600: '卢旺达', 965200: '圣巴泰勒米岛', 965400: '圣赫勒拿', 965900: '圣基茨和尼维斯', 966000: '安圭拉', 966200: '圣卢西亚', 966300: '法属圣马丁', 966600: '圣皮埃尔和密克隆', 967000: '圣文森特和格林纳丁斯', 967400: '圣马力诺', 967800: '圣多美和普林西比', 968200: '沙特阿拉伯', 968600: '塞内加尔', 968800: '塞尔维亚', 969000: '塞舌尔', 969400: '塞拉利昂', 970200: '新加坡', 970300: '斯洛伐克', 970400: '越南', 970500: '斯洛文尼亚', 970600: '索马里', 971000: '南非', 971600: '津巴布韦', 972400: '西班牙', 972800: '南苏丹', 972900: '苏丹', 973200: '西撒哈拉', 974000: '苏里南', 974400: '斯瓦尔巴群岛和 扬马延岛', 974800: '斯威士兰', 975200: '瑞典', 975600: '瑞士', 976000: '叙利亚', 976200: '塔吉克斯坦', 976400: '泰国', 976800: '多哥', 977200: '托克劳', 977600: '汤加', 978000: '特立尼达和多巴哥', 978400: '阿联酋', 978800: '突尼斯', 979200: '土耳其', 979500: '土库曼斯坦', 979600: '特克斯和凯科斯群岛', 979800: '图瓦卢', 980000: '乌干达', 980400: '乌克兰', 980700: '马其顿', 981800: '埃及', 982600: '英国', 983100: '根西岛', 983200: '泽西岛', 983300: '马恩岛', 983400: '坦桑尼亚', 984000: '美国', 985000: '美属维尔京群岛', 985400: '布基纳法索', 985800: '乌拉圭', 986000: '乌兹别克斯坦', 986200: '委内瑞拉', 987600: '瓦利斯和富图纳', 988200: '萨摩亚', 988700: '也门', 989400: '赞比亚' &#125;, county_list: &#123; 110101: '东城区', 110102: '西城区', 110105: '朝阳区', 110106: '丰台区', 110107: '石景山区', 110108: '海淀区', 110109: '门头沟区', 110111: '房山区', 110112: '通州区', 110113: '顺义区', 110114: '昌平区', 110115: '大兴区', 110116: '怀柔区', 110117: '平谷区', 110118: '密云区', 110119: '延庆区', 120101: '和平区', 120102: '河东区', 120103: '河西区', 120104: '南开区', 120105: '河北区', 120106: '红桥区', 120110: '东丽区', 120111: '西青区', 120112: '津南区', 120113: '北辰区', 120114: '武清区', 120115: '宝坻区', 120116: '滨海新区', 120117: '宁河区', 120118: '静海区', 120119: '蓟州区', 130102: '长安区', 130104: '桥西区', 130105: '新华区', 130107: '井陉矿区', 130108: '裕华区', 130109: '藁城区', 130110: '鹿泉区', 130111: '栾城区', 130121: '井陉县', 130123: '正定县', 130125: '行唐县', 130126: '灵寿县', 130127: '高邑县', 130128: '深泽县', 130129: '赞皇县', 130130: '无极县', 130131: '平山县', 130132: '元氏县', 130133: '赵县', 130181: '辛集市', 130183: '晋州市', 130184: '新乐市', 130202: '路南区', 130203: '路北区', 130204: '古冶区', 130205: '开平区', 130207: '丰南区', 130208: '丰润区', 130209: '曹妃甸区', 130224: '滦南县', 130225: '乐亭县', 130227: '迁西县', 130229: '玉田县', 130281: '遵化市', 130283: '迁安市', 130284: '滦州市', 130302: '海港区', 130303: '山海关区', 130304: '北戴河区', 130306: '抚宁区', 130321: '青龙满族自治县', 130322: '昌黎县', 130324: '卢龙县', 130390: '经济技术开发区', 130402: '邯山区', 130403: '丛台区', 130404: '复兴区', 130406: '峰峰矿区', 130407: '肥乡区', 130408: '永年区', 130423: '临漳县', 130424: '成安县', 130425: '大名县', 130426: '涉县', 130427: '磁县', 130430: '邱县', 130431: '鸡泽县', 130432: '广平县', 130433: '馆陶县', 130434: '魏县', 130435: '曲周县', 130481: '武安市', 130502: '桥东区', 130503: '桥西区', 130521: '邢台县', 130522: '临城县', 130523: '内丘县', 130524: '柏乡县', 130525: '隆尧县', 130526: '任县', 130527: '南和县', 130528: '宁晋县', 130529: '巨鹿县', 130530: '新河县', 130531: '广宗县', 130532: '平乡县', 130533: '威县', 130534: '清河县', 130535: '临西县', 130581: '南宫市', 130582: '沙河市', 130602: '竞秀区', 130606: '莲池区', 130607: '满城区', 130608: '清苑区', 130609: '徐水区', 130623: '涞水县', 130624: '阜平县', 130626: '定兴县', 130627: '唐县', 130628: '高阳县', 130629: '容城县', 130630: '涞源县', 130631: '望都县', 130632: '安新县', 130633: '易县', 130634: '曲阳县', 130635: '蠡县', 130636: '顺平县', 130637: '博野县', 130638: '雄县', 130681: '涿州市', 130682: '定州市', 130683: '安国市', 130684: '高碑店市', 130702: '桥东区', 130703: '桥西区', 130705: '宣化区', 130706: '下花园区', 130708: '万全区', 130709: '崇礼区', 130722: '张北县', 130723: '康保县', 130724: '沽源县', 130725: '尚义县', 130726: '蔚县', 130727: '阳原县', 130728: '怀安县', 130730: '怀来县', 130731: '涿鹿县', 130732: '赤城县', 130802: '双桥区', 130803: '双滦区', 130804: '鹰手营子矿区', 130821: '承德县', 130822: '兴隆县', 130824: '滦平县', 130825: '隆化县', 130826: '丰宁满族自治县', 130827: '宽城满族自治县', 130828: '围场满族蒙古族自治县', 130881: '平泉市', 130902: '新华区', 130903: '运河区', 130921: '沧县', 130922: '青县', 130923: '东光县', 130924: '海兴县', 130925: '盐山县', 130926: '肃宁县', 130927: '南皮县', 130928: '吴桥县', 130929: '献县', 130930: '孟村回族自治县', 130981: '泊头市', 130982: '任丘市', 130983: '黄骅市', 130984: '河间市', 131002: '安次区', 131003: '广阳区', 131022: '固安县', 131023: '永清县', 131024: '香河县', 131025: '大城县', 131026: '文安县', 131028: '大厂回族自治县', 131081: '霸州市', 131082: '三河市', 131090: '开发区', 131102: '桃城区', 131103: '冀州区', 131121: '枣强县', 131122: '武邑县', 131123: '武强县', 131124: '饶阳县', 131125: '安平县', 131126: '故城县', 131127: '景县', 131128: '阜城县', 131182: '深州市', 140105: '小店区', 140106: '迎泽区', 140107: '杏花岭区', 140108: '尖草坪区', 140109: '万柏林区', 140110: '晋源区', 140121: '清徐县', 140122: '阳曲县', 140123: '娄烦县', 140181: '古交市', 140212: '新荣区', 140213: '平城区', 140214: '云冈区', 140215: '云州区', 140221: '阳高县', 140222: '天镇县', 140223: '广灵县', 140224: '灵丘县', 140225: '浑源县', 140226: '左云县', 140302: '城区', 140303: '矿区', 140311: '郊区', 140321: '平定县', 140322: '盂县', 140403: '潞州区', 140404: '上党区', 140405: '屯留区', 140406: '潞城区', 140423: '襄垣县', 140425: '平顺县', 140426: '黎城县', 140427: '壶关县', 140428: '长子县', 140429: '武乡县', 140430: '沁县', 140431: '沁源县', 140502: '城区', 140521: '沁水县', 140522: '阳城县', 140524: '陵川县', 140525: '泽州县', 140581: '高平市', 140602: '朔城区', 140603: '平鲁区', 140621: '山阴县', 140622: '应县', 140623: '右玉县', 140681: '怀仁市', 140702: '榆次区', 140721: '榆社县', 140722: '左权县', 140723: '和顺县', 140724: '昔阳县', 140725: '寿阳县', 140726: '太谷县', 140727: '祁县', 140728: '平遥县', 140729: '灵石县', 140781: '介休市', 140802: '盐湖区', 140821: '临猗县', 140822: '万荣县', 140823: '闻喜县', 140824: '稷山县', 140825: '新绛县', 140826: '绛县', 140827: '垣曲县', 140828: '夏县', 140829: '平陆县', 140830: '芮城县', 140881: '永济市', 140882: '河津市', 140902: '忻府区', 140921: '定襄县', 140922: '五台县', 140923: '代县', 140924: '繁峙县', 140925: '宁武县', 140926: '静乐县', 140927: '神池县', 140928: '五寨县', 140929: '岢岚县', 140930: '河曲县', 140931: '保德县', 140932: '偏关县', 140981: '原平市', 141002: '尧都区', 141021: '曲沃县', 141022: '翼城县', 141023: '襄汾县', 141024: '洪洞县', 141025: '古县', 141026: '安泽县', 141027: '浮山县', 141028: '吉县', 141029: '乡宁县', 141030: '大宁县', 141031: '隰县', 141032: '永和县', 141033: '蒲县', 141034: '汾西县', 141081: '侯马市', 141082: '霍州市', 141102: '离石区', 141121: '文水县', 141122: '交城县', 141123: '兴县', 141124: '临县', 141125: '柳林县', 141126: '石楼县', 141127: '岚县', 141128: '方山县', 141129: '中阳县', 141130: '交口县', 141181: '孝义市', 141182: '汾阳市', 150102: '新城区', 150103: '回民区', 150104: '玉泉区', 150105: '赛罕区', 150121: '土默特左旗', 150122: '托克托县', 150123: '和林格尔县', 150124: '清水河县', 150125: '武川县', 150202: '东河区', 150203: '昆都仑区', 150204: '青山区', 150205: '石拐区', 150206: '白云鄂博矿区', 150207: '九原区', 150221: '土默特右旗', 150222: '固阳县', 150223: '达尔罕茂明安联合旗', 150302: '海勃湾区', 150303: '海南区', 150304: '乌达区', 150402: '红山区', 150403: '元宝山区', 150404: '松山区', 150421: '阿鲁科尔沁旗', 150422: '巴林左旗', 150423: '巴林右旗', 150424: '林西县', 150425: '克什克腾旗', 150426: '翁牛特旗', 150428: '喀喇沁旗', 150429: '宁城县', 150430: '敖汉旗', 150502: '科尔沁区', 150521: '科尔沁左翼中旗', 150522: '科尔沁左翼后旗', 150523: '开鲁县', 150524: '库伦旗', 150525: '奈曼旗', 150526: '扎鲁特旗', 150581: '霍林郭勒市', 150602: '东胜区', 150603: '康巴什区', 150621: '达拉特旗', 150622: '准格尔旗', 150623: '鄂托克前旗', 150624: '鄂托克旗', 150625: '杭锦旗', 150626: '乌审旗', 150627: '伊金霍洛旗', 150702: '海拉尔区', 150703: '扎赉诺尔区', 150721: '阿荣旗', 150722: '莫力达瓦达斡尔族自治旗', 150723: '鄂伦春自治旗', 150724: '鄂温克族自治旗', 150725: '陈巴尔虎旗', 150726: '新巴尔虎左旗', 150727: '新巴尔虎右旗', 150781: '满洲里市', 150782: '牙克石市', 150783: '扎兰屯市', 150784: '额尔古纳市', 150785: '根河市', 150802: '临河区', 150821: '五原县', 150822: '磴口县', 150823: '乌拉特前旗', 150824: '乌拉特中旗', 150825: '乌拉特后旗', 150826: '杭锦后旗', 150902: '集宁区', 150921: '卓资县', 150922: '化德县', 150923: '商都县', 150924: '兴和县', 150925: '凉城县', 150926: '察哈尔右翼前旗', 150927: '察哈尔右翼中旗', 150928: '察哈尔右翼后旗', 150929: '四子王旗', 150981: '丰镇市', 152201: '乌兰浩特市', 152202: '阿尔山市', 152221: '科尔沁右翼前旗', 152222: '科尔沁右翼中旗', 152223: '扎赉特旗', 152224: '突泉县', 152501: '二连浩特市', 152502: '锡林浩特市', 152522: '阿巴嘎旗', 152523: '苏尼特左旗', 152524: '苏尼特右旗', 152525: '东乌珠穆沁旗', 152526: '西乌珠穆沁旗', 152527: '太仆寺旗', 152528: '镶黄旗', 152529: '正镶白旗', 152530: '正蓝旗', 152531: '多伦县', 152921: '阿拉善左旗', 152922: '阿拉善右旗', 152923: '额济纳旗', 210102: '和平区', 210103: '沈河区', 210104: '大东区', 210105: '皇姑区', 210106: '铁西区', 210111: '苏家屯区', 210112: '浑南区', 210113: '沈北新区', 210114: '于洪区', 210115: '辽中区', 210123: '康平县', 210124: '法库县', 210181: '新民市', 210190: '经济技术开发区', 210202: '中山区', 210203: '西岗区', 210204: '沙河口区', 210211: '甘井子区', 210212: '旅顺口区', 210213: '金州区', 210214: '普兰店区', 210224: '长海县', 210281: '瓦房店市', 210283: '庄河市', 210302: '铁东区', 210303: '铁西区', 210304: '立山区', 210311: '千山区', 210321: '台安县', 210323: '岫岩满族自治县', 210381: '海城市', 210390: '高新区', 210402: '新抚区', 210403: '东洲区', 210404: '望花区', 210411: '顺城区', 210421: '抚顺县', 210422: '新宾满族自治县', 210423: '清原满族自治县', 210502: '平山区', 210503: '溪湖区', 210504: '明山区', 210505: '南芬区', 210521: '本溪满族自治县', 210522: '桓仁满族自治县', 210602: '元宝区', 210603: '振兴区', 210604: '振安区', 210624: '宽甸满族自治县', 210681: '东港市', 210682: '凤城市', 210702: '古塔区', 210703: '凌河区', 210711: '太和区', 210726: '黑山县', 210727: '义县', 210781: '凌海市', 210782: '北镇市', 210793: '经济技术开发区', 210802: '站前区', 210803: '西市区', 210804: '鲅鱼圈区', 210811: '老边区', 210881: '盖州市', 210882: '大石桥市', 210902: '海州区', 210903: '新邱区', 210904: '太平区', 210905: '清河门区', 210911: '细河区', 210921: '阜新蒙古族自治县', 210922: '彰武县', 211002: '白塔区', 211003: '文圣区', 211004: '宏伟区', 211005: '弓长岭区', 211011: '太子河区', 211021: '辽阳县', 211081: '灯塔市', 211102: '双台子区', 211103: '兴隆台区', 211104: '大洼区', 211122: '盘山县', 211202: '银州区', 211204: '清河区', 211221: '铁岭县', 211223: '西丰县', 211224: '昌图县', 211281: '调兵山市', 211282: '开原市', 211302: '双塔区', 211303: '龙城区', 211321: '朝阳县', 211322: '建平县', 211324: '喀喇沁左翼蒙古族自治县', 211381: '北票市', 211382: '凌源市', 211402: '连山区', 211403: '龙港区', 211404: '南票区', 211421: '绥中县', 211422: '建昌县', 211481: '兴城市', 220102: '南关区', 220103: '宽城区', 220104: '朝阳区', 220105: '二道区', 220106: '绿园区', 220112: '双阳区', 220113: '九台区', 220122: '农安县', 220182: '榆树市', 220183: '德惠市', 220192: '经济技术开发区', 220202: '昌邑区', 220203: '龙潭区', 220204: '船营区', 220211: '丰满区', 220221: '永吉县', 220281: '蛟河市', 220282: '桦甸市', 220283: '舒兰市', 220284: '磐石市', 220302: '铁西区', 220303: '铁东区', 220322: '梨树县', 220323: '伊通满族自治县', 220381: '公主岭市', 220382: '双辽市', 220402: '龙山区', 220403: '西安区', 220421: '东丰县', 220422: '东辽县', 220502: '东昌区', 220503: '二道江区', 220521: '通化县', 220523: '辉南县', 220524: '柳河县', 220581: '梅河口市', 220582: '集安市', 220602: '浑江区', 220605: '江源区', 220621: '抚松县', 220622: '靖宇县', 220623: '长白朝鲜族自治县', 220681: '临江市', 220702: '宁江区', 220721: '前郭尔罗斯蒙古族自治县', 220722: '长岭县', 220723: '乾安县', 220781: '扶余市', 220802: '洮北区', 220821: '镇赉县', 220822: '通榆县', 220881: '洮南市', 220882: '大安市', 222401: '延吉市', 222402: '图们市', 222403: '敦化市', 222404: '珲春市', 222405: '龙井市', 222406: '和龙市', 222424: '汪清县', 222426: '安图县', 230102: '道里区', 230103: '南岗区', 230104: '道外区', 230108: '平房区', 230109: '松北区', 230110: '香坊区', 230111: '呼兰区', 230112: '阿城区', 230113: '双城区', 230123: '依兰县', 230124: '方正县', 230125: '宾县', 230126: '巴彦县', 230127: '木兰县', 230128: '通河县', 230129: '延寿县', 230183: '尚志市', 230184: '五常市', 230202: '龙沙区', 230203: '建华区', 230204: '铁锋区', 230205: '昂昂溪区', 230206: '富拉尔基区', 230207: '碾子山区', 230208: '梅里斯达斡尔族区', 230221: '龙江县', 230223: '依安县', 230224: '泰来县', 230225: '甘南县', 230227: '富裕县', 230229: '克山县', 230230: '克东县', 230231: '拜泉县', 230281: '讷河市', 230302: '鸡冠区', 230303: '恒山区', 230304: '滴道区', 230305: '梨树区', 230306: '城子河区', 230307: '麻山区', 230321: '鸡东县', 230381: '虎林市', 230382: '密山市', 230402: '向阳区', 230403: '工农区', 230404: '南山区', 230405: '兴安区', 230406: '东山区', 230407: '兴山区', 230421: '萝北县', 230422: '绥滨县', 230502: '尖山区', 230503: '岭东区', 230505: '四方台区', 230506: '宝山区', 230521: '集贤县', 230522: '友谊县', 230523: '宝清县', 230524: '饶河县', 230602: '萨尔图区', 230603: '龙凤区', 230604: '让胡路区', 230605: '红岗区', 230606: '大同区', 230621: '肇州县', 230622: '肇源县', 230623: '林甸县', 230624: '杜尔伯特蒙古族自治县', 230702: '伊春区', 230703: '南岔区', 230704: '友好区', 230705: '西林区', 230706: '翠峦区', 230707: '新青区', 230708: '美溪区', 230709: '金山屯区', 230710: '五营区', 230711: '乌马河区', 230712: '汤旺河区', 230713: '带岭区', 230714: '乌伊岭区', 230715: '红星区', 230716: '上甘岭区', 230722: '嘉荫县', 230781: '铁力市', 230803: '向阳区', 230804: '前进区', 230805: '东风区', 230811: '郊区', 230822: '桦南县', 230826: '桦川县', 230828: '汤原县', 230881: '同江市', 230882: '富锦市', 230883: '抚远市', 230902: '新兴区', 230903: '桃山区', 230904: '茄子河区', 230921: '勃利县', 231002: '东安区', 231003: '阳明区', 231004: '爱民区', 231005: '西安区', 231025: '林口县', 231081: '绥芬河市', 231083: '海林市', 231084: '宁安市', 231085: '穆棱市', 231086: '东宁市', 231102: '爱辉区', 231121: '嫩江县', 231123: '逊克县', 231124: '孙吴县', 231181: '北安市', 231182: '五大连池市', 231202: '北林区', 231221: '望奎县', 231222: '兰西县', 231223: '青冈县', 231224: '庆安县', 231225: '明水县', 231226: '绥棱县', 231281: '安达市', 231282: '肇东市', 231283: '海伦市', 232701: '漠河市', 232721: '呼玛县', 232722: '塔河县', 232790: '松岭区', 232791: '呼中区', 232792: '加格达奇区', 232793: '新林区', 310101: '黄浦区', 310104: '徐汇区', 310105: '长宁区', 310106: '静安区', 310107: '普陀区', 310109: '虹口区', 310110: '杨浦区', 310112: '闵行区', 310113: '宝山区', 310114: '嘉定区', 310115: '浦东新区', 310116: '金山区', 310117: '松江区', 310118: '青浦区', 310120: '奉贤区', 310151: '崇明区', 320102: '玄武区', 320104: '秦淮区', 320105: '建邺区', 320106: '鼓楼区', 320111: '浦口区', 320113: '栖霞区', 320114: '雨花台区', 320115: '江宁区', 320116: '六合区', 320117: '溧水区', 320118: '高淳区', 320205: '锡山区', 320206: '惠山区', 320211: '滨湖区', 320213: '梁溪区', 320214: '新吴区', 320281: '江阴市', 320282: '宜兴市', 320302: '鼓楼区', 320303: '云龙区', 320305: '贾汪区', 320311: '泉山区', 320312: '铜山区', 320321: '丰县', 320322: '沛县', 320324: '睢宁县', 320381: '新沂市', 320382: '邳州市', 320391: '工业园区', 320402: '天宁区', 320404: '钟楼区', 320411: '新北区', 320412: '武进区', 320413: '金坛区', 320481: '溧阳市', 320505: '虎丘区', 320506: '吴中区', 320507: '相城区', 320508: '姑苏区', 320509: '吴江区', 320581: '常熟市', 320582: '张家港市', 320583: '昆山市', 320585: '太仓市', 320590: '工业园区', 320591: '高新区', 320602: '崇川区', 320611: '港闸区', 320612: '通州区', 320623: '如东县', 320681: '启东市', 320682: '如皋市', 320684: '海门市', 320685: '海安市', 320691: '高新区', 320703: '连云区', 320706: '海州区', 320707: '赣榆区', 320722: '东海县', 320723: '灌云县', 320724: '灌南县', 320803: '淮安区', 320804: '淮阴区', 320812: '清江浦区', 320813: '洪泽区', 320826: '涟水县', 320830: '盱眙县', 320831: '金湖县', 320890: '经济开发区', 320902: '亭湖区', 320903: '盐都区', 320904: '大丰区', 320921: '响水县', 320922: '滨海县', 320923: '阜宁县', 320924: '射阳县', 320925: '建湖县', 320981: '东台市', 321002: '广陵区', 321003: '邗江区', 321012: '江都区', 321023: '宝应县', 321081: '仪征市', 321084: '高邮市', 321090: '经济开发区', 321102: '京口区', 321111: '润州区', 321112: '丹徒区', 321181: '丹阳市', 321182: '扬中市', 321183: '句容市', 321202: '海陵区', 321203: '高港区', 321204: '姜堰区', 321281: '兴化市', 321282: '靖江市', 321283: '泰兴市', 321302: '宿城区', 321311: '宿豫区', 321322: '沭阳县', 321323: '泗阳县', 321324: '泗洪县', 330102: '上城区', 330103: '下城区', 330104: '江干区', 330105: '拱墅区', 330106: '西湖区', 330108: '滨江区', 330109: '萧山区', 330110: '余杭区', 330111: '富阳区', 330112: '临安区', 330122: '桐庐县', 330127: '淳安县', 330182: '建德市', 330203: '海曙区', 330205: '江北区', 330206: '北仑区', 330211: '镇海区', 330212: '鄞州区', 330213: '奉化区', 330225: '象山县', 330226: '宁海县', 330281: '余姚市', 330282: '慈溪市', 330302: '鹿城区', 330303: '龙湾区', 330304: '瓯海区', 330305: '洞头区', 330324: '永嘉县', 330326: '平阳县', 330327: '苍南县', 330328: '文成县', 330329: '泰顺县', 330381: '瑞安市', 330382: '乐清市', 330402: '南湖区', 330411: '秀洲区', 330421: '嘉善县', 330424: '海盐县', 330481: '海宁市', 330482: '平湖市', 330483: '桐乡市', 330502: '吴兴区', 330503: '南浔区', 330521: '德清县', 330522: '长兴县', 330523: '安吉县', 330602: '越城区', 330603: '柯桥区', 330604: '上虞区', 330624: '新昌县', 330681: '诸暨市', 330683: '嵊州市', 330702: '婺城区', 330703: '金东区', 330723: '武义县', 330726: '浦江县', 330727: '磐安县', 330781: '兰溪市', 330782: '义乌市', 330783: '东阳市', 330784: '永康市', 330802: '柯城区', 330803: '衢江区', 330822: '常山县', 330824: '开化县', 330825: '龙游县', 330881: '江山市', 330902: '定海区', 330903: '普陀区', 330921: '岱山县', 330922: '嵊泗县', 331002: '椒江区', 331003: '黄岩区', 331004: '路桥区', 331022: '三门县', 331023: '天台县', 331024: '仙居县', 331081: '温岭市', 331082: '临海市', 331083: '玉环市', 331102: '莲都区', 331121: '青田县', 331122: '缙云县', 331123: '遂昌县', 331124: '松阳县', 331125: '云和县', 331126: '庆元县', 331127: '景宁畲族自治县', 331181: '龙泉市', 340102: '瑶海区', 340103: '庐阳区', 340104: '蜀山区', 340111: '包河区', 340121: '长丰县', 340122: '肥东县', 340123: '肥西县', 340124: '庐江县', 340181: '巢湖市', 340190: '高新技术开发区', 340191: '经济技术开发区', 340202: '镜湖区', 340203: '弋江区', 340207: '鸠江区', 340208: '三山区', 340221: '芜湖县', 340222: '繁昌县', 340223: '南陵县', 340225: '无为县', 340302: '龙子湖区', 340303: '蚌山区', 340304: '禹会区', 340311: '淮上区', 340321: '怀远县', 340322: '五河县', 340323: '固镇县', 340402: '大通区', 340403: '田家庵区', 340404: '谢家集区', 340405: '八公山区', 340406: '潘集区', 340421: '凤台县', 340422: '寿县', 340503: '花山区', 340504: '雨山区', 340506: '博望区', 340521: '当涂县', 340522: '含山县', 340523: '和县', 340602: '杜集区', 340603: '相山区', 340604: '烈山区', 340621: '濉溪县', 340705: '铜官区', 340706: '义安区', 340711: '郊区', 340722: '枞阳县', 340802: '迎江区', 340803: '大观区', 340811: '宜秀区', 340822: '怀宁县', 340824: '潜山县', 340825: '太湖县', 340826: '宿松县', 340827: '望江县', 340828: '岳西县', 340881: '桐城市', 341002: '屯溪区', 341003: '黄山区', 341004: '徽州区', 341021: '歙县', 341022: '休宁县', 341023: '黟县', 341024: '祁门县', 341102: '琅琊区', 341103: '南谯区', 341122: '来安县', 341124: '全椒县', 341125: '定远县', 341126: '凤阳县', 341181: '天长市', 341182: '明光市', 341202: '颍州区', 341203: '颍东区', 341204: '颍泉区', 341221: '临泉县', 341222: '太和县', 341225: '阜南县', 341226: '颍上县', 341282: '界首市', 341302: '埇桥区', 341321: '砀山县', 341322: '萧县', 341323: '灵璧县', 341324: '泗县', 341390: '经济开发区', 341502: '金安区', 341503: '裕安区', 341504: '叶集区', 341522: '霍邱县', 341523: '舒城县', 341524: '金寨县', 341525: '霍山县', 341602: '谯城区', 341621: '涡阳县', 341622: '蒙城县', 341623: '利辛县', 341702: '贵池区', 341721: '东至县', 341722: '石台县', 341723: '青阳县', 341802: '宣州区', 341821: '郎溪县', 341822: '广德县', 341823: '泾县', 341824: '绩溪县', 341825: '旌德县', 341881: '宁国市', 350102: '鼓楼区', 350103: '台江区', 350104: '仓山区', 350105: '马尾区', 350111: '晋安区', 350112: '长乐区', 350121: '闽侯县', 350122: '连江县', 350123: '罗源县', 350124: '闽清县', 350125: '永泰县', 350128: '平潭县', 350181: '福清市', 350203: '思明区', 350205: '海沧区', 350206: '湖里区', 350211: '集美区', 350212: '同安区', 350213: '翔安区', 350302: '城厢区', 350303: '涵江区', 350304: '荔城区', 350305: '秀屿区', 350322: '仙游县', 350402: '梅列区', 350403: '三元区', 350421: '明溪县', 350423: '清流县', 350424: '宁化县', 350425: '大田县', 350426: '尤溪县', 350427: '沙县', 350428: '将乐县', 350429: '泰宁县', 350430: '建宁县', 350481: '永安市', 350502: '鲤城区', 350503: '丰泽区', 350504: '洛江区', 350505: '泉港区', 350521: '惠安县', 350524: '安溪县', 350525: '永春县', 350526: '德化县', 350527: '金门县', 350581: '石狮市', 350582: '晋江市', 350583: '南安市', 350602: '芗城区', 350603: '龙文区', 350622: '云霄县', 350623: '漳浦县', 350624: '诏安县', 350625: '长泰县', 350626: '东山县', 350627: '南靖县', 350628: '平和县', 350629: '华安县', 350681: '龙海市', 350702: '延平区', 350703: '建阳区', 350721: '顺昌县', 350722: '浦城县', 350723: '光泽县', 350724: '松溪县', 350725: '政和县', 350781: '邵武市', 350782: '武夷山市', 350783: '建瓯市', 350802: '新罗区', 350803: '永定区', 350821: '长汀县', 350823: '上杭县', 350824: '武平县', 350825: '连城县', 350881: '漳平市', 350902: '蕉城区', 350921: '霞浦县', 350922: '古田县', 350923: '屏南县', 350924: '寿宁县', 350925: '周宁县', 350926: '柘荣县', 350981: '福安市', 350982: '福鼎市', 360102: '东湖区', 360103: '西湖区', 360104: '青云谱区', 360105: '湾里区', 360111: '青山湖区', 360112: '新建区', 360121: '南昌县', 360123: '安义县', 360124: '进贤县', 360190: '经济技术开发区', 360192: '高新区', 360202: '昌江区', 360203: '珠山区', 360222: '浮梁县', 360281: '乐平市', 360302: '安源区', 360313: '湘东区', 360321: '莲花县', 360322: '上栗县', 360323: '芦溪县', 360402: '濂溪区', 360403: '浔阳区', 360404: '柴桑区', 360423: '武宁县', 360424: '修水县', 360425: '永修县', 360426: '德安县', 360428: '都昌县', 360429: '湖口县', 360430: '彭泽县', 360481: '瑞昌市', 360482: '共青城市', 360483: '庐山市', 360490: '经济技术开发区', 360502: '渝水区', 360521: '分宜县', 360602: '月湖区', 360603: '余江区', 360681: '贵溪市', 360702: '章贡区', 360703: '南康区', 360704: '赣县区', 360722: '信丰县', 360723: '大余县', 360724: '上犹县', 360725: '崇义县', 360726: '安远县', 360727: '龙南县', 360728: '定南县', 360729: '全南县', 360730: '宁都县', 360731: '于都县', 360732: '兴国县', 360733: '会昌县', 360734: '寻乌县', 360735: '石城县', 360781: '瑞金市', 360802: '吉州区', 360803: '青原区', 360821: '吉安县', 360822: '吉水县', 360823: '峡江县', 360824: '新干县', 360825: '永丰县', 360826: '泰和县', 360827: '遂川县', 360828: '万安县', 360829: '安福县', 360830: '永新县', 360881: '井冈山市', 360902: '袁州区', 360921: '奉新县', 360922: '万载县', 360923: '上高县', 360924: '宜丰县', 360925: '靖安县', 360926: '铜鼓县', 360981: '丰城市', 360982: '樟树市', 360983: '高安市', 361002: '临川区', 361003: '东乡区', 361021: '南城县', 361022: '黎川县', 361023: '南丰县', 361024: '崇仁县', 361025: '乐安县', 361026: '宜黄县', 361027: '金溪县', 361028: '资溪县', 361030: '广昌县', 361102: '信州区', 361103: '广丰区', 361121: '上饶县', 361123: '玉山县', 361124: '铅山县', 361125: '横峰县', 361126: '弋阳县', 361127: '余干县', 361128: '鄱阳县', 361129: '万年县', 361130: '婺源县', 361181: '德兴市', 370102: '历下区', 370103: '市中区', 370104: '槐荫区', 370105: '天桥区', 370112: '历城区', 370113: '长清区', 370114: '章丘区', 370115: '济阳区', 370116: '莱芜区', 370117: '钢城区', 370124: '平阴县', 370126: '商河县', 370190: '高新区', 370202: '市南区', 370203: '市北区', 370211: '黄岛区', 370212: '崂山区', 370213: '李沧区', 370214: '城阳区', 370215: '即墨区', 370281: '胶州市', 370283: '平度市', 370285: '莱西市', 370290: '开发区', 370302: '淄川区', 370303: '张店区', 370304: '博山区', 370305: '临淄区', 370306: '周村区', 370321: '桓台县', 370322: '高青县', 370323: '沂源县', 370402: '市中区', 370403: '薛城区', 370404: '峄城区', 370405: '台儿庄区', 370406: '山亭区', 370481: '滕州市', 370502: '东营区', 370503: '河口区', 370505: '垦利区', 370522: '利津县', 370523: '广饶县', 370602: '芝罘区', 370611: '福山区', 370612: '牟平区', 370613: '莱山区', 370634: '长岛县', 370681: '龙口市', 370682: '莱阳市', 370683: '莱州市', 370684: '蓬莱市', 370685: '招远市', 370686: '栖霞市', 370687: '海阳市', 370690: '开发区', 370702: '潍城区', 370703: '寒亭区', 370704: '坊子区', 370705: '奎文区', 370724: '临朐县', 370725: '昌乐县', 370781: '青州市', 370782: '诸城市', 370783: '寿光市', 370784: '安丘市', 370785: '高密市', 370786: '昌邑市', 370790: '开发区', 370791: '高新区', 370811: '任城区', 370812: '兖州区', 370826: '微山县', 370827: '鱼台县', 370828: '金乡县', 370829: '嘉祥县', 370830: '汶上县', 370831: '泗水县', 370832: '梁山县', 370881: '曲阜市', 370883: '邹城市', 370890: '高新区', 370902: '泰山区', 370911: '岱岳区', 370921: '宁阳县', 370923: '东平县', 370982: '新泰市', 370983: '肥城市', 371002: '环翠区', 371003: '文登区', 371082: '荣成市', 371083: '乳山市', 371091: '经济技术开发区', 371102: '东港区', 371103: '岚山区', 371121: '五莲县', 371122: '莒县', 371302: '兰山区', 371311: '罗庄区', 371312: '河东区', 371321: '沂南县', 371322: '郯城县', 371323: '沂水县', 371324: '兰陵县', 371325: '费县', 371326: '平邑县', 371327: '莒南县', 371328: '蒙阴县', 371329: '临沭县', 371402: '德城区', 371403: '陵城区', 371422: '宁津县', 371423: '庆云县', 371424: '临邑县', 371425: '齐河县', 371426: '平原县', 371427: '夏津县', 371428: '武城县', 371481: '乐陵市', 371482: '禹城市', 371502: '东昌府区', 371521: '阳谷县', 371522: '莘县', 371523: '茌平县', 371524: '东阿县', 371525: '冠县', 371526: '高唐县', 371581: '临清市', 371602: '滨城区', 371603: '沾化区', 371621: '惠民县', 371622: '阳信县', 371623: '无棣县', 371625: '博兴县', 371681: '邹平市', 371702: '牡丹区', 371703: '定陶区', 371721: '曹县', 371722: '单县', 371723: '成武县', 371724: '巨野县', 371725: '郓城县', 371726: '鄄城县', 371728: '东明县', 410102: '中原区', 410103: '二七区', 410104: '管城回族区', 410105: '金水区', 410106: '上街区', 410108: '惠济区', 410122: '中牟县', 410181: '巩义市', 410182: '荥阳市', 410183: '新密市', 410184: '新郑市', 410185: '登封市', 410190: '高新技术开发区', 410191: '经济技术开发区', 410202: '龙亭区', 410203: '顺河回族区', 410204: '鼓楼区', 410205: '禹王台区', 410212: '祥符区', 410221: '杞县', 410222: '通许县', 410223: '尉氏县', 410225: '兰考县', 410302: '老城区', 410303: '西工区', 410304: '瀍河回族区', 410305: '涧西区', 410306: '吉利区', 410311: '洛龙区', 410322: '孟津县', 410323: '新安县', 410324: '栾川县', 410325: '嵩县', 410326: '汝阳县', 410327: '宜阳县', 410328: '洛宁县', 410329: '伊川县', 410381: '偃师市', 410402: '新华区', 410403: '卫东区', 410404: '石龙区', 410411: '湛河区', 410421: '宝丰县', 410422: '叶县', 410423: '鲁山县', 410425: '郏县', 410481: '舞钢市', 410482: '汝州市', 410502: '文峰区', 410503: '北关区', 410505: '殷都区', 410506: '龙安区', 410522: '安阳县', 410523: '汤阴县', 410526: '滑县', 410527: '内黄县', 410581: '林州市', 410590: '开发区', 410602: '鹤山区', 410603: '山城区', 410611: '淇滨区', 410621: '浚县', 410622: '淇县', 410702: '红旗区', 410703: '卫滨区', 410704: '凤泉区', 410711: '牧野区', 410721: '新乡县', 410724: '获嘉县', 410725: '原阳县', 410726: '延津县', 410727: '封丘县', 410728: '长垣县', 410781: '卫辉市', 410782: '辉县市', 410802: '解放区', 410803: '中站区', 410804: '马村区', 410811: '山阳区', 410821: '修武县', 410822: '博爱县', 410823: '武陟县', 410825: '温县', 410882: '沁阳市', 410883: '孟州市', 410902: '华龙区', 410922: '清丰县', 410923: '南乐县', 410926: '范县', 410927: '台前县', 410928: '濮阳县', 411002: '魏都区', 411003: '建安区', 411024: '鄢陵县', 411025: '襄城县', 411081: '禹州市', 411082: '长葛市', 411102: '源汇区', 411103: '郾城区', 411104: '召陵区', 411121: '舞阳县', 411122: '临颍县', 411202: '湖滨区', 411203: '陕州区', 411221: '渑池县', 411224: '卢氏县', 411281: '义马市', 411282: '灵宝市', 411302: '宛城区', 411303: '卧龙区', 411321: '南召县', 411322: '方城县', 411323: '西峡县', 411324: '镇平县', 411325: '内乡县', 411326: '淅川县', 411327: '社旗县', 411328: '唐河县', 411329: '新野县', 411330: '桐柏县', 411381: '邓州市', 411402: '梁园区', 411403: '睢阳区', 411421: '民权县', 411422: '睢县', 411423: '宁陵县', 411424: '柘城县', 411425: '虞城县', 411426: '夏邑县', 411481: '永城市', 411502: '浉河区', 411503: '平桥区', 411521: '罗山县', 411522: '光山县', 411523: '新县', 411524: '商城县', 411525: '固始县', 411526: '潢川县', 411527: '淮滨县', 411528: '息县', 411602: '川汇区', 411621: '扶沟县', 411622: '西华县', 411623: '商水县', 411624: '沈丘县', 411625: '郸城县', 411626: '淮阳县', 411627: '太康县', 411628: '鹿邑县', 411681: '项城市', 411690: '经济开发区', 411702: '驿城区', 411721: '西平县', 411722: '上蔡县', 411723: '平舆县', 411724: '正阳县', 411725: '确山县', 411726: '泌阳县', 411727: '汝南县', 411728: '遂平县', 411729: '新蔡县', 419001: '济源市', 420102: '江岸区', 420103: '江汉区', 420104: '硚口区', 420105: '汉阳区', 420106: '武昌区', 420107: '青山区', 420111: '洪山区', 420112: '东西湖区', 420113: '汉南区', 420114: '蔡甸区', 420115: '江夏区', 420116: '黄陂区', 420117: '新洲区', 420202: '黄石港区', 420203: '西塞山区', 420204: '下陆区', 420205: '铁山区', 420222: '阳新县', 420281: '大冶市', 420302: '茅箭区', 420303: '张湾区', 420304: '郧阳区', 420322: '郧西县', 420323: '竹山县', 420324: '竹溪县', 420325: '房县', 420381: '丹江口市', 420502: '西陵区', 420503: '伍家岗区', 420504: '点军区', 420505: '猇亭区', 420506: '夷陵区', 420525: '远安县', 420526: '兴山县', 420527: '秭归县', 420528: '长阳土家族自治县', 420529: '五峰土家族自治县', 420581: '宜都市', 420582: '当阳市', 420583: '枝江市', 420590: '经济开发区', 420602: '襄城区', 420606: '樊城区', 420607: '襄州区', 420624: '南漳县', 420625: '谷城县', 420626: '保康县', 420682: '老河口市', 420683: '枣阳市', 420684: '宜城市', 420702: '梁子湖区', 420703: '华容区', 420704: '鄂城区', 420802: '东宝区', 420804: '掇刀区', 420822: '沙洋县', 420881: '钟祥市', 420882: '京山市', 420902: '孝南区', 420921: '孝昌县', 420922: '大悟县', 420923: '云梦县', 420981: '应城市', 420982: '安陆市', 420984: '汉川市', 421002: '沙市区', 421003: '荆州区', 421022: '公安县', 421023: '监利县', 421024: '江陵县', 421081: '石首市', 421083: '洪湖市', 421087: '松滋市', 421102: '黄州区', 421121: '团风县', 421122: '红安县', 421123: '罗田县', 421124: '英山县', 421125: '浠水县', 421126: '蕲春县', 421127: '黄梅县', 421181: '麻城市', 421182: '武穴市', 421202: '咸安区', 421221: '嘉鱼县', 421222: '通城县', 421223: '崇阳县', 421224: '通山县', 421281: '赤壁市', 421303: '曾都区', 421321: '随县', 421381: '广水市', 422801: '恩施市', 422802: '利川市', 422822: '建始县', 422823: '巴东县', 422825: '宣恩县', 422826: '咸丰县', 422827: '来凤县', 422828: '鹤峰县', 429004: '仙桃市', 429005: '潜江市', 429006: '天门市', 429021: '神农架林区', 430102: '芙蓉区', 430103: '天心区', 430104: '岳麓区', 430105: '开福区', 430111: '雨花区', 430112: '望城区', 430121: '长沙县', 430181: '浏阳市', 430182: '宁乡市', 430202: '荷塘区', 430203: '芦淞区', 430204: '石峰区', 430211: '天元区', 430212: '渌口区', 430223: '攸县', 430224: '茶陵县', 430225: '炎陵县', 430281: '醴陵市', 430302: '雨湖区', 430304: '岳塘区', 430321: '湘潭县', 430381: '湘乡市', 430382: '韶山市', 430405: '珠晖区', 430406: '雁峰区', 430407: '石鼓区', 430408: '蒸湘区', 430412: '南岳区', 430421: '衡阳县', 430422: '衡南县', 430423: '衡山县', 430424: '衡东县', 430426: '祁东县', 430481: '耒阳市', 430482: '常宁市', 430502: '双清区', 430503: '大祥区', 430511: '北塔区', 430521: '邵东县', 430522: '新邵县', 430523: '邵阳县', 430524: '隆回县', 430525: '洞口县', 430527: '绥宁县', 430528: '新宁县', 430529: '城步苗族自治县', 430581: '武冈市', 430602: '岳阳楼区', 430603: '云溪区', 430611: '君山区', 430621: '岳阳县', 430623: '华容县', 430624: '湘阴县', 430626: '平江县', 430681: '汨罗市', 430682: '临湘市', 430702: '武陵区', 430703: '鼎城区', 430721: '安乡县', 430722: '汉寿县', 430723: '澧县', 430724: '临澧县', 430725: '桃源县', 430726: '石门县', 430781: '津市市', 430802: '永定区', 430811: '武陵源区', 430821: '慈利县', 430822: '桑植县', 430902: '资阳区', 430903: '赫山区', 430921: '南县', 430922: '桃江县', 430923: '安化县', 430981: '沅江市', 431002: '北湖区', 431003: '苏仙区', 431021: '桂阳县', 431022: '宜章县', 431023: '永兴县', 431024: '嘉禾县', 431025: '临武县', 431026: '汝城县', 431027: '桂东县', 431028: '安仁县', 431081: '资兴市', 431102: '零陵区', 431103: '冷水滩区', 431121: '祁阳县', 431122: '东安县', 431123: '双牌县', 431124: '道县', 431125: '江永县', 431126: '宁远县', 431127: '蓝山县', 431128: '新田县', 431129: '江华瑶族自治县', 431202: '鹤城区', 431221: '中方县', 431222: '沅陵县', 431223: '辰溪县', 431224: '溆浦县', 431225: '会同县', 431226: '麻阳苗族自治县', 431227: '新晃侗族自治县', 431228: '芷江侗族自治县', 431229: '靖州苗族侗族自治县', 431230: '通道侗族自治县', 431281: '洪江市', 431302: '娄星区', 431321: '双峰县', 431322: '新化县', 431381: '冷水江市', 431382: '涟源市', 433101: '吉首市', 433122: '泸溪县', 433123: '凤凰县', 433124: '花垣县', 433125: '保靖县', 433126: '古丈县', 433127: '永顺县', 433130: '龙山县', 440103: '荔湾区', 440104: '越秀区', 440105: '海珠区', 440106: '天河区', 440111: '白云区', 440112: '黄埔区', 440113: '番禺区', 440114: '花都区', 440115: '南沙区', 440117: '从化区', 440118: '增城区', 440203: '武江区', 440204: '浈江区', 440205: '曲江区', 440222: '始兴县', 440224: '仁化县', 440229: '翁源县', 440232: '乳源瑶族自治县', 440233: '新丰县', 440281: '乐昌市', 440282: '南雄市', 440303: '罗湖区', 440304: '福田区', 440305: '南山区', 440306: '宝安区', 440307: '龙岗区', 440308: '盐田区', 440309: '龙华区', 440310: '坪山区', 440311: '光明区', 440402: '香洲区', 440403: '斗门区', 440404: '金湾区', 440507: '龙湖区', 440511: '金平区', 440512: '濠江区', 440513: '潮阳区', 440514: '潮南区', 440515: '澄海区', 440523: '南澳县', 440604: '禅城区', 440605: '南海区', 440606: '顺德区', 440607: '三水区', 440608: '高明区', 440703: '蓬江区', 440704: '江海区', 440705: '新会区', 440781: '台山市', 440783: '开平市', 440784: '鹤山市', 440785: '恩平市', 440802: '赤坎区', 440803: '霞山区', 440804: '坡头区', 440811: '麻章区', 440823: '遂溪县', 440825: '徐闻县', 440881: '廉江市', 440882: '雷州市', 440883: '吴川市', 440890: '经济技术开发区', 440902: '茂南区', 440904: '电白区', 440981: '高州市', 440982: '化州市', 440983: '信宜市', 441202: '端州区', 441203: '鼎湖区', 441204: '高要区', 441223: '广宁县', 441224: '怀集县', 441225: '封开县', 441226: '德庆县', 441284: '四会市', 441302: '惠城区', 441303: '惠阳区', 441322: '博罗县', 441323: '惠东县', 441324: '龙门县', 441402: '梅江区', 441403: '梅县区', 441422: '大埔县', 441423: '丰顺县', 441424: '五华县', 441426: '平远县', 441427: '蕉岭县', 441481: '兴宁市', 441502: '城区', 441521: '海丰县', 441523: '陆河县', 441581: '陆丰市', 441602: '源城区', 441621: '紫金县', 441622: '龙川县', 441623: '连平县', 441624: '和平县', 441625: '东源县', 441702: '江城区', 441704: '阳东区', 441721: '阳西县', 441781: '阳春市', 441802: '清城区', 441803: '清新区', 441821: '佛冈县', 441823: '阳山县', 441825: '连山壮族瑶族自治县', 441826: '连南瑶族自治县', 441881: '英德市', 441882: '连州市', 441901: '中堂镇', 441903: '南城街道办事处', 441904: '长安镇', 441905: '东坑镇', 441906: '樟木头镇', 441907: '莞城街道办事处', 441908: '石龙镇', 441909: '桥头镇', 441910: '万江街道办事处', 441911: '麻涌镇', 441912: '虎门镇', 441913: '谢岗镇', 441914: '石碣镇', 441915: '茶山镇', 441916: '东城街道办事处', 441917: '洪梅镇', 441918: '道滘镇', 441919: '高埗镇', 441920: '企石镇', 441921: '凤岗镇', 441922: '大岭山镇', 441923: '松山湖管委会', 441924: '清溪镇', 441925: '望牛墩镇', 441926: '厚街镇', 441927: '常平镇', 441928: '寮步镇', 441929: '石排镇', 441930: '横沥镇', 441931: '塘厦镇', 441932: '黄江镇', 441933: '大朗镇', 441934: '东莞港', 441935: '东莞生态园', 441990: '沙田镇', 442001: '南头镇', 442002: '神湾镇', 442003: '东凤镇', 442004: '五桂山街道办事处', 442005: '黄圃镇', 442006: '小榄镇', 442007: '石岐区街道办事处', 442008: '横栏镇', 442009: '三角镇', 442010: '三乡镇', 442011: '港口镇', 442012: '沙溪镇', 442013: '板芙镇', 442015: '东升镇', 442016: '阜沙镇', 442017: '民众镇', 442018: '东区街道办事处', 442019: '火炬开发区街道办事处', 442020: '西区街道办事处', 442021: '南区街道办事处', 442022: '古镇镇', 442023: '坦洲镇', 442024: '大涌镇', 442025: '南朗镇', 445102: '湘桥区', 445103: '潮安区', 445122: '饶平县', 445202: '榕城区', 445203: '揭东区', 445222: '揭西县', 445224: '惠来县', 445281: '普宁市', 445302: '云城区', 445303: '云安区', 445321: '新兴县', 445322: '郁南县', 445381: '罗定市', 450102: '兴宁区', 450103: '青秀区', 450105: '江南区', 450107: '西乡塘区', 450108: '良庆区', 450109: '邕宁区', 450110: '武鸣区', 450123: '隆安县', 450124: '马山县', 450125: '上林县', 450126: '宾阳县', 450127: '横县', 450202: '城中区', 450203: '鱼峰区', 450204: '柳南区', 450205: '柳北区', 450206: '柳江区', 450222: '柳城县', 450223: '鹿寨县', 450224: '融安县', 450225: '融水苗族自治县', 450226: '三江侗族自治县', 450302: '秀峰区', 450303: '叠彩区', 450304: '象山区', 450305: '七星区', 450311: '雁山区', 450312: '临桂区', 450321: '阳朔县', 450323: '灵川县', 450324: '全州县', 450325: '兴安县', 450326: '永福县', 450327: '灌阳县', 450328: '龙胜各族自治县', 450329: '资源县', 450330: '平乐县', 450332: '恭城瑶族自治县', 450381: '荔浦市', 450403: '万秀区', 450405: '长洲区', 450406: '龙圩区', 450421: '苍梧县', 450422: '藤县', 450423: '蒙山县', 450481: '岑溪市', 450502: '海城区', 450503: '银海区', 450512: '铁山港区', 450521: '合浦县', 450602: '港口区', 450603: '防城区', 450621: '上思县', 450681: '东兴市', 450702: '钦南区', 450703: '钦北区', 450721: '灵山县', 450722: '浦北县', 450802: '港北区', 450803: '港南区', 450804: '覃塘区', 450821: '平南县', 450881: '桂平市', 450902: '玉州区', 450903: '福绵区', 450921: '容县', 450922: '陆川县', 450923: '博白县', 450924: '兴业县', 450981: '北流市', 451002: '右江区', 451021: '田阳县', 451022: '田东县', 451023: '平果县', 451024: '德保县', 451026: '那坡县', 451027: '凌云县', 451028: '乐业县', 451029: '田林县', 451030: '西林县', 451031: '隆林各族自治县', 451081: '靖西市', 451102: '八步区', 451103: '平桂区', 451121: '昭平县', 451122: '钟山县', 451123: '富川瑶族自治县', 451202: '金城江区', 451203: '宜州区', 451221: '南丹县', 451222: '天峨县', 451223: '凤山县', 451224: '东兰县', 451225: '罗城仫佬族自治县', 451226: '环江毛南族自治县', 451227: '巴马瑶族自治县', 451228: '都安瑶族自治县', 451229: '大化瑶族自治县', 451302: '兴宾区', 451321: '忻城县', 451322: '象州县', 451323: '武宣县', 451324: '金秀瑶族自治县', 451381: '合山市', 451402: '江州区', 451421: '扶绥县', 451422: '宁明县', 451423: '龙州县', 451424: '大新县', 451425: '天等县', 451481: '凭祥市', 460105: '秀英区', 460106: '龙华区', 460107: '琼山区', 460108: '美兰区', 460202: '海棠区', 460203: '吉阳区', 460204: '天涯区', 460205: '崖州区', 460321: '西沙群岛', 460322: '南沙群岛', 460323: '中沙群岛的岛礁及其海域', 460401: '那大镇', 460402: '和庆镇', 460403: '南丰镇', 460404: '大成镇', 460405: '雅星镇', 460406: '兰洋镇', 460407: '光村镇', 460408: '木棠镇', 460409: '海头镇', 460410: '峨蔓镇', 460411: '王五镇', 460412: '白马井镇', 460413: '中和镇', 460414: '排浦镇', 460415: '东成镇', 460416: '新州镇', 460417: '洋浦经济开发区', 460418: '华南热作学院', 469001: '五指山市', 469002: '琼海市', 469005: '文昌市', 469006: '万宁市', 469007: '东方市', 469021: '定安县', 469022: '屯昌县', 469023: '澄迈县', 469024: '临高县', 469025: '白沙黎族自治县', 469026: '昌江黎族自治县', 469027: '乐东黎族自治县', 469028: '陵水黎族自治县', 469029: '保亭黎族苗族自治县', 469030: '琼中黎族苗族自治县', 500101: '万州区', 500102: '涪陵区', 500103: '渝中区', 500104: '大渡口区', 500105: '江北区', 500106: '沙坪坝区', 500107: '九龙坡区', 500108: '南岸区', 500109: '北碚区', 500110: '綦江区', 500111: '大足区', 500112: '渝北区', 500113: '巴南区', 500114: '黔江区', 500115: '长寿区', 500116: '江津区', 500117: '合川区', 500118: '永川区', 500119: '南川区', 500120: '璧山区', 500151: '铜梁区', 500152: '潼南区', 500153: '荣昌区', 500154: '开州区', 500155: '梁平区', 500156: '武隆区', 500229: '城口县', 500230: '丰都县', 500231: '垫江县', 500233: '忠县', 500235: '云阳县', 500236: '奉节县', 500237: '巫山县', 500238: '巫溪县', 500240: '石柱土家族自治县', 500241: '秀山土家族苗族自治县', 500242: '酉阳土家族苗族自治县', 500243: '彭水苗族土家族自治县', 510104: '锦江区', 510105: '青羊区', 510106: '金牛区', 510107: '武侯区', 510108: '成华区', 510112: '龙泉驿区', 510113: '青白江区', 510114: '新都区', 510115: '温江区', 510116: '双流区', 510117: '郫都区', 510121: '金堂县', 510129: '大邑县', 510131: '蒲江县', 510132: '新津县', 510181: '都江堰市', 510182: '彭州市', 510183: '邛崃市', 510184: '崇州市', 510185: '简阳市', 510191: '高新区', 510302: '自流井区', 510303: '贡井区', 510304: '大安区', 510311: '沿滩区', 510321: '荣县', 510322: '富顺县', 510402: '东区', 510403: '西区', 510411: '仁和区', 510421: '米易县', 510422: '盐边县', 510502: '江阳区', 510503: '纳溪区', 510504: '龙马潭区', 510521: '泸县', 510522: '合江县', 510524: '叙永县', 510525: '古蔺县', 510603: '旌阳区', 510604: '罗江区', 510623: '中江县', 510681: '广汉市', 510682: '什邡市', 510683: '绵竹市', 510703: '涪城区', 510704: '游仙区', 510705: '安州区', 510722: '三台县', 510723: '盐亭县', 510725: '梓潼县', 510726: '北川羌族自治县', 510727: '平武县', 510781: '江油市', 510791: '高新区', 510802: '利州区', 510811: '昭化区', 510812: '朝天区', 510821: '旺苍县', 510822: '青川县', 510823: '剑阁县', 510824: '苍溪县', 510903: '船山区', 510904: '安居区', 510921: '蓬溪县', 510922: '射洪县', 510923: '大英县', 511002: '市中区', 511011: '东兴区', 511024: '威远县', 511025: '资中县', 511083: '隆昌市', 511102: '市中区', 511111: '沙湾区', 511112: '五通桥区', 511113: '金口河区', 511123: '犍为县', 511124: '井研县', 511126: '夹江县', 511129: '沐川县', 511132: '峨边彝族自治县', 511133: '马边彝族自治县', 511181: '峨眉山市', 511302: '顺庆区', 511303: '高坪区', 511304: '嘉陵区', 511321: '南部县', 511322: '营山县', 511323: '蓬安县', 511324: '仪陇县', 511325: '西充县', 511381: '阆中市', 511402: '东坡区', 511403: '彭山区', 511421: '仁寿县', 511423: '洪雅县', 511424: '丹棱县', 511425: '青神县', 511502: '翠屏区', 511503: '南溪区', 511504: '叙州区', 511523: '江安县', 511524: '长宁县', 511525: '高县', 511526: '珙县', 511527: '筠连县', 511528: '兴文县', 511529: '屏山县', 511602: '广安区', 511603: '前锋区', 511621: '岳池县', 511622: '武胜县', 511623: '邻水县', 511681: '华蓥市', 511702: '通川区', 511703: '达川区', 511722: '宣汉县', 511723: '开江县', 511724: '大竹县', 511725: '渠县', 511781: '万源市', 511802: '雨城区', 511803: '名山区', 511822: '荥经县', 511823: '汉源县', 511824: '石棉县', 511825: '天全县', 511826: '芦山县', 511827: '宝兴县', 511902: '巴州区', 511903: '恩阳区', 511921: '通江县', 511922: '南江县', 511923: '平昌县', 512002: '雁江区', 512021: '安岳县', 512022: '乐至县', 513201: '马尔康市', 513221: '汶川县', 513222: '理县', 513223: '茂县', 513224: '松潘县', 513225: '九寨沟县', 513226: '金川县', 513227: '小金县', 513228: '黑水县', 513230: '壤塘县', 513231: '阿坝县', 513232: '若尔盖县', 513233: '红原县', 513301: '康定市', 513322: '泸定县', 513323: '丹巴县', 513324: '九龙县', 513325: '雅江县', 513326: '道孚县', 513327: '炉霍县', 513328: '甘孜县', 513329: '新龙县', 513330: '德格县', 513331: '白玉县', 513332: '石渠县', 513333: '色达县', 513334: '理塘县', 513335: '巴塘县', 513336: '乡城县', 513337: '稻城县', 513338: '得荣县', 513401: '西昌市', 513422: '木里藏族自治县', 513423: '盐源县', 513424: '德昌县', 513425: '会理县', 513426: '会东县', 513427: '宁南县', 513428: '普格县', 513429: '布拖县', 513430: '金阳县', 513431: '昭觉县', 513432: '喜德县', 513433: '冕宁县', 513434: '越西县', 513435: '甘洛县', 513436: '美姑县', 513437: '雷波县', 520102: '南明区', 520103: '云岩区', 520111: '花溪区', 520112: '乌当区', 520113: '白云区', 520115: '观山湖区', 520121: '开阳县', 520122: '息烽县', 520123: '修文县', 520181: '清镇市', 520201: '钟山区', 520203: '六枝特区', 520221: '水城县', 520281: '盘州市', 520302: '红花岗区', 520303: '汇川区', 520304: '播州区', 520322: '桐梓县', 520323: '绥阳县', 520324: '正安县', 520325: '道真仡佬族苗族自治县', 520326: '务川仡佬族苗族自治县', 520327: '凤冈县', 520328: '湄潭县', 520329: '余庆县', 520330: '习水县', 520381: '赤水市', 520382: '仁怀市', 520402: '西秀区', 520403: '平坝区', 520422: '普定县', 520423: '镇宁布依族苗族自治县', 520424: '关岭布依族苗族自治县', 520425: '紫云苗族布依族自治县', 520502: '七星关区', 520521: '大方县', 520522: '黔西县', 520523: '金沙县', 520524: '织金县', 520525: '纳雍县', 520526: '威宁彝族回族苗族自治县', 520527: '赫章县', 520602: '碧江区', 520603: '万山区', 520621: '江口县', 520622: '玉屏侗族自治县', 520623: '石阡县', 520624: '思南县', 520625: '印江土家族苗族自治县', 520626: '德江县', 520627: '沿河土家族自治县', 520628: '松桃苗族自治县', 522301: '兴义市', 522302: '兴仁市', 522323: '普安县', 522324: '晴隆县', 522325: '贞丰县', 522326: '望谟县', 522327: '册亨县', 522328: '安龙县', 522601: '凯里市', 522622: '黄平县', 522623: '施秉县', 522624: '三穗县', 522625: '镇远县', 522626: '岑巩县', 522627: '天柱县', 522628: '锦屏县', 522629: '剑河县', 522630: '台江县', 522631: '黎平县', 522632: '榕江县', 522633: '从江县', 522634: '雷山县', 522635: '麻江县', 522636: '丹寨县', 522701: '都匀市', 522702: '福泉市', 522722: '荔波县', 522723: '贵定县', 522725: '瓮安县', 522726: '独山县', 522727: '平塘县', 522728: '罗甸县', 522729: '长顺县', 522730: '龙里县', 522731: '惠水县', 522732: '三都水族自治县', 530102: '五华区', 530103: '盘龙区', 530111: '官渡区', 530112: '西山区', 530113: '东川区', 530114: '呈贡区', 530115: '晋宁区', 530124: '富民县', 530125: '宜良县', 530126: '石林彝族自治县', 530127: '嵩明县', 530128: '禄劝彝族苗族自治县', 530129: '寻甸回族彝族自治县', 530181: '安宁市', 530302: '麒麟区', 530303: '沾益区', 530304: '马龙区', 530322: '陆良县', 530323: '师宗县', 530324: '罗平县', 530325: '富源县', 530326: '会泽县', 530381: '宣威市', 530402: '红塔区', 530403: '江川区', 530422: '澄江县', 530423: '通海县', 530424: '华宁县', 530425: '易门县', 530426: '峨山彝族自治县', 530427: '新平彝族傣族自治县', 530428: '元江哈尼族彝族傣族自治县', 530502: '隆阳区', 530521: '施甸县', 530523: '龙陵县', 530524: '昌宁县', 530581: '腾冲市', 530602: '昭阳区', 530621: '鲁甸县', 530622: '巧家县', 530623: '盐津县', 530624: '大关县', 530625: '永善县', 530626: '绥江县', 530627: '镇雄县', 530628: '彝良县', 530629: '威信县', 530681: '水富市', 530702: '古城区', 530721: '玉龙纳西族自治县', 530722: '永胜县', 530723: '华坪县', 530724: '宁蒗彝族自治县', 530802: '思茅区', 530821: '宁洱哈尼族彝族自治县', 530822: '墨江哈尼族自治县', 530823: '景东彝族自治县', 530824: '景谷傣族彝族自治县', 530825: '镇沅彝族哈尼族拉祜族自治县', 530826: '江城哈尼族彝族自治县', 530827: '孟连傣族拉祜族佤族自治县', 530828: '澜沧拉祜族自治县', 530829: '西盟佤族自治县', 530902: '临翔区', 530921: '凤庆县', 530922: '云县', 530923: '永德县', 530924: '镇康县', 530925: '双江拉祜族佤族布朗族傣族自治县', 530926: '耿马傣族佤族自治县', 530927: '沧源佤族自治县', 532301: '楚雄市', 532322: '双柏县', 532323: '牟定县', 532324: '南华县', 532325: '姚安县', 532326: '大姚县', 532327: '永仁县', 532328: '元谋县', 532329: '武定县', 532331: '禄丰县', 532501: '个旧市', 532502: '开远市', 532503: '蒙自市', 532504: '弥勒市', 532523: '屏边苗族自治县', 532524: '建水县', 532525: '石屏县', 532527: '泸西县', 532528: '元阳县', 532529: '红河县', 532530: '金平苗族瑶族傣族自治县', 532531: '绿春县', 532532: '河口瑶族自治县', 532601: '文山市', 532622: '砚山县', 532623: '西畴县', 532624: '麻栗坡县', 532625: '马关县', 532626: '丘北县', 532627: '广南县', 532628: '富宁县', 532801: '景洪市', 532822: '勐海县', 532823: '勐腊县', 532901: '大理市', 532922: '漾濞彝族自治县', 532923: '祥云县', 532924: '宾川县', 532925: '弥渡县', 532926: '南涧彝族自治县', 532927: '巍山彝族回族自治县', 532928: '永平县', 532929: '云龙县', 532930: '洱源县', 532931: '剑川县', 532932: '鹤庆县', 533102: '瑞丽市', 533103: '芒市', 533122: '梁河县', 533123: '盈江县', 533124: '陇川县', 533301: '泸水市', 533323: '福贡县', 533324: '贡山独龙族怒族自治县', 533325: '兰坪白族普米族自治县', 533401: '香格里拉市', 533422: '德钦县', 533423: '维西傈僳族自治县', 540102: '城关区', 540103: '堆龙德庆区', 540104: '达孜区', 540121: '林周县', 540122: '当雄县', 540123: '尼木县', 540124: '曲水县', 540127: '墨竹工卡县', 540202: '桑珠孜区', 540221: '南木林县', 540222: '江孜县', 540223: '定日县', 540224: '萨迦县', 540225: '拉孜县', 540226: '昂仁县', 540227: '谢通门县', 540228: '白朗县', 540229: '仁布县', 540230: '康马县', 540231: '定结县', 540232: '仲巴县', 540233: '亚东县', 540234: '吉隆县', 540235: '聂拉木县', 540236: '萨嘎县', 540237: '岗巴县', 540302: '卡若区', 540321: '江达县', 540322: '贡觉县', 540323: '类乌齐县', 540324: '丁青县', 540325: '察雅县', 540326: '八宿县', 540327: '左贡县', 540328: '芒康县', 540329: '洛隆县', 540330: '边坝县', 540402: '巴宜区', 540421: '工布江达县', 540422: '米林县', 540423: '墨脱县', 540424: '波密县', 540425: '察隅县', 540426: '朗县', 540502: '乃东区', 540521: '扎囊县', 540522: '贡嘎县', 540523: '桑日县', 540524: '琼结县', 540525: '曲松县', 540526: '措美县', 540527: '洛扎县', 540528: '加查县', 540529: '隆子县', 540530: '错那县', 540531: '浪卡子县', 540602: '色尼区', 540621: '嘉黎县', 540622: '比如县', 540623: '聂荣县', 540624: '安多县', 540625: '申扎县', 540626: '索县', 540627: '班戈县', 540628: '巴青县', 540629: '尼玛县', 540630: '双湖县', 542521: '普兰县', 542522: '札达县', 542523: '噶尔县', 542524: '日土县', 542525: '革吉县', 542526: '改则县', 542527: '措勤县', 610102: '新城区', 610103: '碑林区', 610104: '莲湖区', 610111: '灞桥区', 610112: '未央区', 610113: '雁塔区', 610114: '阎良区', 610115: '临潼区', 610116: '长安区', 610117: '高陵区', 610118: '鄠邑区', 610122: '蓝田县', 610124: '周至县', 610202: '王益区', 610203: '印台区', 610204: '耀州区', 610222: '宜君县', 610302: '渭滨区', 610303: '金台区', 610304: '陈仓区', 610322: '凤翔县', 610323: '岐山县', 610324: '扶风县', 610326: '眉县', 610327: '陇县', 610328: '千阳县', 610329: '麟游县', 610330: '凤县', 610331: '太白县', 610402: '秦都区', 610403: '杨陵区', 610404: '渭城区', 610422: '三原县', 610423: '泾阳县', 610424: '乾县', 610425: '礼泉县', 610426: '永寿县', 610428: '长武县', 610429: '旬邑县', 610430: '淳化县', 610431: '武功县', 610481: '兴平市', 610482: '彬州市', 610502: '临渭区', 610503: '华州区', 610522: '潼关县', 610523: '大荔县', 610524: '合阳县', 610525: '澄城县', 610526: '蒲城县', 610527: '白水县', 610528: '富平县', 610581: '韩城市', 610582: '华阴市', 610602: '宝塔区', 610603: '安塞区', 610621: '延长县', 610622: '延川县', 610623: '子长县', 610625: '志丹县', 610626: '吴起县', 610627: '甘泉县', 610628: '富县', 610629: '洛川县', 610630: '宜川县', 610631: '黄龙县', 610632: '黄陵县', 610702: '汉台区', 610703: '南郑区', 610722: '城固县', 610723: '洋县', 610724: '西乡县', 610725: '勉县', 610726: '宁强县', 610727: '略阳县', 610728: '镇巴县', 610729: '留坝县', 610730: '佛坪县', 610802: '榆阳区', 610803: '横山区', 610822: '府谷县', 610824: '靖边县', 610825: '定边县', 610826: '绥德县', 610827: '米脂县', 610828: '佳县', 610829: '吴堡县', 610830: '清涧县', 610831: '子洲县', 610881: '神木市', 610902: '汉滨区', 610921: '汉阴县', 610922: '石泉县', 610923: '宁陕县', 610924: '紫阳县', 610925: '岚皋县', 610926: '平利县', 610927: '镇坪县', 610928: '旬阳县', 610929: '白河县', 611002: '商州区', 611021: '洛南县', 611022: '丹凤县', 611023: '商南县', 611024: '山阳县', 611025: '镇安县', 611026: '柞水县', 620102: '城关区', 620103: '七里河区', 620104: '西固区', 620105: '安宁区', 620111: '红古区', 620121: '永登县', 620122: '皋兰县', 620123: '榆中县', 620201: '市辖区', 620290: '雄关区', 620291: '长城区', 620292: '镜铁区', 620293: '新城镇', 620294: '峪泉镇', 620295: '文殊镇', 620302: '金川区', 620321: '永昌县', 620402: '白银区', 620403: '平川区', 620421: '靖远县', 620422: '会宁县', 620423: '景泰县', 620502: '秦州区', 620503: '麦积区', 620521: '清水县', 620522: '秦安县', 620523: '甘谷县', 620524: '武山县', 620525: '张家川回族自治县', 620602: '凉州区', 620621: '民勤县', 620622: '古浪县', 620623: '天祝藏族自治县', 620702: '甘州区', 620721: '肃南裕固族自治县', 620722: '民乐县', 620723: '临泽县', 620724: '高台县', 620725: '山丹县', 620802: '崆峒区', 620821: '泾川县', 620822: '灵台县', 620823: '崇信县', 620825: '庄浪县', 620826: '静宁县', 620881: '华亭市', 620902: '肃州区', 620921: '金塔县', 620922: '瓜州县', 620923: '肃北蒙古族自治县', 620924: '阿克塞哈萨克族自治县', 620981: '玉门市', 620982: '敦煌市', 621002: '西峰区', 621021: '庆城县', 621022: '环县', 621023: '华池县', 621024: '合水县', 621025: '正宁县', 621026: '宁县', 621027: '镇原县', 621102: '安定区', 621121: '通渭县', 621122: '陇西县', 621123: '渭源县', 621124: '临洮县', 621125: '漳县', 621126: '岷县', 621202: '武都区', 621221: '成县', 621222: '文县', 621223: '宕昌县', 621224: '康县', 621225: '西和县', 621226: '礼县', 621227: '徽县', 621228: '两当县', 622901: '临夏市', 622921: '临夏县', 622922: '康乐县', 622923: '永靖县', 622924: '广河县', 622925: '和政县', 622926: '东乡族自治县', 622927: '积石山保安族东乡族撒拉族自治县', 623001: '合作市', 623021: '临潭县', 623022: '卓尼县', 623023: '舟曲县', 623024: '迭部县', 623025: '玛曲县', 623026: '碌曲县', 623027: '夏河县', 630102: '城东区', 630103: '城中区', 630104: '城西区', 630105: '城北区', 630121: '大通回族土族自治县', 630122: '湟中县', 630123: '湟源县', 630202: '乐都区', 630203: '平安区', 630222: '民和回族土族自治县', 630223: '互助土族自治县', 630224: '化隆回族自治县', 630225: '循化撒拉族自治县', 632221: '门源回族自治县', 632222: '祁连县', 632223: '海晏县', 632224: '刚察县', 632321: '同仁县', 632322: '尖扎县', 632323: '泽库县', 632324: '河南蒙古族自治县', 632521: '共和县', 632522: '同德县', 632523: '贵德县', 632524: '兴海县', 632525: '贵南县', 632621: '玛沁县', 632622: '班玛县', 632623: '甘德县', 632624: '达日县', 632625: '久治县', 632626: '玛多县', 632701: '玉树市', 632722: '杂多县', 632723: '称多县', 632724: '治多县', 632725: '囊谦县', 632726: '曲麻莱县', 632801: '格尔木市', 632802: '德令哈市', 632803: '茫崖市', 632821: '乌兰县', 632822: '都兰县', 632823: '天峻县', 640104: '兴庆区', 640105: '西夏区', 640106: '金凤区', 640121: '永宁县', 640122: '贺兰县', 640181: '灵武市', 640202: '大武口区', 640205: '惠农区', 640221: '平罗县', 640302: '利通区', 640303: '红寺堡区', 640323: '盐池县', 640324: '同心县', 640381: '青铜峡市', 640402: '原州区', 640422: '西吉县', 640423: '隆德县', 640424: '泾源县', 640425: '彭阳县', 640502: '沙坡头区', 640521: '中宁县', 640522: '海原县', 650102: '天山区', 650103: '沙依巴克区', 650104: '新市区', 650105: '水磨沟区', 650106: '头屯河区', 650107: '达坂城区', 650109: '米东区', 650121: '乌鲁木齐县', 650202: '独山子区', 650203: '克拉玛依区', 650204: '白碱滩区', 650205: '乌尔禾区', 650402: '高昌区', 650421: '鄯善县', 650422: '托克逊县', 650502: '伊州区', 650521: '巴里坤哈萨克自治县', 650522: '伊吾县', 652301: '昌吉市', 652302: '阜康市', 652323: '呼图壁县', 652324: '玛纳斯县', 652325: '奇台县', 652327: '吉木萨尔县', 652328: '木垒哈萨克自治县', 652701: '博乐市', 652702: '阿拉山口市', 652722: '精河县', 652723: '温泉县', 652801: '库尔勒市', 652822: '轮台县', 652823: '尉犁县', 652824: '若羌县', 652825: '且末县', 652826: '焉耆回族自治县', 652827: '和静县', 652828: '和硕县', 652829: '博湖县', 652901: '阿克苏市', 652922: '温宿县', 652923: '库车县', 652924: '沙雅县', 652925: '新和县', 652926: '拜城县', 652927: '乌什县', 652928: '阿瓦提县', 652929: '柯坪县', 653001: '阿图什市', 653022: '阿克陶县', 653023: '阿合奇县', 653024: '乌恰县', 653101: '喀什市', 653121: '疏附县', 653122: '疏勒县', 653123: '英吉沙县', 653124: '泽普县', 653125: '莎车县', 653126: '叶城县', 653127: '麦盖提县', 653128: '岳普湖县', 653129: '伽师县', 653130: '巴楚县', 653131: '塔什库尔干塔吉克自治县', 653201: '和田市', 653221: '和田县', 653222: '墨玉县', 653223: '皮山县', 653224: '洛浦县', 653225: '策勒县', 653226: '于田县', 653227: '民丰县', 654002: '伊宁市', 654003: '奎屯市', 654004: '霍尔果斯市', 654021: '伊宁县', 654022: '察布查尔锡伯自治县', 654023: '霍城县', 654024: '巩留县', 654025: '新源县', 654026: '昭苏县', 654027: '特克斯县', 654028: '尼勒克县', 654201: '塔城市', 654202: '乌苏市', 654221: '额敏县', 654223: '沙湾县', 654224: '托里县', 654225: '裕民县', 654226: '和布克赛尔蒙古自治县', 654301: '阿勒泰市', 654321: '布尔津县', 654322: '富蕴县', 654323: '福海县', 654324: '哈巴河县', 654325: '青河县', 654326: '吉木乃县', 659001: '石河子市', 659002: '阿拉尔市', 659003: '图木舒克市', 659004: '五家渠市', 659005: '北屯市', 659006: '铁门关市', 659007: '双河市', 659008: '可克达拉市', 659009: '昆玉市', 710101: '中正区', 710102: '大同区', 710103: '中山区', 710104: '松山区', 710105: '大安区', 710106: '万华区', 710107: '信义区', 710108: '士林区', 710109: '北投区', 710110: '内湖区', 710111: '南港区', 710112: '文山区', 710199: '其它区', 710201: '新兴区', 710202: '前金区', 710203: '芩雅区', 710204: '盐埕区', 710205: '鼓山区', 710206: '旗津区', 710207: '前镇区', 710208: '三民区', 710209: '左营区', 710210: '楠梓区', 710211: '小港区', 710241: '苓雅区', 710242: '仁武区', 710243: '大社区', 710244: '冈山区', 710245: '路竹区', 710246: '阿莲区', 710247: '田寮区', 710248: '燕巢区', 710249: '桥头区', 710250: '梓官区', 710251: '弥陀区', 710252: '永安区', 710253: '湖内区', 710254: '凤山区', 710255: '大寮区', 710256: '林园区', 710257: '鸟松区', 710258: '大树区', 710259: '旗山区', 710260: '美浓区', 710261: '六龟区', 710262: '内门区', 710263: '杉林区', 710264: '甲仙区', 710265: '桃源区', 710266: '那玛夏区', 710267: '茂林区', 710268: '茄萣区', 710299: '其它区', 710301: '中西区', 710302: '东区', 710303: '南区', 710304: '北区', 710305: '安平区', 710306: '安南区', 710339: '永康区', 710340: '归仁区', 710341: '新化区', 710342: '左镇区', 710343: '玉井区', 710344: '楠西区', 710345: '南化区', 710346: '仁德区', 710347: '关庙区', 710348: '龙崎区', 710349: '官田区', 710350: '麻豆区', 710351: '佳里区', 710352: '西港区', 710353: '七股区', 710354: '将军区', 710355: '学甲区', 710356: '北门区', 710357: '新营区', 710358: '后壁区', 710359: '白河区', 710360: '东山区', 710361: '六甲区', 710362: '下营区', 710363: '柳营区', 710364: '盐水区', 710365: '善化区', 710366: '大内区', 710367: '山上区', 710368: '新市区', 710369: '安定区', 710399: '其它区', 710401: '中区', 710402: '东区', 710403: '南区', 710404: '西区', 710405: '北区', 710406: '北屯区', 710407: '西屯区', 710408: '南屯区', 710431: '太平区', 710432: '大里区', 710433: '雾峰区', 710434: '乌日区', 710435: '丰原区', 710436: '后里区', 710437: '石冈区', 710438: '东势区', 710439: '和平区', 710440: '新社区', 710441: '潭子区', 710442: '大雅区', 710443: '神冈区', 710444: '大肚区', 710445: '沙鹿区', 710446: '龙井区', 710447: '梧栖区', 710448: '清水区', 710449: '大甲区', 710450: '外埔区', 710451: '大安区', 710499: '其它区', 710507: '金沙镇', 710508: '金湖镇', 710509: '金宁乡', 710510: '金城镇', 710511: '烈屿乡', 710512: '乌坵乡', 710614: '南投市', 710615: '中寮乡', 710616: '草屯镇', 710617: '国姓乡', 710618: '埔里镇', 710619: '仁爱乡', 710620: '名间乡', 710621: '集集镇', 710622: '水里乡', 710623: '鱼池乡', 710624: '信义乡', 710625: '竹山镇', 710626: '鹿谷乡', 710701: '仁爱区', 710702: '信义区', 710703: '中正区', 710704: '中山区', 710705: '安乐区', 710706: '暖暖区', 710707: '七堵区', 710799: '其它区', 710801: '东区', 710802: '北区', 710803: '香山区', 710899: '其它区', 710901: '东区', 710902: '西区', 710999: '其它区', 711130: '万里区', 711132: '板桥区', 711133: '汐止区', 711134: '深坑区', 711135: '石碇区', 711136: '瑞芳区', 711137: '平溪区', 711138: '双溪区', 711139: '贡寮区', 711140: '新店区', 711141: '坪林区', 711142: '乌来区', 711143: '永和区', 711144: '中和区', 711145: '土城区', 711146: '三峡区', 711147: '树林区', 711148: '莺歌区', 711149: '三重区', 711150: '新庄区', 711151: '泰山区', 711152: '林口区', 711153: '芦洲区', 711154: '五股区', 711155: '八里区', 711156: '淡水区', 711157: '三芝区', 711158: '石门区', 711287: '宜兰市', 711288: '头城镇', 711289: '礁溪乡', 711290: '壮围乡', 711291: '员山乡', 711292: '罗东镇', 711293: '三星乡', 711294: '大同乡', 711295: '五结乡', 711296: '冬山乡', 711297: '苏澳镇', 711298: '南澳乡', 711299: '钓鱼台', 711387: '竹北市', 711388: '湖口乡', 711389: '新丰乡', 711390: '新埔镇', 711391: '关西镇', 711392: '芎林乡', 711393: '宝山乡', 711394: '竹东镇', 711395: '五峰乡', 711396: '横山乡', 711397: '尖石乡', 711398: '北埔乡', 711399: '峨眉乡', 711414: '中坜区', 711415: '平镇区', 711417: '杨梅区', 711418: '新屋区', 711419: '观音区', 711420: '桃园区', 711421: '龟山区', 711422: '八德区', 711423: '大溪区', 711425: '大园区', 711426: '芦竹区', 711487: '中坜市', 711488: '平镇市', 711489: '龙潭乡', 711490: '杨梅市', 711491: '新屋乡', 711492: '观音乡', 711493: '桃园市', 711494: '龟山乡', 711495: '八德市', 711496: '大溪镇', 711497: '复兴乡', 711498: '大园乡', 711499: '芦竹乡', 711520: '头份市', 711582: '竹南镇', 711583: '头份镇', 711584: '三湾乡', 711585: '南庄乡', 711586: '狮潭乡', 711587: '后龙镇', 711588: '通霄镇', 711589: '苑里镇', 711590: '苗栗市', 711591: '造桥乡', 711592: '头屋乡', 711593: '公馆乡', 711594: '大湖乡', 711595: '泰安乡', 711596: '铜锣乡', 711597: '三义乡', 711598: '西湖乡', 711599: '卓兰镇', 711736: '员林市', 711774: '彰化市', 711775: '芬园乡', 711776: '花坛乡', 711777: '秀水乡', 711778: '鹿港镇', 711779: '福兴乡', 711780: '线西乡', 711781: '和美镇', 711782: '伸港乡', 711783: '员林镇', 711784: '社头乡', 711785: '永靖乡', 711786: '埔心乡', 711787: '溪湖镇', 711788: '大村乡', 711789: '埔盐乡', 711790: '田中镇', 711791: '北斗镇', 711792: '田尾乡', 711793: '埤头乡', 711794: '溪州乡', 711795: '竹塘乡', 711796: '二林镇', 711797: '大城乡', 711798: '芳苑乡', 711799: '二水乡', 711982: '番路乡', 711983: '梅山乡', 711984: '竹崎乡', 711985: '阿里山乡', 711986: '中埔乡', 711987: '大埔乡', 711988: '水上乡', 711989: '鹿草乡', 711990: '太保市', 711991: '朴子市', 711992: '东石乡', 711993: '六脚乡', 711994: '新港乡', 711995: '民雄乡', 711996: '大林镇', 711997: '溪口乡', 711998: '义竹乡', 711999: '布袋镇', 712180: '斗南镇', 712181: '大埤乡', 712182: '虎尾镇', 712183: '土库镇', 712184: '褒忠乡', 712185: '东势乡', 712186: '台西乡', 712187: '仑背乡', 712188: '麦寮乡', 712189: '斗六市', 712190: '林内乡', 712191: '古坑乡', 712192: '莿桐乡', 712193: '西螺镇', 712194: '二仑乡', 712195: '北港镇', 712196: '水林乡', 712197: '口湖乡', 712198: '四湖乡', 712199: '元长乡', 712451: '崁顶乡', 712467: '屏东市', 712468: '三地门乡', 712469: '雾台乡', 712470: '玛家乡', 712471: '九如乡', 712472: '里港乡', 712473: '高树乡', 712474: '盐埔乡', 712475: '长治乡', 712476: '麟洛乡', 712477: '竹田乡', 712478: '内埔乡', 712479: '万丹乡', 712480: '潮州镇', 712481: '泰武乡', 712482: '来义乡', 712483: '万峦乡', 712484: '莰顶乡', 712485: '新埤乡', 712486: '南州乡', 712487: '林边乡', 712488: '东港镇', 712489: '琉球乡', 712490: '佳冬乡', 712491: '新园乡', 712492: '枋寮乡', 712493: '枋山乡', 712494: '春日乡', 712495: '狮子乡', 712496: '车城乡', 712497: '牡丹乡', 712498: '恒春镇', 712499: '满州乡', 712584: '台东市', 712585: '绿岛乡', 712586: '兰屿乡', 712587: '延平乡', 712588: '卑南乡', 712589: '鹿野乡', 712590: '关山镇', 712591: '海端乡', 712592: '池上乡', 712593: '东河乡', 712594: '成功镇', 712595: '长滨乡', 712596: '金峰乡', 712597: '大武乡', 712598: '达仁乡', 712599: '太麻里乡', 712686: '花莲市', 712687: '新城乡', 712688: '太鲁阁', 712689: '秀林乡', 712690: '吉安乡', 712691: '寿丰乡', 712692: '凤林镇', 712693: '光复乡', 712694: '丰滨乡', 712695: '瑞穗乡', 712696: '万荣乡', 712697: '玉里镇', 712698: '卓溪乡', 712699: '富里乡', 712794: '马公市', 712795: '西屿乡', 712796: '望安乡', 712797: '七美乡', 712798: '白沙乡', 712799: '湖西乡', 712896: '南竿乡', 712897: '北竿乡', 712898: '东引乡', 712899: '莒光乡', 810101: '中西区', 810102: '湾仔区', 810103: '东区', 810104: '南区', 810201: '九龙城区', 810202: '油尖旺区', 810203: '深水埗区', 810204: '黄大仙区', 810205: '观塘区', 810301: '北区', 810302: '大埔区', 810303: '沙田区', 810304: '西贡区', 810305: '元朗区', 810306: '屯门区', 810307: '荃湾区', 810308: '葵青区', 810309: '离岛区', 820101: '澳门半岛', 820201: '离岛' &#125; &#125;","categories":[{"name":"浅谈前端","slug":"浅谈前端","permalink":"http://yoursite.com/categories/浅谈前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"微信小程序基础","slug":"微信小程序基础","date":"2020-09-10T10:52:40.129Z","updated":"2020-10-28T13:59:50.106Z","comments":true,"path":"2020/09/10/微信小程序基础/","link":"","permalink":"http://yoursite.com/2020/09/10/微信小程序基础/","excerpt":"","text":"一、配置小程序1、全局配置：app.json&#123; \"pages\": [ //注册页面，默认显示第一个为主页面 \"pages/home/home\", \"pages/about/about\", \"pages/profile/profile\", \"pages/category/category\" ], \"window\": &#123; //app.json才有的window参数 \"navigationBarBackgroundColor\": \"#ff5777\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"我的小程序\", \"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\", \"enablePullDownRefresh\": false &#125;, \"tabBar\": &#123; //封装好的tabBar \"selectedColor\": \"#ff5777\", //选中颜色 \"list\": [ &#123; \"pagePath\": \"pages/home/home\", \"text\": \"首页\", \"iconPath\": \"assets/tabbar/home.png\", \"selectedIconPath\": \"assets/tabbar/home_active.png\" &#125;, &#123; \"pagePath\": \"pages/category/category\", \"text\": \"分类\", \"iconPath\": \"assets/tabbar/category.png\", \"selectedIconPath\": \"assets/tabbar/category_active.png\" &#125; ] &#125;, &#125; 2、页面配置&#123; \"usingComponents\": &#123;&#125;, \"enablePullDownRefresh\": true &#125; 当前页面的优先级高过app.json 3、sitemap 配置小程序根目录下的 sitemap.json 文件用来配置小程序及其页面是否允许被微信索引。 &#123; \"rules\":[&#123; \"action\": \"allow\", \"page\": \"*\" &#125;] &#125; //或者 &#123; \"rules\":[&#123; \"action\": \"disallow\", \"page\": \"path/to/page\" &#125;] &#125; 二、逻辑层1、注册小程序app// app.js App(&#123; onLaunch (options) &#123; // Do something initial when launch. &#125;, onShow (options) &#123; // Do something when show. &#125;, onHide () &#123; // Do something when hide. &#125;, onError (msg) &#123; console.log(msg) &#125;, globalData: &#123; name: 'Guzhz', age: 18 &#125; &#125;) 整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 App 上的函数。 //其他页面的js const app = getApp() //拿到全局app console.log(app.globalData.name); 2、注册页面pagePage(&#123; onLoad: function(options) &#123; // 页面创建时执行 &#125;, onShow: function() &#123; // 页面出现在前台时执行 &#125;, onReady: function() &#123; // 页面首次渲染完毕时执行 &#125;, onHide: function() &#123; // 页面从前台变为后台时执行 &#125;, onUnload: function() &#123; // 页面销毁时执行 &#125;, onPullDownRefresh: function() &#123; // 触发下拉刷新时执行 &#125;, onReachBottom: function() &#123; // 页面触底时执行 &#125; &#125;) 3、获取用户信息//获取： &lt;button size=\"mini\" open-type=\"getUserInfo\" bindgetuserinfo=\"handGetUserInfo\"&gt; 获取授权 &lt;/button&gt; handGetUserInfo(event) &#123; console.log(event) &#125; //展示： &lt;open-data type=\"userNickName\" bindtap=\"nameClick\"&gt;&lt;/open-data&gt; 4、回调函数中的this指向Page(&#123; data: &#123; list: [] &#125;, onLoad() &#123; wx.request(&#123; url: '', success: (res) =&gt; &#123; const data = res.data.data.list; this.setData(&#123; this.list: data; //箭头函数的this会不断网上找，箭头函数这里找到的是page &#125;) &#125; &#125;) &#125;, onLoad() &#123; const _this = this; //独立定义 wx.request(&#123; url: '', success: function(res) &#123; //如果是这种写法则this指向会找不到，则需要独立定义 const data = res.data.data.list; this.setData(&#123; _this.list: data; //箭头函数的this会不断网上找，箭头函数这里找到的是page &#125;) &#125; &#125;) &#125; &#125; 二、组件1、Text组件的基本使用(span)&lt;!-- 1.1、selectable: true //现在可以不加&#123;&#123;&#125;&#125; --&gt; &lt;text selectable=\"&#123;&#123;true&#125;&#125;\"&gt;Hello World\\n&lt;/text&gt; &lt;!-- 1.2、只写属性，默认为true，不写为false --&gt; &lt;text selectable&gt;你好小程序\\n&lt;/text&gt; &lt;!-- 2、space：决定文本空格的大小 --&gt; &lt;text&gt;哈 哈\\n&lt;/text&gt; &lt;text space=\"nbsp\"&gt;哈 哈\\n&lt;/text&gt; &lt;!-- 默认就是nbsp --&gt; &lt;text space=\"ensp\"&gt;哈 哈\\n&lt;/text&gt; &lt;!-- 半个中文字符大小 --&gt; &lt;text space=\"emsp\"&gt;哈 哈\\n&lt;/text&gt; &lt;!-- 一个中文字符大小 --&gt; &lt;!-- 3、decode属性：是否解码文本 --&gt; &lt;text decode&gt;5 &amp;gt; 3&lt;/text&gt; 2、button组件的基本使用&lt;!-- 1、本身是块级元素，加了size变成行内块元素 --&gt; &lt;button size='mini'&gt;按钮&lt;/button&gt; &lt;!-- 2、type属性：bootstrap样式 --&gt; &lt;button size=\"mini\" type=\"primary\"&gt;按钮&lt;/button&gt; &lt;!-- 3、plain：镂空效果 --&gt; &lt;button size=\"mini\" plain&gt;按钮&lt;/button&gt; &lt;!-- 4、disable：不可用 --&gt; &lt;button size=\"mini\" disabled&gt;按钮&lt;/button&gt; &lt;!-- 5、loading：加载效果 --&gt; &lt;button size=\"mini\" loading=\"&#123;&#123;isLoading&#125;&#125;\"&gt;按钮&lt;/button&gt; &lt;!-- 6、hover-class --&gt; &lt;button size=\"mini\" hover-class=\"pressed\"&gt;按钮&lt;/button&gt; .pressed &#123; background: red; color: white; &#125; 3、view组件的基本使用（div）&lt;!-- 1、view的基本使用 --&gt; &lt;view&gt; &lt;text&gt;文本&lt;/text&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/view&gt; &lt;!-- 2、hover-class：用户按下组件时，显示的样式 --&gt; &lt;view class=\"box1\" hover-class=\"hover-view\" hover-stay-time=\"0\" hover-start-time=\"1000\"&gt;点下去&lt;/view&gt; &lt;!-- 3、组织传播：hover-stop-propagation：点里面的容器，外面的容器不反应 --&gt; &lt;view&gt; &lt;view hover-stop-propagation&gt;&lt;/view&gt; &lt;/view&gt; 4、image组件的基本使用&lt;!-- 重点： 1、可以写成单标签 2、默认有大小：320px*240px 3、image组件是一个行内块元素（inline-block） --&gt; &lt;!-- 相对路径 --&gt; &lt;image src=\"../../assets/tabbar/cart.png\"/&gt; &lt;!-- 绝对路径 --&gt; &lt;image src=\"/assets/tabbar/cart.png\"/&gt; &lt;!-- 远程地址 --&gt; &lt;image src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg\"/&gt; &lt;!-- 补充：相册中的图片 --&gt; &lt;button bindtap=\"handleChooseAlbum\"&gt;选中图片&lt;/button&gt; &lt;image src=\"&#123;&#123;imagePath&#125;&#125;\"/&gt; data: &#123; isLoading: true, imagePath: '' &#125;, handleChooseAlbum() &#123; //系统api wx.chooseImage(&#123; success: (res) =&gt; &#123; this.setData(&#123; imagePath: res.tempFilePaths[0] &#125;) &#125; &#125;) &#125;, &lt;!-- bindload: 监听图片加载完成 --&gt; &lt;!-- 图片懒加载 --&gt; &lt;image wx:for=\"&#123;&#123;1&#125;&#125;\" src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg\" bindload=\"handleImageLoad\" lazy-load /&gt; &lt;!-- .show-menu-by-longpress:长按图片出现识别小程序码 --&gt; &lt;image show-menu-by-longpress src=\"https://res.wx.qq.com/wxdoc/dist/assets/img/0.4cb08bb4.jpg\"/&gt; 5、input组件的基本使用&lt;!-- 1.input的基本使用 --&gt; &lt;input /&gt; &lt;!-- 2.value：input中的默认值 --&gt; &lt;input value=\"哈哈哈\"&gt;&lt;/input&gt; &lt;!-- 3.文本输入键盘 --&gt; &lt;input type=\"number \"&gt;&lt;/input&gt; &lt;!-- 4.password类型 --&gt; &lt;input password&gt;&lt;/input&gt; &lt;!-- 5.提示内容 --&gt; &lt;input placeholder=\"提示内容\"&gt;&lt;/input&gt; &lt;!-- 6.confire-type --&gt; &lt;input confirm-type=\"search\"&gt;&lt;/input&gt; &lt;!-- 7.input绑定事件 --&gt; &lt;input bindinput=\"handleInput\" bindfocus=\"handleFocus\" bindblur=\"handleBlur\"&gt;&lt;/input&gt; handleInput(event) &#123; console.log(\"用户输入内容：\",event); &#125;, handleFocus(event) &#123; console.log(\"input获取焦点：\",event); &#125;, handleBlur(event) &#123; console.log(\"input失去焦点：\",event); &#125; 6、scroll-view组件的基本使用&lt;!-- 1.水平滚动：scroll-x --&gt; &lt;scroll-view class=\"container1\" scroll-x&gt; &lt;view wx:for=\"&#123;&#123;10&#125;&#125;\" class=\"item1\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 2.垂直滚动：scroll-y --&gt; &lt;scroll-view class=\"container2\" scroll-y&gt; &lt;view wx:for=\"&#123;&#123;10&#125;&#125;\" class=\"item2\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;/scroll-view&gt; &lt;!-- 3.其他补充 --&gt; &lt;scroll-view class=\"container2\" scroll-y bindscroll=\"handleScroll\"&gt; &lt;view wx:for=\"&#123;&#123;10&#125;&#125;\" class=\"item2\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;/scroll-view&gt; .container1 &#123; background: pink; white-space: nowrap; &#125; .item1 &#123; width: 100px; height: 100px; background: red; margin: 10px; display: inline-block; &#125; .container2 &#123; background: orange; height: 100px; &#125; .item2 &#123; width: 100px; background: blue; margin: 10px; &#125; 7、事件对象1）常见事件监听 bindtouchstart：手指触摸开始 bindtouchmove：手指触摸移动 bindtouchend：手指触摸结束 bindtouchcancel：手指触摸取消 bindtap：起点手势 {两者只会触发一个} bindlongpress：手指长按 {两者只会触发一个} 2）事件参数传递(data-)for: &lt;view data-index=\"&#123;&#123;index&#125;&#125;\" data-item=\"&#123;&#123;item&#125;&#125;\"&gt;&lt;/view&gt; 取： const dataset = event.currentTarget.dataset; const title = dataset.item; const index dataset.index; 3）事件捕获和冒泡捕获：事件从外到内依次进行捕获（capture-bind:tap） 冒泡：事件从内到外依次进行冒泡（bindtap） 阻止：事件一旦被当前标签阻止了，则不再进行捕获或者冒泡（catch-bind:tap、catchtap） 三、样式1、基本使用&lt;!-- 1.1、内联样式 --&gt; &lt;view style=\"color: red\"&gt;哈哈哈&lt;/view&gt; &lt;!-- 1.2、页内样式 --&gt; &lt;view class=\"box\"&gt;呵呵呵&lt;/view&gt; &lt;!-- 1.3、全局样式 --&gt; &lt;view class=\"container\"&gt;嘿嘿嘿&lt;/view&gt; &lt;!-- 2、权重：!important &gt; 内联 &gt; 页内 &gt; 全局 &gt; 元素 --&gt; &lt;!-- 3、wxss中的单位：rpx，用于做适配，默认是px的一半，所以要写成2倍--&gt; &lt;view class=\"box1\"&gt;嗯嗯嗯&lt;/view&gt; 2、导入样式@import ‘路径’ 3、官方样式库https://github.com/Tencent/weui-wxss 的dist文件夹 四、wxml基本语法1、wx:if2、wx:if wx:elif wx:else3、hidden隐藏（wx:if不渲染）4、wx:for（item，index） item起别名：wx:for-item=”movie” index起别名：wx:for-index=”i”，多用于多层遍历。 列表渲染，wx:key作为唯一标识，提高性能（diff算法） 如果不加key，例如对数组dom进行插入的时候，则会使插入位置的后面的所有dom都进行改变 如果加了key，则会在对每个dom添加一个id标识，在插入的时候不会影响后面的dom，提高了性能 5、block标签这个标签不是组件，主要用于包裹元素，不会被渲染成dom，提高性能。可以替代 6、template模板（少用）&lt;template name=\"名字\"&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;view&gt;哈哈哈&lt;/view&gt; &lt;/template&gt; 使用：&lt;template is=\"名字\"/&gt; ------------------------------- &lt;template name=\"名字\"&gt; &lt;button&gt;&#123;&#123;btnText&#125;&#125;&lt;/button&gt; &lt;view&gt;&#123;&#123;content&#125;&#125;&lt;/view&gt; &lt;/template&gt; 类似插槽：&lt;template is=\"名字\" data=\"&#123;&#123;btnText: '按钮', content: '哈哈哈'&#125;&#125;\"/&gt; ps：wxml导入/引入，把模板抽离到单独的一个wxml文件里 import可以导入模板，但不能循环导入 include不能引入模板，但是可以循环引入wxml文件 五、wxs模块（类似js，但不是js）1、当前页面的写法&lt;wxs module=\"info\"&gt; //es5语法 var message = \"Hello, world\"; var name = \"hhh\"; var sum = function(num1, num2) &#123; return num1 + num2; &#125; module.exports = &#123; message: message, name: name, sum: sum &#125; &lt;/wxs&gt; &lt;view&gt;&#123;&#123;info.message&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;info.name&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;info.sum(10,20)&#125;&#125;&lt;/view&gt; 2、分离写法类似js模块化开发 //info.wxs文件： var message = \"Hello, world\"; var name = \"hhh\"; var sum = function (num1, num2) &#123; return num1 + num2; &#125; module.exports = &#123; message: message, name: name, sum: sum &#125; //导入使用 &lt;wxs src=\"./mywxs.wxs\" module=\"info\"/&gt; //只能是相对路径 &lt;view&gt;&#123;&#123;info.message&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;info.name&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;info.sum(10,20)&#125;&#125;&lt;/view&gt; 六、组件化开发1、基本使用//my-cpn.wxml，定义 &lt;view class=\"title\"&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;view class=\"content\"&gt;我是自定义组件的内容&lt;/view&gt; //home.json注册 &#123; \"usingComponents\": &#123; \"mycpn\": \"/components/my-cpn/my-cpn\" &#125; &#125; //home.wxml使用 &lt;mycpn/&gt; //可以在app.json里面进行全局注册。但是不建议都放在app.json里面 2、样式问题 组件里面的样式和页面的样式互不影响，默认存在隔离。 组件里面不推荐使用id选择器，只用class选择器。 特殊需求：需要它们相互影响 组件的.js文件 Component(&#123; options: &#123; styleIsolation: \"isolated\" //默认是隔离的 styleIsolation: \"apply-shared\" //应用组件被分享，也就是页面影响了组件 styleIsolation: \"shared\" //互相影响 &#125; &#125;) 3、组件和页面的通信1）页面给组件传递参数//组件.js文件 Component(&#123; //定义属性 properties: &#123; // title: String title: &#123; type: String, value: \"我是默认的标题\", observer: function(newValue, oldValue) &#123; //观察者 console.log(newValue, oldValue); &#125; &#125; &#125; &#125;) //组件 &lt;view class=\"title\"&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; &lt;view class=\"content\"&gt;我是自定义组件的内容&lt;/view&gt; &lt;!-- 使用自定义组件 --&gt; &lt;mycpn title=\"hhh\"/&gt; &lt;mycpn title=\"xxx\"/&gt; &lt;mycpn /&gt; 2）页面给组件传递样式//1.组件js声明一个样式变量 Component(&#123; externalClasses: ['titleclass'] &#125;) //2.组件wxml使用该变量 &lt;view class=\"title titleclass\"&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt; //3.页面给变量赋值（传递），此时dom里面就有class=\"red\"了 &lt;mycpn title=\"hhh\" titleclass=\"red\"/&gt; //4.在页面的wxss里面添加.red的样式，使其dom被作用了即可 .red &#123; color: red; &#125; 3）组件给页面传递事件 - 自定义事件//1.组件监听事件 &lt;button size=\"mini\" bind:tap=\"handleIncrement\"&gt;+1&lt;/button&gt; //2.监听事件发射事件 methods: &#123; handleIncrement() &#123; this.triggerEvent(\"increment\",&#123;name: \"hhh\"&#125;,&#123;&#125;) //事件名，&#123;key:value 额外参数&#125; &#125; &#125; //3.页面接收，然后绑定自己的方法 &lt;my-event bind:increment=\"handleIncrement\"/&gt; //4.页面实现自己的方法 handleIncrement(event) &#123; console.log(event); //参数在event.detail里面 this.setData(&#123; counter: this.data.counter+1 &#125;) &#125;, 4、获得组件对象需求：在页面上不通过传参的方式，修改组件的data数据，则需要获取组件对象从而setData() 方法：this.selectComponent(&quot;#sel_id&quot;) //绑定id或者class //1.给使用的组件绑定一个id或者class &lt;my-select id=\"sel_id\"/&gt; //组件定义数据 data: &#123; counter: 0 &#125;, //2.页面监听事件 &lt;button size=\"mini\" bind:tap=\"handleIncrementCpnData\"&gt;修改组件内的数据+1&lt;/button&gt; handleIncrementCpnData() &#123; //修改my-select的counter //想办法获得组件对象 const my_select = this.selectComponent(\"#sel_id\") //绑定id或者class my_select.setData(&#123; counter: my_select.data.counter + 1 &#125;) &#125;, //------更优雅的方式------ 让组件暴露出一个方法，页面调用方法来修改，而不是直接修改对象的数据 methods: &#123; incrementCounter(num) &#123; this.setData(&#123; counter: this.data.counter + num &#125;) &#125; &#125; handleIncrementCpnData() &#123; const my_select = this.selectComponent(\"#sel_id\") //绑定id或者class my_select.incrementCounter(10) &#125;, 5、插槽的使用1）单插槽//1.组件预留插槽 &lt;view&gt;我的插槽的头部&lt;/view&gt; &lt;slot/&gt; &lt;view&gt;我的插槽的尾部&lt;/view&gt; //2.注册使用插槽 &lt;my-slot&gt; &lt;button&gt;我是插槽的按钮&lt;/button&gt; &lt;/my-slot&gt; 2）多插槽注意点： 具名：组件插槽起名字：name=”名字”，页面使用slot=”名字” Component添加options，开启多插槽：multipleSlots: true //1.组件预留插槽 &lt;view&gt;我的插槽的头部&lt;/view&gt; &lt;view&gt;&lt;slot name=\"left\"&gt;&lt;/slot&gt;&lt;/view&gt; &lt;view&gt;&lt;slot name=\"center\"&gt;&lt;/slot&gt;&lt;/view&gt; &lt;view&gt;&lt;slot name=\"right\"&gt;&lt;/slot&gt;&lt;/view&gt; &lt;view&gt;我的插槽的尾部&lt;/view&gt; //2.开启多插槽 Component(&#123; options: &#123; multipleSlots: true &#125; &#125;) //3.注册使用插槽 &lt;my-slot&gt; &lt;text slot=\"left\"&gt;我是左边&lt;/text&gt; &lt;text slot=\"center\"&gt;我是中间&lt;/text&gt; &lt;text slot=\"right\"&gt;我是右边&lt;/text&gt; &lt;/my-slot&gt; 6、component构造器 properties：可以让使用者给组件传入数据 data：定义主键内部的初始化数据 methods：定义组件内部函数 options：定义组件的配置选项 externalClasses：[]，外界给组件传入额外的样式 observers：可以监听属性properties/data的改变 observers: &#123; counter: function(newValue) &#123; &#125; //没有oldvalue &#125; 组件所在页面的生命周期 pageLifetimes: &#123; show() &#123; console.log(\"监听组件所在页面显示出来时\") &#125;, hide() &#123; console.log(\"监听组件所在页面隐藏起来时\") &#125;, resize() &#123; console.log(\"监听组件所在页面尺寸的改变\") &#125; &#125; 监听组件本身 lifetimes: &#123; created() &#123;&#125;, //创建出来 attached() &#123;&#125;, //被添加时 ready() &#123;&#125;, //组件被渲染出来时 moved() &#123;&#125;, //组件被移动到另外一个节点时 detached() &#123;&#125; //组件被移除 &#125; 七、网络请求1、基本使用onLoad: function (options) &#123; //1.最简单的发送请求 wx.request(&#123; url: 'http://152.136.185.210:8000/api/z8/recommend', success: function(res) &#123; console.log(res) &#125; &#125;), //2.get请求，但是携带参数 wx.request(&#123; url: 'http://152.136.185.210:8000/api/z8/home/data', data: &#123; type: 'sell', page: 1 &#125;, success: function(res) &#123; console.log(res) &#125; &#125;) //3.post请求，并且携带参数 wx.request(&#123; url: 'http://httpbin.org/post', method: 'POST', data: &#123; name: 'guzhz', age: 18 &#125;, success: function(res) &#123; console.log(res) &#125;, fail: function(err) &#123; console.log(err) &#125; &#125;) &#125; 2、请求封装（promise）export default function request(options) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: options.url, method: options.method || 'GET', //默认是get data: options.data || &#123;&#125;, success: resolve, //本身就是回调函数 fail: reject &#125;) &#125;) &#125; import request from '../../service/network.js' onLoad: function (options) &#123; // get_data_origin(); request(&#123; url: 'http://152.136.185.210:8000/api/z8/recommend', &#125;).then(res =&gt; &#123; console.log(res) &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, 八、界面交互1、弹窗（showToast）handleShowToast() &#123; wx.showToast(&#123; title: '我是标题', duration: 1000, icon: 'loading', mask: true, //防止触摸蒙版， success: function() &#123; console.log(\"展示弹窗成功！\"); &#125;, fail: function() &#123; console.log(\"展示弹窗失败！\"); &#125;, complete: function() &#123; console.log(\"完成调用！\"); &#125; &#125;) &#125;, 2、模态框（showModal）wx.showModal(&#123; title: '标题', content: '内容', cancelColor: 'red', showCancel: true, cancelText: '退出', success: function(res) &#123; console.log('展示成功！') if(res.cancel) &#123; console.log(\"点击了取消\") &#125; if(res.confirm) &#123; console.log(\"点击了确定\") &#125; &#125; &#125;) 3、加载（showLoading）wx.showLoading(&#123; title: '加载ing', mask: true &#125;) //需手动取消加载才会消失 setTimeout(function () &#123; wx.hideLoading() &#125;, 2000) 4、下方活动表单（showActionSheet）wx.showActionSheet(&#123; itemList: ['相册','拍照'], itemColor: 'red', success: function(res) &#123; console.log(res) //res.tapIndex &#125; &#125;) 5、使用分享/** * 用户点击右上角分享 */ onShareAppMessage: function () &#123; return &#123; title: '转发标题', path: '/pages/about/about', imageUrl: '本地图片/网络图片', //默认是首页的截图 &#125; &#125; //按钮直接分享 &lt;button size=\"mini\" open-type=\"share\"&gt;分享&lt;/button&gt; 九、登录流程 1.调用wx.login获取code 2.调用wx.request发送code到我们自己的服务器（返回一个标识token） 3.将登录态的标识token进行存储，以便下次使用 4.请求需要登录态接口时，携带token const TOKEN = 'token' App(&#123; globalData: &#123; token: '' &#125;, /** * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */ onLaunch: function () &#123; //1.先判断缓存中取出token const token = wx.getStorageSync(TOKEN) //2.判断是否token是否过期 if (token &amp;&amp; token.length !== 0) &#123; //判断是否过期 this.check_token() &#125; else &#123; //如果不存在则登录 this.login(); &#125; &#125;, check_token(token) &#123; console.log(\"执行了验证操作！\") wx.request(&#123; url: 'http://152.136.185.210:8000/api/z8/auth', header: &#123; token //接口中用请求头的方式传递token &#125;, success: (res) =&gt; &#123; //正在验证 if (!res.data.errCode) &#123; //当前token有效 this.globalData.token = token //再次存储一遍 &#125; else &#123; //当前token无效：1001：没有传入token，1002：传入错误的token，1003：token过期 this.login(); &#125; &#125;, fail: (err) =&gt; &#123; console.log(err) &#125; &#125;) &#125;, login() &#123; console.log(\"执行了登录操作！\") wx.login(&#123; success: (res) =&gt; &#123; //1.获取code，只有5分钟有效期 const code = res.code; //2.将code发送给我们的服务器 wx.request(&#123; url: 'http://152.136.185.210:8000/api/z8/login', method: 'post', data: &#123; code //可能还需要appid和appsecret &#125;, success: (res) =&gt; &#123; //1.取出token const token = res.data.token //2.保存到全局方便实用 this.globalData.token = token //3.存储在缓存里，用于判断登录态 wx.setStorageSync('TOKEN', token) //同步 &#125; &#125;) &#125; &#125;) &#125; &#125;) 十、页面跳转1）普通跳转&lt;!-- 1、页面跳转，不支持跳转到导航页 --&gt; &lt;navigator url='/pages/category/category'&gt;跳转到category&lt;/navigator&gt; //返回： &lt;navigator open-type=\"navigateBack\" dalta=\"2\"&gt;返回层级，默认是1也就是上一级&lt;/navigator&gt; &lt;!-- 2、重定向页面跳转，会把前一个页面销毁掉，不支持跳转到导航页 --&gt; &lt;navigator url='/pages/category/category' open-type=\"redirect\"&gt;重定向&lt;/navigator&gt; &lt;!-- 3、switchTab，切换到导航的指定页--&gt; &lt;navigator url='/pages/about/about' open-type=\"switchTab\"&gt;切换到导航的指定页&lt;/navigator&gt; &lt;!-- 4、reLaunch，不支持跳转到导航页 --&gt; &lt;navigator url='/pages/category/category' open-type=\"reLaunch\"&gt;关闭所有页面再跳转&lt;/navigator&gt; 2）传参跳转 往下一层传参 &lt;!-- 页面跳转携带参数 --&gt; &lt;navigator url='/pages/category/category?name=Guzhz&amp;age=15'&gt;跳转到category&lt;/navigator&gt; &lt;!-- category取出参数，onload的options参数 --&gt; onLoad: function (options) &#123; console.log(options); &#125; 往上一层传参，没有直接的方法，但是可以通过获得上一层的页面对象来进行操作 //需求：从home跳转到category，通过category修改home的数据 //category的js onUnload: function () &#123; const pages = getCurrentPages(); //获得活跃的页面，得到的是一个数组 const home = pages[pages.length-2]; //下标-2是获得上一个页面，不建议直接写0，因为不知道多少层 home.setData(&#123; message: '改变了' &#125;) &#125;, 3）通过方法跳转，利用同样的api//跳转 handlePushDetail() &#123; wx.navigateTo(&#123; url: '/pages/detail/detail?title=你好啊' &#125;) &#125; //返回 handleBackHome() &#123; wx.navigateBack(&#123; delta: 1 //可以不写 &#125;) &#125;","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"VUE学习（八）：axios使用","slug":"VUE学习（八）：axios使用","date":"2020-08-04T08:08:37.000Z","updated":"2020-10-27T04:49:28.000Z","comments":true,"path":"2020/08/04/VUE学习（八）：axios使用/","link":"","permalink":"http://yoursite.com/2020/08/04/VUE学习（八）：axios使用/","excerpt":"","text":"axios：网络请求1、安装：npm install axios –save2、基本使用import axios from 'axios' axios(&#123; //没有参数 //httpbin.org url: 'http://152.136.185.210:8000/api/z8/home/multidata', method: 'get' //默认是post &#125;).then(res =&gt;&#123; console.log(res) &#125;) axios(&#123; url: 'http://152.136.185.210:8000/api/z8/home/data', params: &#123; //有参数 type: 'pop', page: 1 &#125; &#125;).then(res =&gt; &#123; console.log(res) &#125;) 3、并发请求（改使用全局配置）axios.defaults.baseURL = 'http://152.136.185.210:8000/api/z8' axios.defaults.timeout = 5000 // 2.axios并发请求 axios.all([axios(&#123; //axios.all() url: '/home/multidata' &#125;), axios(&#123; url: '/home/data', params: &#123; type: 'pop', page: 4 &#125; &#125;)]) // .then(results =&gt; &#123; // console.log(results[0]); // console.log(results[1]); // &#125;) // 另一种写法 .then(axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2); &#125;)) 4、创建独立实例（解决多个全局配置问题）//创建实例并配置全局 const instance1 = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //使用实例 instance1(&#123; url: '/home/multidata' &#125;).then(res =&gt; &#123; console.log(res); &#125;) //使用实例 instance1(&#123; url: '/home/data', params: &#123; type: 'pop', page: 1 &#125; &#125;).then(res =&gt; &#123; console.log(res); &#125;) 5、封装模块network -&gt; request.js 方法一：回调函数方式（config, success, failure）//request.js //导出实例，为了保证拓展性，就不使用default import axios from 'axios' export function request(config, success, failure) &#123; //1、创建实例 const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //2、真正发送网络请求，config为请求的数据 instance(config) .then(res =&gt; &#123; success(res) &#125;) .catch(err =&gt; &#123; failure(err) &#125;) &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; url: '/home/multidata' &#125;, res =&gt; &#123; console.log(res); &#125;, err =&gt; &#123; console.log(err); &#125;) 方法二：回调函数方式（config） -&gt; (baseConfig, function(),function)import axios from 'axios' export function request(config) &#123; //1、创建实例 const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //2、真正发送网络请求，config为请求的数据 instance(config.baseConfig) .then(res =&gt; &#123; config.success(res) &#125;) .catch(err =&gt; &#123; config.failure(err) &#125;) &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; baseConfig: &#123; url: '/home/multidata' &#125;, success: function (res) &#123; console.log(res); &#125;, failure: function (err) &#123; console.log(err); &#125; &#125;) 方法三：使用Promise方式import axios from 'axios' export function request(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) instance(config) .then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; url: '/home/multidata' &#125;).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 方法四：优化Promise方式import axios from 'axios' export function request(config) &#123; const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) return instance(config) //因为本身返回的就是Promise &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; url: '/home/multidata' &#125;).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 6、拦截器的使用export function request(config) &#123; const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //axios请求拦截 //一般拦截：不符合服务器的要求的信息需要修改、在界面中显示请求图标结束后取消掉、某些请求需要特殊信息token instance.interceptors.request.use(config =&gt; &#123; console.log(config); //成功走这里 return config //一定要放行 &#125;, err =&gt; &#123; //失败走这里，一般不会走这里 console.log(err); &#125;) //响应拦截 instance.interceptors.response.use(res =&gt; &#123; console.log(res); return res.data //只需要取出data &#125;, err =&gt; &#123; console.log(err); &#125;) return instance(config) &#125; 2020年08月4日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（七）：VueX的使用","slug":"VUE学习（七）：VueX的使用","date":"2020-08-02T19:08:37.000Z","updated":"2020-10-27T04:49:28.000Z","comments":true,"path":"2020/08/03/VUE学习（七）：VueX的使用/","link":"","permalink":"http://yoursite.com/2020/08/03/VUE学习（七）：VueX的使用/","excerpt":"","text":"VueX：管理组件间的共享资源1、安装和使用：npm install vuex@3.0.1 –save 1、新建store包，放在index.js里 import Vue from 'vue' import Vuex from 'vuex' //安装插件 Vue.use(Vuex) //创建对象 const store = new Vuex.Store(&#123; state: &#123; counter: 1000 &#125;, mutations: &#123; //记录处理记录 &#125;, actions: &#123; //异步处理，对接后端 &#125;, getters:&#123; &#125;, modules: &#123; &#125; &#125;) //导出 export default store 2、main.js，通过vue使用vuex插件 import store from './store' //导入对应的包即可 Vue.prototype.$store = store 3、使用共享数据（不建议直接修改） &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; 4、安装devtools浏览器插件（谷歌商店）进行调试 //定义处理方法（这个方法经过vuex插件 mutations: &#123; //记录处理记录 increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;, //通过提交的方式，字符串参数为方法名 methods: &#123; add() &#123; this.$store.commit('increment') &#125;, minus() &#123; this.$store.commit('decrement') &#125; &#125; 2、state：管理状态 单一状态树，即vuex本身不建议创建多个，只需要一个即可，方便管理 3、getters：计算属性 | 函数参数：state、(getters) 可以理解为计算属性，对数据的复杂处理，然后按照属性的方式进行调用 getters:&#123; powerCounter(state) &#123; return state.counter * state.counter &#125; &#125;, 妙用：需要对已有的方法进行进一步处理，可以再写个方法传getters进去，然后调用指定的方法进行处理 more20stu(state) &#123; return state.students.filter(s =&gt; s.age&gt;20) &#125;, more20stuLength(state, getters) &#123; //只接受state和getters，两个参数 return getters.more20stu.length; &#125; 需求：调动getters的方法时，需要指定参数 思想：因为getters不接受自定义参数，则可以通过嵌套函数，由函数处理传进来的参数，然后return回去 &lt;h2&gt;超过指定年龄的学生：&#123;&#123;$store.getters.moreAgeStu(17)&#125;&#125;&lt;/h2&gt; //17就传到function里面了 moreAgeStu(state) &#123; return function (age) &#123; return state.students.filter(s =&gt; s.age &gt; age); &#125; &#125; 4、mutations：| 函数参数：state、%| 调用：commit 1、修改state参数时使用 2、传递参数 //App.vue addStudent() &#123; const stu = &#123;id: 5, name: 'eee', age: 111&#125; this.$store.commit('addStudent',stu) &#125; addStudent(state, stu) &#123; state.students.push(stu) &#125; 3、提交风格（传对象） addCount(count) &#123; //直接传数字 // this.$store.commit('incrementCount',count) //传对象 this.$store.commit(&#123; type: 'incrementCount', count &#125;) &#125;, //接收的时候也是对象，需要在对象里取出对应的值，注意：传的type会自动查找指定函数 incrementCount(state,payload) &#123; console.log(payload); state.counter += payload.count; &#125;, 4、响应式系统：需要提前初始化好才会是响应式；如果动态添加属性，则不会响应式（观察者模式） 解决： &gt; 添加： 响应式：Vue.set(state.info, 'key', 'value') //对象 &gt; 删除： 非响应式：delete state.info.age 响应式：Vue.delete(state.info, 'age') 5、类型常量（解决方法名可能写错的问题） //新建mutation-types.js，统一常量名然后导出 export const INCREMENT = 'increment' import &#123;INCREMENT&#125; from \"./store/mutations-types\"; //Vue.vue使用 add() &#123; this.$store.commit(INCREMENT) &#125;, //index.js使用 [INCREMENT](state) &#123; //用括号包起来 state.counter++ &#125;, 5、actions：异步操作 | 函数参数：context，payload | 调用：dispatch原理：把异步请求放在actions里，在actions的方法里通过commit请求mutations，vue通过dispatch调用actions的方法 //按钮点击修改 updateInfo() &#123; this.$store.dispatch('aUpdateInfo','我是payload') &#125; //来到actions actions: &#123; //异步处理，对接后端 //上下文，理解为store对象 aUpdateInfo(context,payload) &#123; setTimeout(() =&gt; &#123; console.log(payload); context.commit('updateInfo') &#125;, 1000) &#125; &#125;, //来到mutations updateInfo(state) &#123; state.info.name = 'hhh' &#125; 高操作：点击按钮后，来到actions发送请求，然后放回Promise对象，对象存放回调信息，然后在一开始的按钮函数里then()拿出信息 //按钮 updateInfo() &#123; //需求：请求完了，要返回一个回调信息 new Promise this.$store .dispatch('aUpdateInfo','我是携带的信息') .then(res =&gt; &#123; console.log('----------------------') console.log(res); &#125;) &#125; //回调 aUpdateInfo(context,payload) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(payload); context.commit('updateInfo') resolve('回调信息') &#125;, 1000) &#125;) &#125; 我的payload 我是携带的信息 ---------------------- 回调信息 6、modules：嵌套子模块modules: &#123; a: moduleA &#125; const moduleA = &#123; state: &#123; name: 'zhangsan', &#125;, mutations: &#123; updateName(state, payload) &#123; //使用方法一样： this.$store.commit('updateName','lisi') state.name = payload &#125; &#125;, getters: &#123; //使用方法一样：&#123;&#123;$store.getters.fullName&#125;&#125; fullName(state) &#123; return state.name + '1111' &#125;, fullName2(state, getters) &#123; return getters.fullName + '2222' &#125;, fullName3(state, gettters, rootState) &#123; //多了一个参数，可以拿到根的state return gettters.fullName2 + rootState.counter &#125; &#125;, actions: &#123; aUpdateName(context) &#123; //context不再是store对象，而是指本模块，commit也只能是自己的 setTimeout(() =&gt; &#123; context.commit('updateName','wangwu') &#125;,1000) &#125; &#125; &#125; 7、文件目录组织1、对象的解构const obj = &#123; name: 'hh', age: 18, height: 1.88, address: '洛杉矶' &#125; const &#123;name,height,age&#125; = obj; //不用按顺序，按需取出 cosole.log(name) //直接使用 2、拆分store |--modules |--moduleA.js |mutations.js |mutations-types.js |getters.js |actions.js |index.js 2020年08月4日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（六）：Promise的使用","slug":"VUE学习（六）：Promise的使用","date":"2020-08-01T11:08:37.000Z","updated":"2020-10-27T04:49:28.000Z","comments":true,"path":"2020/08/01/VUE学习（六）：Promise的使用/","link":"","permalink":"http://yoursite.com/2020/08/01/VUE学习（六）：Promise的使用/","excerpt":"","text":"Promise的使用1. Promise的基本使用&lt;script&gt; //Promise：优雅的解决嵌套请求问题，使代码看起来更清晰，即链式编程 //什么情况下会用到Promise？ //有异步操作时，用Promise对这个异步操作进行封装 new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; //成功的时候执行，然后走then // resolve('hello world') //失败则调用reject reject('error message') &#125;, 1000) &#125;).then((data) =&gt; &#123; // 拿到数据，然后处理 console.log(data); console.log(data); console.log(data); console.log(data); console.log(data); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;) &lt;/script&gt; 2. Promise的另一种写法&lt;script&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve('hello resolve') reject('error message') &#125;,1000) &#125;).then(data =&gt; &#123; console.log(data); &#125;, err =&gt; &#123; console.log(err); &#125;) &lt;/script&gt; 3. Promise的链式调用&lt;script&gt; new Promise((resolve, reject) =&gt; &#123; //1 setTimeout(() =&gt; &#123; resolve() &#125;,1000) &#125;).then(() =&gt; &#123; console.log('第一次处理'); return new Promise((resolve, reject) =&gt; &#123; //2 setTimeout(() =&gt; &#123; resolve() &#125;,1000) &#125;) &#125;).then(() =&gt; &#123; console.log('第二次处理'); return new Promise((resolve, reject) =&gt; &#123; //3 setTimeout(() =&gt; &#123; resolve() &#125;,1000) &#125;) &#125;).then(() =&gt; &#123; console.log(\"第三次处理\"); &#125;) &lt;/script&gt; 4. Promise的简洁写法&lt;script&gt; //需求：aaa-&gt;自己处理10行 //处理：aaa111-&gt;自己处理10行 //处理：aaa111222 -&gt; 自己处理 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('aaa') &#125;,1000) &#125;).then(res =&gt; &#123; //1 console.log(res + '第一次处理'); //2，对结果进行第一次处理 return Promise.resolve(res + '111') &#125;).then(res =&gt; &#123; console.log(res + '第二次处理'); return Promise.resolve(res + '222') &#125;).then(res =&gt; &#123; console.log(res + \"第三次处理\"); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) &lt;/script&gt; //&gt; return new Promise((resolve, reject) =&gt; &#123; resolve(res + '111') &#125;) //&gt; return Promise.resolve(res + '111') //reject同理 //&gt; return res + '111' //throw 'err message' 5. Promise的all方法的使用&lt;script&gt; //处理多个请求的结果，传入可迭代的容器：数组，数组存放请求 //伪代码 Promise.all([ new Promise((resolve, reject) =&gt; &#123; $ajax([ url: 'url1', success: function (data) &#123; resolve(data) &#125; ]) &#125;), new Promise((resolve, reject) =&gt; &#123; $ajax([ url: 'url2', success: function (data) &#123; resolve(data) &#125; ]) &#125;) ]).then(results =&gt; &#123; //这里的参数也是数组 console.log(results[0]); console.log(results[1]); &#125;) &lt;/script&gt; //模拟使用 &lt;script&gt; //处理多个请求的结果，传入可迭代的容器：数组，数组存放请求 Promise.all([ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;name: 'result1', age: 18&#125;) &#125;,2000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"result2\") &#125;,1000) &#125;) ]).then(results =&gt; &#123; //这里的参数也是数组 console.log(results[0].age); console.log(results[1]); &#125;) &lt;/script&gt; 2020年08月4日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（五）：vue-router的使用","slug":"VUE学习（五）：vue-router的使用","date":"2020-07-29T11:21:37.000Z","updated":"2020-10-27T04:47:53.000Z","comments":true,"path":"2020/07/29/VUE学习（五）：vue-router的使用/","link":"","permalink":"http://yoursite.com/2020/07/29/VUE学习（五）：vue-router的使用/","excerpt":"","text":"一、vue-router的使用1、使用方法 1、components文件夹新建vue文件； 2、index.js添加映射路径（导入组件）； 3、App.vue使用组件 2、改hash路径为history路径 index.js -&gt; Router对象：mode: ‘history’, 3、router-link的使用&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;我是app组件&lt;/h2&gt; &lt;!--默认a标签，tag指定标签，replace：replaceState（禁止来回返回）--&gt; &lt;router-link to=\"/home\" tag=\"button\" replace&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\" tag=\"button\" replace&gt;关于&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 4、router-link-active//当&lt;router-link&gt;对应的路由匹配成功时，会自动给元素设置一个router-link-active的class，可以对这个类进行样式设置 .router-link-active &#123; color: red; &#125; //修改默认的名称：index.js，使用linkActiveClass: 'active'，则会修改陈active .active &#123; color: red; &#125; 5、绑定方法，使用this.$router.push(‘/home’)跳转页面&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;我是app组件&lt;/h2&gt; &lt;button @click=\"clickHome\"&gt;首页&lt;/button&gt; &lt;button @click=\"clickAbout\"&gt;关于&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; export default &#123; name: 'App', methods: &#123; clickHome() &#123; this.$router.replace('/home').catch(err =&gt; &#123;&#125;); //区别push console.log('clickHome'); &#125;, clickAbout() &#123; this.$router.replace('/about').catch(err =&gt; &#123;&#125;); console.log('clickAbout'); &#125; &#125; &#125; 6、$router、$route、routes的区别 1、$router：代指Router对象，使用：this.$router； 2、$route：指当前正在活跃(使用)的路由：通过this.$route.params.参数，可以拿到参数 3、routes：index.js路由管理里面，Router对象里的属性，也是映射管理； 7、动态路由（路由传参）&lt;router-link v-bind:to=\"'/user/'+uId\"&gt;用户&lt;/router-link&gt; data() &#123; return &#123; uId: 'ss' &#125; &#125;, ------User.vue------ &lt;template&gt; &lt;div&gt; &lt;h2&gt;我是用户界面&lt;/h2&gt; &lt;p&gt;我是用户的相关信息，略略略&lt;/p&gt; &lt;h2&gt;&#123;&#123;userId&#125;&#125;&lt;/h2&gt; &lt;!--展示--&gt; &lt;h2&gt;&#123;&#123;$route.params.uId&#125;&#125;&lt;/h2&gt; &lt;!--直接拿--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: \"user\", computed: &#123; userId() &#123; return this.$route.params.uId //获得参数 &#125; &#125; &#125; &lt;/script&gt; 8、路由的懒加载 把不同的路由拆分为多个js文件，不一起打包，用到的时候再加载。 /*懒加载*/ const Home = () =&gt; import('../components/Home') const About = () =&gt; import('../components/About') const User = () =&gt; import('../components/User') 在index.js里，把之前直接引入的方式，改为声明为一个变量（常量），用到时候再引用，即加载 9、嵌套子路由 1、新建vue：HomeNews.vue/HomeMessage.vue 2、配置子路由映射children[{},{}] ，不需要”/“ 3、父vue模板，也加上 4、注意：router-link to=”完整路径” &#123; path: '/home', component: Home, children: [ &#123; path: 'news', //不需要加 '/' component: HomeNews &#125;, &#123; path: 'message', //不需要加 '/' component: HomeMessage &#125; ] &#125;, &lt;template&gt; &lt;div&gt; &lt;h2&gt;我是首页&lt;/h2&gt; &lt;p&gt;我是首页内容，嘻嘻嘻&lt;/p&gt; &lt;router-link to=\"/home/news\"&gt;新闻&lt;/router-link&gt; &lt;router-link to=\"/home/message\"&gt;消息&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 10、路由参数传递1. 方式一：restful风格&lt;router-link v-bind:to=\"'/user/'+uId\"&gt;用户&lt;/router-link&gt; &#123; path: '/user/:uId', component: User &#125;, &#123;&#123;$route.params.uId&#125;&#125; 2. 方式二：query传递&lt;router-link v-bind:to=\"&#123;path: '/profile', query: &#123;name: 'guzhz', age: 18&#125;&#125;\"&gt;档案&lt;/router-link&gt; &#123;&#123;$route.query.name&#125;&#125; &#123;&#123;$route.query.age&#125;&#125; 11、全局导航守卫1. 生命周期的方式实现created() &#123; console.log('组件被创建的时候回调'); document.title = '首页'; &#125;, mounted() &#123; console.log('dom被挂载的时候回调'); &#125;, updated() &#123; console.log('界面刷新则回调'); &#125; 2. 前置钩子：全局导航守卫（cil4里则用to.name即可）//router调用beforeEach，参数是一个函数 //matched[0],解决嵌套的时候undefined的问题 router.beforeEach((to, from ,next) =&gt; &#123; document.title = to.matched[0].meta.title; next(); //必须调用，才能下一步 &#125;) //在各自的route里面添加meta(元数据，描述数据的数据) &#123; path: '/user/:uId', component: User, meta: &#123; title: '用户' &#125; &#125;, 3. 补充：后置钩子（没有next）router.afterEach((to,from) =&gt; &#123; console.log('after'); &#125;) 4. 补充：独享钩子//对指定的route配置 beforeEnter: (to, from, next) =&gt; &#123; console.log('beforeEnter'); next(); &#125;, 5. 补充：组件补充12、keep-alive的使用：提供组件缓存&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; //有缓存activated()和deactivated()才能使用 1. 嵌套子组件引发问题 问题：嵌套的子组件由于缺省设定的问题，导致切换回来的时候，子组件永远是缺省的那个 思路：去掉缺省值，动态添加默认显示的子组件，同时记录路径，使切换回来的时候仍然是切换走的时候那个子组件 //index.js的Home的route去掉写死的缺省值 children: [ // &#123; // path: '', // redirect: 'news' // &#125;, &#123; path: 'news', //不需要加 '/' component: HomeNews &#125;, &#123; path: 'message', //不需要加 '/' component: HomeMessage &#125; ], //Home.vue，data()添加一个路径变量记录路径：path data() &#123; return &#123; message: '你好啊', path: '/home/news' &#125; &#125;, //Home.vue配合activated()活跃时动态创建，beforeRouteLeave()离开时记录path activated() &#123; console.log('activated'); this.$router.push(this.path).catch(err =&gt; &#123;&#125;); &#125;, deactivated()&#123; //这个方法来不及获取path路径，所以不能使用 &#125; beforeRouteLeave(to, from, next) &#123; this.path = this.$route.path; next(); &#125; 2. 排除个别不需要缓存&lt;keep-alive exclude=\"Profile,User\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 二、vue-router底部栏项目知识点1. 目录文件管理与逻辑分离 1、共同的vue放在components里 2、主要视图放在views里，然后详细页面再分包 3、App.vue如果太多代码，还可以继续抽离 4、大组件继续拆分小组件，用插槽 5、div(设置属性)包裹插槽，可以避免属性被覆盖 2. 获得活跃路径和动态修改样式//父传子&lt;tab-bar-item path=\"/profile\" activeColor=\"blue\"&gt; props: &#123; path: String, activeColor: &#123; type: String, default: 'deeppink' &#125; &#125;, computed: &#123; isActive() &#123; //获得活跃路径 return this.$route.path.indexOf(this.path) !== -1; &#125;, activeStyle() &#123; return this.isActive ? &#123;color: this.activeColor&#125; : &#123;&#125; &#125; &#125;, 3. 点击跳转&lt;div class=\"tab-bar-item\" @click=\"itemClick\"&gt; //父传子，path methods: &#123; itemClick() &#123; this.$router.push(this.path).catch(err =&gt; &#123;&#125;); &#125; &#125; 4. 文件路径起别名 1、webpack.base.conf.js修改 &gt; resolve: &#123; &gt; extensions: ['.js', '.vue', '.json'], &gt; alias: &#123; &gt; '@': resolve('src'), &gt; 'assets': resolve('src/assets'), &gt; 'components': resolve('src/components'), &gt; 'views': resolve('src/views'), &gt; &#125; &gt; &#125;, &gt; 2、使用 &gt; //如果是import from 的路径则直接使用别名 &gt; import TabBar from \"components/tabbar/TabBar\"; &gt; import TabBarItem from \"components/tabbar/TabBarItem\"; &gt; &gt; //src引用，则需要在别名前面加“~” &gt; &lt;img slot=\"item-icon\" src=\"~assets/img/tabbar/category.svg\" alt=\"\"&gt; &gt; 2020年08月4日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（四）：脚手架和箭头函数的使用","slug":"VUE学习（四）：脚手架和箭头函数的使用","date":"2020-07-28T10:06:34.000Z","updated":"2020-10-27T04:47:53.000Z","comments":true,"path":"2020/07/28/VUE学习（四）：脚手架和箭头函数的使用/","link":"","permalink":"http://yoursite.com/2020/07/28/VUE学习（四）：脚手架和箭头函数的使用/","excerpt":"","text":"一、脚手架2/3的使用1. 安装cil3：npm install @vue/cli -g 拉取2.x：npm install @vue/cli-init -g 2. 初始化cli2：vue init webpack xxxruntime-compiler和runtime-only的区别 runtime-compiler：template -&gt; ast -&gt; render -&gt; vdom -&gt; UI（） runtime-only：render -&gt; vdom -&gt; UI （性能高，代码量少） 1、vue文件的template不需要解析了 2、因为被vue-template-compiler解析成render函数了 3. 初始化cil3：vue create xxx 可视化界面 &gt; vue ui cil3把许多配置文件隐藏起来了，需要配置则在根目录下创建： vue.config.js（固定名字，红色） git commit -m “添加文件”（绿色） 二、箭头函数的使用1. 基本使用const sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; console.log(sum(1, 2)); 2. 只有一个参数，括号可以省略const power = num =&gt; &#123; return num * num; &#125; console.log(power(100)); 3. 内容只有一行代码const mul = (num1,num2) =&gt; num1 * num2; console.log(mul(20, 20)); 4. 没有参数，没有返回值const print = () =&gt; console.log('hello'); print() 5. 箭头函数的this的使用问题：箭头函数中的this是如何查找的？ 答案：向外层作用域查找，一层层查找this，知道有this的定义 const obj = &#123; aaa() &#123; setTimeout(function () &#123; setTimeout(function () &#123; console.log(this); //window，这种无参格式都是window &#125;); setTimeout(() =&gt; &#123; console.log(this); //上一层是function()，所以this也是window &#125;); &#125;); setTimeout(() =&gt; &#123; setTimeout(function () &#123; console.log(this); //window &#125;); setTimeout(() =&gt; &#123; console.log(this); //上一层没有，再上一层是aaa，所以this是aaa &#125;) &#125;) &#125; &#125;; 2020年08月4日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（三）：webpack详解","slug":"VUE学习（三）：webpack详解","date":"2020-07-27T15:08:37.000Z","updated":"2020-10-27T04:47:57.000Z","comments":true,"path":"2020/07/27/VUE学习（三）：webpack详解/","link":"","permalink":"http://yoursite.com/2020/07/27/VUE学习（三）：webpack详解/","excerpt":"","text":"一、传统的模块化1. 导入导出//commonJS 导出：module.exports = &#123;add&#125; 导入：const &#123;add&#125; = require('./mathUtils.js'); //es6 导出：export const name = '哈哈哈'; 导入：import &#123;name&#125; from './info'; 2. 打包 webpack ./src/main.js ./dist/bundle.js 二、webpack初体验1. 自定义打包命令：webpack（配置固定路径）//npm init 生成 package.json const path = require('path'); // 需要用到node依赖path module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname,'dist'), //绝对路径 filename: 'bundle.js' &#125; &#125; 2、映射路径为局部命令：npm run build1. 由于实际开发中大多数是用到局部webpack版本，则需要使用局部webpack 2. 使用局部命令 (1)修改package.json里的scripts，添加自定义命令 \"scripts\": &#123; \"build\": \"webpack\" &#125;, 3、配置开发环境 npm install webpack@3.6.0 –save-dev 安装开发环境的webpack，局部命令则优先去node_modules里面找webpack包 三、webpack的各种加载器 webpack官网：https://www.webpackjs.com/loaders 1. 依赖css main.js依赖：require(‘./css/normal.css’); npm install css-loader@2.0.2 –save-dev npm install style-loader –save-dev //同时需要样式加载器 修改webpack.config.js module: &#123; rules: [ &#123; test: /\\.css$/, // 使用多个loader，是从右向左读，先css在style use: ['style-loader','css-loader'] &#125; ] &#125; 2. 依赖less npm install –save-dev less-loader@4.1.0 less 2. &#123; test: /\\.less$/, use: [&#123; loader: \"style-loader\" // creates style nodes from JS strings &#125;, &#123; loader: \"css-loader\" // translates CSS into CommonJS &#125;, &#123; loader: \"less-loader\" // compiles Less to CSS &#125;] &#125; 3.1 依赖图片 npm install –save-dev url-loader@1.1.2 2. rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; //图片大小，小于limit时，会转化成base64形式并直接使用 limit: 8192 &#125; &#125; ] &#125; ] 3.2 依赖图片 -&gt; 依赖文件 如果大于limit，需要用到file-loader但不需要配置 npm install file-loader@3.0.1 –save-dev 问题一：自动生成的图片在dist文件夹里，而写的路径在img里解决：需要配置图片路径，自动拼接dist/才能显示 webpack.config.js： output: &#123; path: path.resolve(__dirname,'dist'), //绝对路径 filename: 'bundle.js', publicPath: 'dist/' &#125;, //后续需要把index.html放到dist中，就不要配置了 问题二：解决文件命名问题 options: &#123; limit: 8192, name: 'img/[name].[hash:8].[ext]' &#125; 4. ES6转ES5npm install –save-dev babel-loader@7 babel-core babel-preset-es2015 &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; 改： options: &#123; presets: ['es2015'] &#125; 四、依赖.vue npm install vue –save（不加-dev，是因为开发和发布都需要用） 配置 resolve: &#123; //起别名，指定路径 alias: &#123; 'vue$': 'vue/dist/vue.esm.js' //(runtime-compiler 而不使用 runtime-only（不能编译template）) &#125; &#125; resolve: &#123; //去后缀 extensions: ['.js','.css','.vue'], 五、index.js代码抽离1. 对象化&lt;div id=\"app\"&gt; &lt;/div&gt; 2. 写成对象 const App = &#123; template: ` &lt;div&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data() &#123; return &#123; message: 'Hello,Webpack', name: '哈哈哈' &#125; &#125;, methods: &#123; btnClick() &#123;&#125; &#125; &#125;; 3. new Vue(&#123; el: '#app', //编译后，会直接把div替换掉 template: '&lt;App/&gt;', //使用 components: &#123; //注册 App &#125; &#125;); 2. 文件化 新建vue/app.js,把App代码拿过去，用导入导出的方式使用 3. 演变成：使用app.vue 安装npm install –save-dev vue-loader vue-template-compiler 配置webpack.config.js &#123; test: /\\.vue$/, use: ['vue-loader'] &#125; // webpack.config.js const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = &#123; // ... plugins: [ new VueLoaderPlugin() ] &#125; 六、插件的使用1. 版权插件const webpack = require('webpack'); plugins: [ new VueLoaderPlugin(),new webpack.BannerPlugin('最终版权归Guzhz所有') ] 2. 打包生成index.html到dist中的插件安装：npm install html-webpack-plugin –save-dev const HtmlWebpackPlugin = require('html-webpack-plugin'); new HtmlWebpackPlugin(&#123; template: 'index.html' //不在需要手动引入script（删除） &#125;) 注意：删除配置的 publicPath: &#39;dist/&#39; 3. 丑化插件uglifyjs安装：npm install uglifyjs-webpack-plugin@1.1.1 –save-dev const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin'); new UglifyjsWebpackPlugin() 4. 搭建本地服务器（热部署）安装：webpack-dev-server@2.9.1 devServer: { contextBase: &apos;./dist&apos;, inline: true //实时监听 } 把上面注释掉，配置webpack.json命令&quot;dev&quot;: &quot;webpack-dev-server --open&quot; 启动：npm run dev 部署：npm run build 5. 合并插件：环境的分离安装：npm install webpack-merge@4.1.5 –save-dev prod: const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin'); const WebpackMerge = require('webpack-merge'); const baseConfig = require('./base.config'); module.exports = WebpackMerge(baseConfig, &#123; plugins: [ new UglifyjsWebpackPlugin() ] &#125;); dev: const WebpackMerge = require('webpack-merge'); const baseConfig = require('./base.config'); module.exports = WebpackMerge (baseConfig, &#123; devServer: &#123; contextBase: './dist', inline: true //实时监听 &#125; &#125;); 配置： package.json \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config ./build/prod.config.js\", \"dev\": \"webpack-dev-server --open --config ./build/dev.config.js\" &#125;, path: path.resolve(__dirname,'../dist'), //绝对路径 2020年08月4日 中午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（二）：组件化开发","slug":"VUE学习（二）：组件化开发","date":"2020-07-26T13:08:37.000Z","updated":"2020-10-27T04:47:53.000Z","comments":true,"path":"2020/07/26/VUE学习（二）：组件化开发/","link":"","permalink":"http://yoursite.com/2020/07/26/VUE学习（二）：组件化开发/","excerpt":"","text":"一、组件使用1.1、组件化的基本使用（Vue.extend）&lt;div id=\"app\"&gt; //使用 &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;/div&gt; &lt;hr&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //创建组件构造器对象 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我的内容&lt;/p&gt; &lt;p&gt;我的内容，嘻嘻嘻&lt;/p&gt; &lt;/div&gt;` &#125;); //注册为全局组件 Vue.component('my-cpn', cpnC) const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125; &#125;) &lt;/script&gt; 底层实现原理就是通过，Vue.extend实现的 1.2、全局组件和局部组件&lt;script&gt; //在外部则为全局组件，多个vue对象都可用 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;); //全局注册 // Vue.component('cpn',cpnC); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, //局部注册 components: &#123; cpn: cpnC &#125; &#125;); //多个Vue对象可以使用全局组件 const app2 = new Vue(&#123; el: '#app2' &#125;) &lt;/script&gt; 1.3、父组件和子组件&lt;script&gt; const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;子组件&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;/div&gt; ` &#125;); const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;父组件&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt; `, components: &#123; //C2注册C1 cpn1: cpnC1 &#125; &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, components: &#123; //root组件使用C2(同时使用了C1) cpn2: cpnC2, //root组件也使用C1，则也要注册 cpn1: cpnC1 &#125; &#125;) &lt;/script&gt; 1.4、组件的语法糖注册方式（Vue.component）//开发中也是用这种方式，但底层还是使用Vue.extend &lt;script&gt; //全局创建并注册，名字叫cpn1 Vue.component('cpn1',&#123; template: ` &lt;div&gt; &lt;h2&gt;语法糖写法&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;/div&gt; ` &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, //局部创建并注册，名字叫cpn2 components: &#123; 'cpn2': &#123; template: ` &lt;div&gt; &lt;h2&gt;局部组件语法糖写法&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;/div&gt; ` &#125; &#125; &#125;) &lt;/script&gt; 1.5、组件模板的分离写法（开发中使用）1、分离创建 &lt;script type=\"text/x-template\" id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;html分离写法&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; 2、template标签创建 &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;template标签分离写法&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //创建并注册为全局 Vue.component('cpn',&#123; template: '#cpn' &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125; &#125;) &lt;/script&gt; 1.6、组件中的数据存放问题//函数、返回值为对象（存放属性） &lt;script&gt; Vue.component('cpn',&#123; template: '#cpn', data() &#123; return &#123; title: '我是大标题ccc' &#125; &#125; &#125;); &lt;/script&gt; 1.7、组件中的data为什么是函数&lt;div id=\"app\"&gt; &lt;!--创建三个实例对象，互不影响--&gt; &lt;!--所以设计data为函数。就是为了互不干扰--&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;当前计数：&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('cpn',&#123; template: '#cpn', data() &#123; return &#123; //每次都new一个对象 counter: 0 &#125; &#125;, methods: &#123; increment() &#123; this.counter++; &#125;, decrement() &#123; this.counter--; &#125; &#125; &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125; &#125;) &lt;/script&gt; 二、组件通信2.1、父组件向子组件传递参数（props）//在引用cpn时传递参数并起名字，子组件用的props接收，然后就在template里使用 &lt;div id=\"app\"&gt; &lt;cpn :cmovies=\"movies\" :cmessage=\"message\"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;cmovies&#125;&#125;&lt;/p&gt; &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //父传子 props const cpn = &#123; template: '#cpn', // props: ['cmovies','cmessage'], //1 数组类型 props: &#123; // cmovies: Array, /*限定为数组*/ //2 限定类型 // cmessage: String cmovies: &#123; //3 限定类型同时设置默认值 type: Array, default() &#123; //高级版本必须以函数的形式返回 return [] &#125; &#125;, cmessage: &#123; type: String, default: 'aaaaaaaaaaa', required: true //必须传值 &#125; &#125; &#125; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊1', movies: ['aaa','bbb','ccc'] //定义数据 &#125;, components: &#123; cpn: cpn &#125; &#125;) &lt;/script&gt; 2.2、父传子（props中的驼峰标识）&lt;div id=\"app\"&gt; &lt;!--html不能识别驼峰，需要把cInfo - 改为c-info--&gt; &lt;cpn :c-info=\"info\" :child-my-message=\"message\"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;!--有多个参数需要显示，必须用东西包起来--&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;cInfo&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;childMyMessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; props: &#123; cInfo: &#123; type: Object, default() &#123; return &#123;&#125; &#125; &#125;, childMyMessage: &#123; type: String, default: '' &#125; &#125; 2.3、子传父（自定义事件$emit）&lt;div id=\"app\"&gt; &lt;!--不写参数默认传item过去--&gt; &lt;cpn @item-click=\"cpnClick\"&gt;&lt;/cpn&gt; //使用方法名绑定自己的方法 &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;!--有多个参数需要显示，必须用东西包起来--&gt; &lt;div&gt; &lt;!--通过自定义事件，把参数传下去--&gt; &lt;button v-for=\"item in categorys\" @click=\"btnClick(item)\"&gt; &#123;&#123;item.name&#125;&#125; &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const cpn = &#123; template: '#cpn', data() &#123; return &#123; categorys: [ &#123;id: 'aaa',name: '热门推荐'&#125;, &#123;id: 'bbb',name: '手机数码'&#125;, &#123;id: 'ccc',name: '家用家电'&#125;, &#123;id: 'ddd',name: '电脑办公'&#125; ] &#125; &#125;, methods: &#123; //在这里把具体参数传给父组件 btnClick(item) &#123; //(方法名，参数) this.$emit('item-click',item); &#125; &#125; &#125; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, components: &#123; cpn &#125;, methods: &#123; //取得具体参数 cpnClick(item)&#123; console.log(item.name); &#125; &#125; &#125;) &lt;/script&gt; 2.4、父子组件通信案例&lt;div id=\"app\"&gt; &lt;cpn :number1=\"num1\" :number2=\"num2\" @dnumber1tofather=\"num1change\" @dnumber2tofather=\"num2change\"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;父组件-传给props：&#123;&#123;number1&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" v-model=\"dnumber1\"&gt;--&gt; &lt;h2&gt;子组件-props赋值给data:&#123;&#123;dnumber1&#125;&#125;&lt;/h2&gt; &lt;input type=\"text\" :value=\"dnumber1\" @input=\"num1Input\"&gt; &lt;!--拆分,通过方法发送$emit()--&gt; &lt;hr&gt; &lt;h2&gt;父组件-传给props：&#123;&#123;number2&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" v-model=\"dnumber2\"&gt;--&gt; &lt;h2&gt;子组件-props赋值给data:&#123;&#123;dnumber2&#125;&#125;&lt;/h2&gt; &lt;input type=\"text\" :value=\"dnumber2\" @input=\"num2Input\"&gt; &lt;!--拆分,通过方法发送$emit()--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; num1: 1, num2: 0 &#125;, methods: &#123; num1change(value) &#123; this.num1 = parseFloat(value); &#125;, num2change(value) &#123; this.num2 = parseFloat(value); &#125; &#125;, components: &#123; cpn: &#123; template: '#cpn', //不能直接绑定到props里，会报错，需要绑定到data里 props: &#123; number1: Number, number2: Number &#125;, data() &#123; return &#123; dnumber1: this.number1, dnumber2: this.number2 &#125; &#125;, methods: &#123; num1Input(event) &#123; this.dnumber1 = event.target.value; this.$emit('dnumber1tofather',this.dnumber1); this.dnumber2 = this.dnumber1*100; //num1 * 100 -&gt; num2 ，控制num2 this.$emit('dnumber2tofather',this.dnumber2); &#125;, num2Input(event) &#123; this.dnumber2 = event.target.value; this.$emit('dnumber2tofather',this.dnumber2); this.dnumber1 = this.dnumber2/100; //num1 * 100 -&gt; num2 ，控制num2 this.$emit('dnumber1tofather',this.dnumber1); &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 需求： 1、父传子 2、子双向绑定 3、子同步父 4、通过子参数1修改子参数2，子参数参数1是子参数2的100倍，子参数2是子参数1的1/100，同时子同步父 总结： 1、父传子，子取得的参数不能直接绑定到子的props中，会报错，需要绑定到子的data中。 2、拆分v-model为v-bind和v-on，并通过@input=\"num1Input\"实时监听输入的数据，绑定方法，通过$emit修改父 3、父接受，修改父参数。 4、父参数修改时要注意类型不同的问题，需要把string转化为int 2.5、父子组件通信案例watch的使用//不拆分，直接双向绑定 &lt;input type=\"text\" v-model=\"dnumber1\"&gt; &lt;input type=\"text\" v-model=\"dnumber2\"&gt; //使用watch自己监听变量是否改变：有两个参数（newVaule，oldValue） watch: &#123; //配合v-model，实时绑定，监听变量是否发生改变 dnumber1(newValue) &#123; this.dnumber2 = this.dnumber1*100; //一旦改变，就可以监听到dnumber2 this.$emit('dnumber1tofather',newValue); //改变自身的props &#125;, dnumber2(newValue) &#123; this.dnumber1 = this.dnumber2/100; //num1 * 100 -&gt; num2 ，控制num2 this.$emit('dnumber2tofather',newValue); &#125; &#125; 2.6、父访问子（$children和$refs）//需求：多个子组件，点击按钮获得子组件的参数 &lt;div id=\"app\"&gt; &lt;cpn ref=\"aaa\"&gt;&lt;/cpn&gt; &lt;cpn ref=\"bbb\"&gt;&lt;/cpn&gt; &lt;cpn ref=\"ccc\"&gt;&lt;/cpn&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, methods: &#123; btnClick() &#123; //$children 不好，不常用，一旦多个子组件顺序发生变化，则可能获得的组件会错乱 // console.log(this.$children); // for (let c of this.$children) &#123; // console.log(c.name); // c.showMessage(); // &#125; //开发中用$ref，绑定ref属性作为key，可以不受索引的影响 =&gt; 默认是空对象 console.log(this.$refs.aaa.name); &#125; &#125;, components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; name: '我是子组件的name' &#125; &#125;, methods: &#123; showMessage() &#123; console.log('showMessage的内容被访问了'); &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 2.7 子访问父（$parent和$root）//代码大意：ccpn通过按钮访问cpn的参数，和vue(root)的参数 &lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; 我是cpn组件 &lt;ccpn&gt;&lt;/ccpn&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=\"ccpn\"&gt; &lt;div&gt; &lt;h2&gt;我是子子组件&lt;/h2&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, //cpn------------ components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; name: '我的cpn的name' &#125; &#125;, //ccpn--------------- components: &#123; ccpn: &#123; template: '#ccpn', methods: &#123; btnClick() &#123; //1、访问父组件 // console.log(this.$parent); // console.log(this.$parent.name); //2、直接访问根组件$root console.log(this.$root); console.log(this.$root.message); &#125; &#125; &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 三、插槽使用3.1、slot-插槽的基本使用&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;/cpn&gt; //直接替代 &lt;cpn&gt; //多个一起替代 &lt;i&gt;嘻嘻嘻&lt;/i&gt; &lt;div&gt;可以多个&lt;/div&gt; &lt;div&gt;一起替代&lt;/div&gt; &lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是组件&lt;/h2&gt; &lt;p&gt;我是组件、哈哈哈&lt;/p&gt; &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt; &lt;!--插槽并有默认值--&gt; &lt;hr&gt; &lt;/div&gt; &lt;/template&gt; 3.2、slot-具名插槽的使用//顾名思义，为了解决多个插槽，如何指定使用某个插槽，的问题 &lt;div id=\"app\"&gt; &lt;!--不指定名字则把没有名字的都替换掉--&gt; &lt;cpn&gt; //先插入，再指定名字 &lt;span slot=\"center\"&gt;标题&lt;/span&gt; &lt;!--指定使用中间那个--&gt; &lt;button slot=\"left\"&gt;返回&lt;/button&gt; &lt;!--指定使用左边那个--&gt; &lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;!--name：指定哪一个--&gt; &lt;div&gt; &lt;slot name=\"left\"&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt; &lt;slot name=\"center\"&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt; &lt;slot name=\"right\"&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt; &lt;hr&gt; &lt;/div&gt; &lt;/template&gt; 3.3、关于插槽，父子参数的编译作用域//总结：是谁，就用谁的参数，父不能直接使用子的参数，反之亦然 &lt;div id=\"app\"&gt; &lt;!--变量是在vue实例里找的，这些cpn当于普通标签--&gt; &lt;cpn v-show=\"isShow\"&gt;&lt;/cpn&gt; //可以显示 &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;div&gt;我是内容，哈哈哈&lt;/div&gt; &lt;!--这个变量就在组件里找，这里是false--&gt; &lt;button v-show=\"isShow\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; isShow: true &#125;, components: &#123; cpn: &#123; template: '#cpn' &#125;, data() &#123; return &#123; isShow: false &#125; &#125; &#125; &#125;) 3.4、编译作用域插槽的案例（解决参数传递）&lt;!--需求：获得子组件的data，另起格式排列，主要是获得data--&gt; &lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;!--通过slot传递参数，2.5.x以下必须使用template包裹--&gt; &lt;template slot-scope=\"slot\"&gt; &lt;span&gt;&#123;&#123;slot.data.join(' - ')&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;!--通过slot传递参数，2.5.x以下必须使用template包裹--&gt; &lt;template slot-scope=\"slot\"&gt; &lt;!--拿到插槽对象--&gt; &lt;span&gt;&#123;&#123;slot.data.join(' * ')&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;!--把数据传上去--&gt; &lt;slot :data=\"pLanguages\"&gt; &lt;!--起名字为data（随意）--&gt; &lt;ul&gt; &lt;li v-for=\"item in pLanguages\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; pLanguages: ['C','Javascript','C++','C#','Python'] &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 2020年07月26日 晚上Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"VUE学习（一）：基础语法","slug":"VUE学习（一）：基础语法","date":"2020-07-26T12:08:37.000Z","updated":"2020-10-27T04:50:58.000Z","comments":true,"path":"2020/07/26/VUE学习（一）：基础语法/","link":"","permalink":"http://yoursite.com/2020/07/26/VUE学习（一）：基础语法/","excerpt":"","text":"前言：本笔记为VUE基础语法的使用。B站视频链接 一、插值的操作1.1、Mustache语法&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;，嘻嘻嘻！&lt;/h2&gt; &lt;h2&gt;&#123;&#123;first + \" \" + end&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;counter * 3&#125;&#125;&lt;/h2&gt; &lt;/div&gt; 直接包裹变量、变量拼接、变量数学运算 1.2、v-once指令的使用&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--不可以被修改--&gt; &lt;/div&gt; 使用了v-once后，变量被修改，值不影响 1.3、v-html指令的使用&lt;h2 v-html=\"url\"&gt;&lt;/h2&gt; url: '&lt;a href=\"http://www.baidu.com\"&gt;百度一下&lt;/a&gt;' 1.4、v-text指令的使用&lt;h2 v-text=\"message\"&gt;&lt;/h2&gt; 不用Mustache语法包裹 1.5、v-pre指令的使用&lt;h2 v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--不解析 Previous--&gt; 原样输出内容：&#123;&#123;message&#125;&#125; -&gt; &#123;&#123;message&#125;&#125; 1.6、v-cloak指令的使用&lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;div id=\"app\" v-cloak&gt; &lt;!--消除闪烁问题，斗篷--&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; 二、动态绑定属性：v-bind2.1、v-bind（:）&lt;div id=\"app\"&gt; &lt;a v-bind:href=\"myhref\"&gt;bilibili&lt;/a&gt; &lt;!--语法糖：只写“:”--&gt; &lt;/div&gt; data: &#123; message: '你好啊', myhref: 'https://www.bilibili.com/' &#125; VUE托管属性、绑定属性 2.2、v-bind动态绑定class属性（对象语法）&lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"&#123;active: isActive, line: isLine&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button v-on:click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; data: &#123; message: '你好啊', isActive: true, isLine: true &#125;, methods: &#123; btnClick: function () &#123; this.isActive = !this.isActive; &#125;, getClasses: function () &#123; return &#123;active: this.isActive, line: this.isLine&#125; &#125; &#125; 效果：点击按钮，切换active 2.3、v-bind动态绑定class属性（数组语法）&lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"['active','line']\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //这里为字符串 &lt;h2 class=\"title\" :class=\"[active,line]\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //这里为数组变量 &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //通过方法获得数组变量 &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊', active: 'aaa', line: 'bbb' &#125;, methods: &#123; getClasses: function () &#123; return [this.active,this.line] &#125; &#125; &#125;) &lt;/script&gt; 2.4、v-bind动态绑定style属性（对象语法）&lt;div id=\"app\"&gt; &lt;h2 :style=\"&#123;fontSize: finalSize + 'px',background: finalColor&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 :style=\"getStyle()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 :style=\"&#123;'font-size': '50px'&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊', finalSize: 100, finalColor: 'red' &#125;, methods: &#123; getStyle: function () &#123; return &#123;fontSize: this.finalSize + 'px',background: this.finalColor&#125; &#125; &#125; &#125;) &lt;/script&gt; 2.5、v-bind动态绑定style属性（数组语法）&lt;div id=\"app\"&gt; &lt;h2 :style=\"[baseStyle]\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊', baseStyle: &#123;background: 'red'&#125; &#125; &#125;) &lt;/script&gt; 比较少用、这种用法相当于套娃 三、计算属性：computed（有缓存、效率高）3.1、计算属性的基本用法&lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; computed: &#123; //计算属性，注重“属性”，命名方式不用get set，直接用就可以了 fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125; 3.2、计算属性的复杂操作&lt;div id=\"app\"&gt; &lt;h2&gt;总价格：&#123;&#123;totalPrice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; books: [ &#123;id: 110,name: 'Unix编程艺术',price: 119&#125;, &#123;id: 111,name: '代码大全',price: 105&#125;, &#123;id: 112,name: '计算机原理',price: 98&#125;, &#123;id: 113,name: '现代操作系统',price: 97&#125;, ] &#125;, //有缓存，效率高 computed: &#123; totalPrice: function () &#123; let result = 0; for (let i = 0; i&lt;this.books.length; i++)&#123; result += this.books[i].price; &#125; return result; &#125; &#125; &#125;) &lt;/script&gt; 3.3、计算属性的setter和gettercomputed: &#123; //简写,默认是get fullName: function () &#123; console.log('fullName'); return this.firstName +' '+ this.lastName; &#125; &#125; // 原理写法，一般我们用不到set，所以省略 computed: &#123; fullName: function () &#123; set() &#123; console.log('只要值改变，就会默认调用') &#125; get() &#123; console.log('fullName'); return this.firstName +' '+ this.lastName; &#125; &#125; &#125; 四、事件监听：v-on4.1、v-on的基本使用：计数器&lt;div id=\"app\"&gt; &lt;h2&gt;计数器：&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; counter: 0 &#125;, methods: &#123; increment() &#123; this.counter++; &#125;, decrement() &#123; this.counter--; &#125; &#125; &#125;) &lt;/script&gt; 4.2、v-on的参数问题无参：两者一样 @click=\"btn1Click\" @click=\"btn1Click()\" 有参： 正常： @click=\"btn2Click(123)\" undefined： @click=\"btn2Click()\" 传进去了event：@click=\"btn2Click\" 指定获得event：@click=\"btn3Click(123,$event)\" 4.3、v-on的修饰符1：.stop的使用：阻止冒泡，点击div不冒泡button（div包裹button） &lt;div @click=\"divClick\"&gt; aa &lt;button @click.stop=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; 2：.prevent的使用：阻止提交 &lt;form action=\"http://www.baidu.com\"&gt; &lt;input type=\"submit\" value=\"提交\" @click.prevent=\"submitClick\"&gt; &lt;/form&gt; 3：@keyup键帽监听：弹起键帽执行事件 &lt;input type=\"text\" @keyup.enter=\"keyUp\"&gt; //指定为enter键 4：.once：只能点击一次 &lt;button @click.once=\"btn2Click\"&gt;按钮2&lt;/button&gt; 五、条件判断5.1、if else-if else&lt;h2 v-if=\"score&gt;=90\"&gt;优秀&lt;/h2&gt; &lt;h2 v-else-if=\"score&gt;=80\"&gt;良好&lt;/h2&gt; &lt;h2 v-else-if=\"score&gt;=60\"&gt;及格&lt;/h2&gt; &lt;h2 v-else&gt;不及格&lt;/h2&gt; 5.2、用户登录切换案例：问题（组件复用导致input值滞留）需求：不需要复用，则加入key属性，给每个input添加key后则不会被复用 &lt;div id=\"app\"&gt; &lt;span v-if=\"isUser\"&gt; &lt;label for=\"username\"&gt;用户账号&lt;/label&gt; &lt;input type=\"text\" id=\"username\" placeholder=\"账号\" key=\"username\"&gt; &lt;!--标识，不一样则不复用--&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=\"email\"&gt;用户邮箱&lt;/label&gt; &lt;input type=\"text\" id=\"email\" placeholder=\"邮箱\" key=\"email\"&gt; &lt;/span&gt; //思想：直接取反即可，不需要写方法 &lt;button @click=\"isUser = !isUser\"&gt;切换类型&lt;/button&gt; &lt;/div&gt; data: &#123; isUser: true &#125; 5.3、v-if和v-show的区别&lt;div id=\"app\"&gt; &lt;h2 id=\"aaa\" v-show=\"false\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--修改样式 display:none--&gt; &lt;h2 id=\"bbb\" v-if=\"false\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--移除dom 不解析--&gt; &lt;/div&gt; 六、循环遍历：v-for6.1、v-for遍历数组&lt;ul&gt; &lt;li v-for=\"(i,index) in names\"&gt;&#123;&#123;index+1&#125;&#125;.&#123;&#123;i&#125;&#125;&lt;/li&gt; //取得下标从1开始显示 &lt;/ul&gt; data: &#123; names: ['aa','bb','cc','dd'] &#125; 6.2、v-for遍历对象&lt;!-- value在左 ，一个item默认取value值--&gt; &lt;ul&gt; &lt;li v-for=\"(value,key) in info\"&gt;&#123;&#123;key&#125;&#125; = &#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 也取下标 --&gt; &lt;ul&gt; = &lt;li v-for=\"(value,key,index) in info\"&gt;&#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125; = &#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; data: &#123; info: &#123; name: 'aa', age: 18, height: 1.88 &#125; &#125; 6.3、哪些数组方法是响应式响应式： 1、追加push()：this.letters.push('aaa'); 2、删除最后一个pop()：this.letters.pop(); 3、删除第一个shift()：this.letters.shift(); 4、在前面追加unshift()：this.letters.unshift('aaa','bbb'); * 5、切片splice(位置、删除个数（空则删除后面所有）、插入)： - this.letters.splice(1,1); //删除第二个元素 - this.letters.splice(1,3,'cc','dd','ee') //替换三个 - this.letters.splice(1,0,\"aaa\",'ccc'); //二号位插入两个 6、排序：sort()：this.letters.sort(); 7、反转：reverse()：this.letters.reverse(); 非响应式： 直接通过下标修改值：this.letters[0] = 'aaa'; 解决：1、this.letters.splice(0,1,\"aaa\"); //替换 2、Vue.set(this.letters,0,'aaaaaa'); //对象、索引、修改值 七、书籍购物车案例知识点7.1、for循环的另一种用法（js)//of直接取值 for (let book of this.books) &#123; totalPrice += book.price * book.count; &#125; 7.2、VUE高级函数用法需求：过滤数组的为100以内然后乘2的累加值。 const nums = [10,20,30,50,100,200,300]; //分开写法 let newNums = nums.filter(function (n) &#123; return n&lt;100; //条件过滤 &#125;); let newNums2 = newNums.map(function (n) &#123; return n*2; //进一步操作 &#125;); //两个参数，第一个与上一个的返回值有关。默认从0为第一次遍历的上一个个值， let total = newNums2.reduce(function (previousValue,n) &#123; return previousValue + n; //递归遍历 &#125;,0); //合并写法： let total = nums.filter(n =&gt; n&lt;100).map(n =&gt; n*2).reduce((pre,n) =&gt; pre+n); 7.3、filters过滤器//使用 &lt;td&gt;&#123;&#123;item.price | showPrice&#125;&#125;&lt;/td&gt; //指定格式显示 filters: &#123; showPrice(price) &#123; return \"￥\" + price.toFixed(2); //保留两位小数 &#125; &#125; 八、双向绑定：v-model8.1、v-model的基本使用&lt;!--双向绑定：同步修改--&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; message: '你好啊' 8.2、v-model的原理//v-bind和v-on的结合体：原理就是修改了input内容的值，通过v-on绑定事件修改了值，然后用v-bind显示值 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"&gt; //内容监听的简写 8.3、v-model结合radio类型&lt;!--双向绑定同一个变量，默认就互斥，可以不需要name--&gt; &lt;input type=\"radio\" id=\"male\" value=\"男\" v-model=\"sex\"&gt;男 &lt;input type=\"radio\" id=\"female\" value=\"女\" v-model=\"sex\"&gt;女 &lt;h2&gt;性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; sex: '女' //默认 8.4、v-model结合checkbox类型//checkbox单选：同意协议场景，同意了则给点击 &lt;input type=\"checkbox\" id=\"agree\" v-model=\"isAgree\"&gt;同意协议 &lt;button :disabled=\"!isAgree\"&gt;下一步&lt;/button&gt; isAgree: false, //选中了则改为true //checkbox多选 &lt;input type=\"checkbox\" value=\"唱\" v-model=\"hobbies\"&gt;唱 &lt;input type=\"checkbox\" value=\"跳\" v-model=\"hobbies\"&gt;跳 &lt;input type=\"checkbox\" value=\"rap\" v-model=\"hobbies\"&gt;rap &lt;input type=\"checkbox\" value=\"篮球\" v-model=\"hobbies\"&gt;篮球 &lt;h2&gt;您的爱好是：&#123;&#123;hobbies&#125;&#125;&lt;/h2&gt; hobbies: [], //选中了则存到数组中 //值绑定：使用场景为，不写死，动态获取，给定初始值 &lt;label :for=\"item\" v-for=\"item in originHobbies\"&gt; &lt;input type=\"checkbox\" :value=\"item\" :id=\"item\" v-model=\"hobbies\"&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt; originHobbies: ['唱','跳','rap','篮球','足球','排球'] 8.5、v-model结合select类型 &lt;!--单选--&gt; &lt;select name=\"fruit\" v-model=\"fruit\"&gt; &lt;option value=\"苹果\"&gt;苹果&lt;/option&gt; &lt;option value=\"香蕉\"&gt;香蕉&lt;/option&gt; &lt;option value=\"榴莲\"&gt;榴莲&lt;/option&gt; &lt;option value=\"葡萄\"&gt;葡萄&lt;/option&gt; &lt;option value=\"西瓜\"&gt;西瓜&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;你选中的是：&#123;&#123;fruit&#125;&#125;&lt;/h2&gt; fruit: '香蕉', //默认选中香蕉 &lt;!--多选--&gt; &lt;select name=\"fruits\" id=\"\" v-model=\"fruits\" multiple&gt; //按住ctrl多选 &lt;option value=\"苹果\"&gt;苹果&lt;/option&gt; &lt;option value=\"香蕉\"&gt;香蕉&lt;/option&gt; &lt;option value=\"榴莲\"&gt;榴莲&lt;/option&gt; &lt;option value=\"葡萄\"&gt;葡萄&lt;/option&gt; &lt;option value=\"西瓜\"&gt;西瓜&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;你选中的是：&#123;&#123;fruits&#125;&#125;&lt;/h2&gt; fruits: [] //用数组存值 8.6、v-model修饰符的使用//1、修饰符.lazy：懒加载 &lt;input type=\"text\" v-model.lazy=\"message\"&gt; &lt;!--不实时，回车、或者失去焦点才同步--&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //2、修饰符.number：改变input默认获得string类型为number类型（免去转化） &lt;input type=\"number\" v-model.number=\"age\"&gt; &lt;h2&gt;&#123;&#123;typeof age&#125;&#125;类型：&#123;&#123;age&#125;&#125;&lt;/h2&gt; //3、修饰符.trim：去首尾空格 &lt;input type=\"text\" v-model.trim=\"name\"&gt; message: '你好啊', age: 0, name: '' 2020年07月26日 凌晨Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"在线订餐系统知识点总结","slug":"在线订餐系统知识点总结","date":"2020-07-12T14:08:37.000Z","updated":"2020-10-27T04:50:58.000Z","comments":true,"path":"2020/07/12/在线订餐系统知识点总结/","link":"","permalink":"http://yoursite.com/2020/07/12/在线订餐系统知识点总结/","excerpt":"","text":"项目背景：在线订餐系统是基于springboot和bootstrap的JavaEE项目，主要实现用户订餐，管理员接单等操作。 SpringBoot基本配置1、阿里巴巴druid配置&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; spring: datasource: username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_orderfood_end?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=true type: com.alibaba.druid.pool.DruidDataSource initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 2、整合swagger&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; Config配置类添加注解：@EnableSwagger2 使用 http://localhost:8080/swagger-ui.html#/ MybatisPlus以及代码生成器1、基本依赖&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2、配置文件mybatis-plus: # 日志log configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: # 配置逻辑删除 db-config: logic-delete-value: 1 logic-not-delete-value: 0 # 如果手写mapper映射文件，需要配置扫描路径 mapper-locations: classpath:/com/guzhz/mapper/xml/*.xml 3、代码生成器类 //代码生成器CodeGenerator public class CodeGenerator &#123; public static void main(String[] args) &#123; String tableName = \"order_detail\"; String deletedCol = \"md_deleted\"; String versionCol = \"md_version\"; AutoGenerator mpg = new AutoGenerator(); GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"Guzhz\"); gc.setFileOverride(false); gc.setOpen(false); gc.setSwagger2(true); gc.setBaseResultMap(true); gc.setBaseColumnList(true); gc.setServiceName(\"%sService\"); gc.setIdType(IdType.AUTO); gc.setDateType(DateType.ONLY_DATE); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/springboot_orderfood_end?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=true\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setParent(\"com.guzhz\"); pc.setEntity(\"entity\"); pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc); //4、策略配置（只需要改这里的表名即可） StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 自动lombok； strategy.setLogicDeleteFieldName(deletedCol); //逻辑删除字段 strategy.setInclude(new String[]&#123;tableName&#125;); //可以传入多个值 //5、自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); //6、乐观锁 strategy.setVersionFieldName(versionCol); //乐观锁字段名 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); mpg.execute(); &#125; &#125; 4、实体类关键成员的注解@TableLogic private Integer mdDeleted; @Version private Integer mdVersion; @JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") @DateTimeFormat(pattern=\"yyyy-MM-dd HH:mm:ss\") @TableField(value = \"od_createTime\",fill = FieldFill.INSERT) private Date odCreateTime; 5、配置分页、乐观锁的配置类@MapperScan(\"com.guzhz.mapper\") @ConditionalOnClass(value = &#123;PaginationInterceptor.class&#125;) @Configuration // 配置类 public class Config &#123; // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; /*配置分页插件*/ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; &#125; 6、自动更新时间配置类//自动更新时间 @Slf4j //日志注解 @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; //实体类成员 this.setFieldValByName(\"odCreateTime\",new Date(),metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; &#125; &#125; 7、时间个格式化json包//时间格式化 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; th:text=\"$&#123;#dates.format(order.getOdCreateTime(),'yyyy-MM-dd HH:mm:ss')&#125;\" SpringSecurity51、基本依赖&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置类@EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Resource TbUserServiceImpl tbUserService; @Override //授权规则 protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().antMatchers(\"/\",\"/index\",\"/main\",\"/search\").permitAll() .antMatchers(\"/userInfo\",\"/insertUserInfo\",\"/edUserInfo\",\"/deleteUser/**\").hasAnyRole(\"admin\") .antMatchers(\"/menuManage\",\"/deleteOneMenu/**\",\"/upLoadImg\",\"/insertMenu\",\"/updateMenu\").hasAnyRole(\"admin\") .antMatchers(\"/insertType\",\"/updateType\",\"/deleteType\").hasAnyRole(\"admin\") .antMatchers(\"/orderManage\",\"/changeStatusToOne\").hasAnyRole(\"admin\") .antMatchers(\"/myInfo\",\"/updateMyImg\",\"/updateMyInfo\").hasAnyRole(\"admin\",\"user\") .antMatchers(\"/shoppingCart\",\"/shoppingCart-plus\",\"/shoppingCart-minus\",\"/addShoppingCart\").hasAnyRole(\"user\") .antMatchers(\"/toOrder\",\"/myOrder\",\"/changeStatusToTwo\").hasAnyRole(\"user\"); http.formLogin().loginPage(\"/toLogin\").usernameParameter(\"uUsername\").passwordParameter(\"uPassword\") .loginProcessingUrl(\"/login\") //表单提交的请求，可以不需要路由（走security的路由） .failureUrl(\"/toLogin?error=true\"); http.csrf().disable(); //取消ajax拦截（post），如果改为post/get则可能不会报错 http.logout().logoutSuccessUrl(\"/toLogin\"); //解决中文乱码问题 CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\"UTF-8\"); filter.setForceEncoding(true); http.addFilterBefore(filter, CsrfFilter.class); /* //开启记住我功能 http.rememberMe().rememberMeParameter(\"remember\");*/ &#125; @Override //验证规则 protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(tbUserService).passwordEncoder(new NoPasswordEncoder()); &#125; &#125; 3、取消加密类public class NoPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; //不做任何加密处理 return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; //charSequence是前端传过来的密码，s是数据库中查到的密码 if (charSequence.toString().equals(s)) &#123; return true; &#125; return false; &#125; &#125; 4、TbUserServiceImpl实现类对接数据库（implements TbUserService）@Service public class TbUserServiceImpl extends ServiceImpl&lt;TbUserMapper, TbUser&gt; implements TbUserService , UserDetailsService&#123; //security验证用户名 @Override public UserDetails loadUserByUsername(String uUsername) throws UsernameNotFoundException &#123; //我们自己定义的 TbUserServiceImpl 需要实现 UserDetailsService 接口，实现该接口，就要实现接口中的方法， // 也就是 loadUserByUsername ，这个方法的参数就是用户在登录的时候传入的用户名， // 根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对） //根据前端传过来的uUsername找到对应的user TbUser user = tbUserMapper.selectOne(new QueryWrapper&lt;TbUser&gt;().eq(\"u_username\", uUsername)); if (user==null)&#123; throw new UsernameNotFoundException(\"用户不存在!\"); &#125; return user; &#125; &#125; 5、在后台获取当前用户的session信息public class UpdateSession &#123; //刷新权限 public static void reloadUserAuthority(HttpSession session , TbUser user)&#123; //1.从HttpServletRequest中获取SecurityContextImpl对象 SecurityContextImpl securityContextImpl = (SecurityContextImpl) session.getAttribute(\"SPRING_SECURITY_CONTEXT\"); //2.从SecurityContextImpl中获取Authentication对象 Authentication authentication = securityContextImpl.getAuthentication(); //3.初始化UsernamePasswordAuthenticationToken实例 ，这里的参数user就是我们要更新的用户信息 UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(user, authentication.getCredentials()); auth.setDetails(authentication.getDetails()); //4.重新设置SecurityContextImpl对象的Authentication securityContextImpl.setAuthentication(auth); &#125; //获得当前session对象，用于判断是否跨用户访问,返回当前所登录的用户的id； public static Integer getSessionUId(HttpSession session)&#123; SecurityContextImpl securityContextImpl = (SecurityContextImpl) session.getAttribute(\"SPRING_SECURITY_CONTEXT\"); Authentication authentication = securityContextImpl.getAuthentication(); TbUser user = (TbUser) authentication.getPrincipal(); return user.getUId(); &#125; &#125; 6、前端获取权限//导入命名空间 xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\" //获得权限 sec:authorize=\"hasRole('admin')\" //获得内存中的值 $&#123;#authentication.getPrincipal().uId&#125;&#125; 多表联合查询//自定义接口 @Mapper public interface MenuDetailMapper extends BaseMapper&lt;MenuDetail&gt; &#123; List&lt;MenuDetail&gt; selectByType(int mtId); &#125; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.guzhz.mapper.MenuDetailMapper\"&gt; &lt;!-- 通用查询映射结果 --&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.guzhz.entity.MenuDetail\"&gt; &lt;id column=\"md_id\" property=\"mdId\" /&gt; &lt;result column=\"md_name\" property=\"mdName\" /&gt; &lt;result column=\"md_price\" property=\"mdPrice\" /&gt; &lt;result column=\"md_amount\" property=\"mdAmount\" /&gt; &lt;result column=\"md_url\" property=\"mdUrl\" /&gt; &lt;result column=\"md_new\" property=\"mdNew\" /&gt; &lt;result column=\"md_star\" property=\"mdStar\" /&gt; &lt;result column=\"md_deleted\" property=\"mdDeleted\" /&gt; &lt;result column=\"md_version\" property=\"mdVersion\" /&gt; &lt;result column=\"mt_id\" property=\"mtId\"/&gt; &lt;association property=\"menuType\" javaType=\"com.guzhz.entity.MenuType\"&gt; &lt;id column=\"mt_id\" property=\"mtId\"/&gt; &lt;result column=\"mt_name\" property=\"mtName\"/&gt; &lt;result column=\"mt_deleted\" property=\"mtDeleted\"/&gt; &lt;result column=\"mt_version\" property=\"mtVersion\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 通用查询结果列 --&gt; &lt;sql id=\"Base_Column_List\"&gt; md_id, md_name, md_price, md_amount, md_url, md_new, md_star, md_deleted, md_version &lt;/sql&gt; &lt;select id=\"selectByType\" parameterType=\"int\" resultMap=\"BaseResultMap\"&gt; select md_id, md_name, md_price, md_amount, md_url, md_new, md_star, md_deleted, md_version, b.mt_id, mt_name, mt_deleted, mt_version from menu_detail a, menu_type b where a.mt_id = b.mt_id and b.mt_id = #&#123;mtId&#125; &lt;/select&gt; &lt;/mapper&gt; 文件上传1、配置类@Configuration public class MyWebAppConfigurer implements WebMvcConfigurer &#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:F:/Study/Book6/JavaEE/images/\"); &#125; &#125; 2、实现类@Repository public class FileUpload &#123; public static String uploadFile(MultipartFile upLoadFile)&#123; if (upLoadFile.isEmpty()) &#123; System.out.println(\"文件为空空\"); return null; &#125; String filePath = \"F:\\\\Study\\\\Book6\\\\JavaEE\\\\images\"; //获取原始文件名 String fileName = upLoadFile.getOriginalFilename(); /*新的文件名*/ fileName = UUID.randomUUID().toString().replace(\"-\", \"\") + fileName.substring(fileName.lastIndexOf(\".\")); File file = new File(filePath,fileName); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); System.out.println(\"创建成功！\"); &#125; try &#123; upLoadFile.transferTo(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String imgPath = \"/images/\"+fileName; return imgPath; &#125; &#125; 3、工具类public class RandomNo &#123; public static String getRandomNo()&#123; SimpleDateFormat sdf=new SimpleDateFormat(\"yyyyMMddHHmmss\"); String newDate=sdf.format(new Date()); String result=\"\"; Random random=new Random(); for(int i=0;i&lt;3;i++)&#123; result+=random.nextInt(10); &#125; return newDate+result; &#125; &#125; 前端知识总结1、bootStrap、JQuery三件套&lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\"&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; //semantic-ui &lt;link href=\"https://cdn.bootcss.com/semantic-ui/2.4.1/semantic.min.css\" rel=\"stylesheet\"&gt; //图标库 &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.9/css/all.css\"&gt; 2、思想：获得循环出来的值，通过Ajax请求把必要元素放进a标签里，设置为input hidden，绑定点击事件 &lt;a onclick=\"getDetail(this)\" id=\"getDetail\" href=\"#successTips\" data-toggle=\"modal\" class=\"add-to-cart\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdName()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdAmount()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdPrice()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdUrl()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdId()&#125;\"&gt; &lt;input type=\"hidden\" sec:authorize=\"isAuthenticated()\" th:value=\"$&#123;#authentication.getPrincipal().uId&#125; \"&gt; &lt;!--登录后获得用户id--&gt; &lt;input type=\"hidden\" sec:authorize=\"isAuthenticated()\" th:value=\"$&#123;#authentication.getPrincipal().uRole&#125; \"&gt; &lt;!--登录后判断账号权限--&gt; &lt;/a&gt; &lt;script&gt; function getDetail(a) &#123; let list = $(a).children('input'); //获得当前元素下的所有子input if (list.length == 5)&#123; //5个说明处于未登录状态 alert(\"请先登录，再订餐哦~\"); $(a).attr(\"href\",\"#\"); return ; &#125; if($(list[6]).val() == \"ROLE_admin\")&#123; alert(\"你就是老板啦，你不能下单哦~\"); $(a).attr(\"href\",\"#\"); return ; &#125;if($(list[1]).val() == \"0\")&#123; alert(\"加入购物车失败！该菜品已售罄，等待补货！\"); $(a).attr(\"href\",\"#\"); return ; &#125; else&#123; let mdName = $(list[0]).val(); let mdPrice = $(list[2]).val(); $('#tips-name').html(\"【名称】\"+mdName); $('#tips-price').html(\"【价格】\"+mdPrice+'元'); /*发起请求*/ let postData = &#123;&#125;; postData['scName'] = mdName; postData['scAmount'] = 1; postData['scPrice'] = mdPrice; postData['scImg'] = $(list[3]).val(); postData['mdId'] = $(list[4]).val(); postData['uId'] = $(list[5]).val(); $.ajax(&#123; url: \"/addShoppingCart\", type: 'POST', data: postData, success: function (arg) &#123; if(arg == \"0\")&#123; $('#myModalLabel').text(\"当前菜品加购已达到上限！\") &#125;else if(arg == \"1\")&#123; $('#myModalLabel').text(\"加入成功！\") &#125;else&#123; $('#myModalLabel').text(\"数量加+1成功！\") &#125; // window.location.reload(); &#125; &#125;) &#125; &#125; &lt;/script&gt; 3、技巧：修改头像&lt;!--更新头像模态框--&gt; //修改点：模态框的id，img的id，模块脚的button &lt;div class=\"modal fade\" id=\"headImgModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\" style=\"margin: 0 auto;width: 450px\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\"&gt;&amp;times;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;修改头像&lt;/h4&gt; &lt;/div&gt; &lt;form action=\"\"&gt; &lt;div class=\"modal-body text-center\"&gt; &lt;span&gt; &lt;!--预览图片位置，默认图片--&gt; &lt;img id=\"headImg\" style=\"width: 250px;height: 250px\" th:src=\"@&#123;$&#123;#authentication.getPrincipal().uUrl&#125;&#125;\" class=\"img-rounded\"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;!--点击选择文件 触发隐藏form，通过id--&gt; &lt;button type=\"button\" class=\"btn btn-default\" onclick=\"$('#updateHeadImg').click();\"&gt;浏览&lt;/button&gt; &lt;!--点击提交表单--&gt; &lt;button type=\"button\" class=\"btn btn-primary\" id=\"submitBtn\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 隐藏form --&gt; //修改点：form的id，form的action，input的id &lt;form id=\"updateHeadImgForm\" th:action=\"@&#123;'/updateMyImg?uId='+$&#123;#authentication.getPrincipal().uId&#125;&#125;\" method=\"post\" enctype=\"multipart/form-data\" class=\"form\"&gt; &lt;input type=\"file\" id=\"updateHeadImg\" name=\"updateHeadImg\" style=\"display: none\"&gt; &lt;/form&gt; &lt;!-- 触发模态框按钮 --&gt; &lt;button onclick=\"tips()\" th:name=\"$&#123;#authentication.getPrincipal().uId&#125;\" style=\"margin-right: 75px; float: right\" class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#headImgModal\"&gt; &lt;span class=\"glyphicon glyphicon-picture\"&gt;&lt;/span&gt;修改头像 &lt;/button&gt; &lt;script&gt; $(\"#updateHeadImg\").change(function () &#123; //点击“浏览”后会触发隐藏文件表单。监听一旦发生改变则 var file = this.files[0]; // 获取input上传的图片数据; console.log(file); var url = window.URL.createObjectURL(file); // 得到file对象路径，可当成普通的文件路径一样使用，赋值给src; $(\"#headImg\").attr(\"src\", url); //修改模态框的头像 &#125;); // JQ点击提交表单 $(\"#submitBtn\").on(\"click\", function () &#123; var file = $(\"#updateHeadImg\").val(); // 获取input上传的图片数据; if(file!='')&#123; alert(\"修改头像成功，正在前往登录页~\"); $('#updateHeadImgForm').submit(); &#125;else&#123; alert('请先浏览图片！') &#125; &#125;); &lt;/script&gt; 4、简单的模态框的使用//关键点：id，下单按钮的事件绑定 &lt;!--填充收货信息模态框--&gt; &lt;div class=\"modal fade\" id=\"fillInfoModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\"&gt; &lt;div class=\"modal-dialog\" role=\"document\"&gt; &lt;div class=\"modal-content\" style=\"margin: 0 auto;width: 450px\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=\"modal-title\" id=\"addTypeModalLabel\"&gt;请编辑收货信息（可前往个人中心修改）：&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;!--模块体填充数据--&gt; &lt;form action=\"\"&gt; &lt;input type=\"hidden\" id=\"fill-uId\" th:value=\"$&#123;#authentication.getPrincipal().uId&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-name\" class=\"control-label\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-name\" th:value=\"$&#123;#authentication.getPrincipal().uName&#125;\" name=\"odName\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-phone\" class=\"control-label\"&gt;手机号：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-phone\" th:value=\"$&#123;#authentication.getPrincipal().uPhone&#125;\" name=\"odPhone\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-address\" class=\"control-label\"&gt;地址：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-address\" th:value=\"$&#123;#authentication.getPrincipal().uAddress&#125;\" name=\"odAddress\" class=\"form-control\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-remarks\" class=\"control-label\"&gt;备注：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-remarks\" name=\"odRemarks\" class=\"form-control\" placeholder=\"有啥要求可以备注说明哦~\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;关闭&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\" onclick=\"toOrder()\"&gt;确认下单&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; function toOrder() &#123; let postData = &#123;&#125;; let uId = $('#fill-uId').val(); let odName = $('#fill-name').val(); let odPhone = $('#fill-phone').val(); let odAddress = $('#fill-address').val(); let odRemarks = $('#fill-remarks').val(); if (odName === \"\") &#123; alert(\"姓名不能为空！\"); return; &#125; if (odPhone === \"\") &#123; alert(\"手机号不能为空\"); return; &#125; if (odAddress === \"\") &#123; alert(\"地址不能为空\"); return; &#125; postData['odName'] = odName; postData['odPhone'] = odPhone; postData['odAddress'] = odAddress; postData['odRemarks'] = odRemarks; postData['uId'] = uId; console.log(postData); $.ajax(&#123; url: \"/toOrder\", type: 'POST', data: postData, success: function (arg) &#123; alert(arg); window.location.reload(); &#125; &#125;); &#125; &lt;/script&gt; 5、表格获取单元数据、简单的删除提示&lt;button class=\"btn btn-warning\" id=\"edit_table_btn\" data-toggle=\"modal\" data-target=\"#edUser\" onclick=\"getData()\"&gt; &lt;span class=\"glyphicon glyphicon-pencil\"&gt;&lt;/span&gt;编辑 &lt;/button&gt; &lt;script&gt; /*被绑定的按钮，先执行onclick，获得表格当前行的值并设置为模态框的值*/ function getData() &#123; $(\"#userInfoTable tbody\").on(\"click\", \"tr\", function () &#123; let data = new Array(); let td = $(this).find(\"td\"); for (let i = 0; i &lt; td.length; i++) &#123; data.push(td.eq(i).text()); &#125; $('#ed-uId').attr('value',data[0]); console.log(data[0]); $('#ed-uUsername').attr('value',data[2]); $('#ed-uPassword').attr('value',data[3]); $('#ed-uName').attr('value',data[4]); $('#ed-uPhone').attr('value',data[5]); $('#ed-uAddress').attr('value',data[6]); &#125;); &lt;/script&gt; &lt;a th:href=\"@&#123;'/deleteUser/'+$&#123;user.getUId()&#125;&#125;\" onClick=\"return confirm('确定删除?');\"&gt; &lt;button class=\"btn btn-danger\"&gt;&lt;span class=\"glyphicon glyphicon-remove\"&gt;&lt;/span&gt; 删除&lt;/button&gt; &lt;/a&gt; 6、翻页&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\" style=\"text-align: center;\"&gt; &lt;div style=\"font-size: 16px;color:grey;\"&gt; 总查询到&amp;nbsp;&lt;span th:text=\"$&#123;page.getTotal()&#125;\"&gt;&lt;/span&gt;&amp;nbsp;条数据 &lt;/div&gt; &lt;!--遍历页数--&gt; &lt;!--th:each=\"i:$&#123;#numbers.sequence(1,page.getPages())&#125;\"--&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a th:if=\"$&#123;!page.hasPrevious()&#125;\" href=\"javascript:alert('已经是第一页啦！');\"&gt;上一页&lt;/a&gt; &lt;a th:if=\"$&#123;page.hasPrevious()&#125;\" th:href=\"@&#123;'/userInfo?pageNum='+ $&#123;page.getCurrent() - 1&#125;&#125;\"&gt;上一页&lt;/a&gt; &lt;/li&gt; &lt;li th:each=\"i:$&#123;#numbers.sequence(1,page.getPages())&#125;\"&gt; &lt;a th:if=\"$&#123;page.getCurrent() == i&#125;\" th:href=\"@&#123;'/uuserInfo?pageNum='+ $&#123;i&#125;&#125;\" th:text=\"$&#123;i&#125;\" style=\"background: #aefff8\"&gt;&lt;/a&gt; &lt;a th:if=\"$&#123;!(page.getCurrent() == i)&#125;\" th:href=\"@&#123;'/userInfo?pageNum='+ $&#123;i&#125;&#125;\" th:text=\"$&#123;i&#125;\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a th:if=\"$&#123;!page.hasNext()&#125;\" href=\"javascript:alert('已经是最后一页啦！');\"&gt;下一页&lt;/a&gt; &lt;a th:if=\"$&#123;page.hasNext()&#125;\" th:href=\"@&#123;'/userInfo?pageNum='+ $&#123;page.getCurrent() + 1&#125;&#125;\"&gt;下一页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2020年07月12日 晚上Guzhz","categories":[{"name":"项目记录","slug":"项目记录","permalink":"http://yoursite.com/categories/项目记录/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://yoursite.com/tags/bootstrap/"}]},{"title":"MyBatisPlus学习笔记","slug":"MyBatisPlus学习笔记","date":"2020-07-12T04:44:37.000Z","updated":"2020-10-27T04:49:28.000Z","comments":true,"path":"2020/07/12/MyBatisPlus学习笔记/","link":"","permalink":"http://yoursite.com/2020/07/12/MyBatisPlus学习笔记/","excerpt":"","text":"前言：MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！ 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作， BaseMapper 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求, 以后简单的CRUD操作，它不用自己编写了！ 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码） 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速入门1、创建数据库2、创建表(id自增)DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); -- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 3、编写项目，初始化项目，使用SpringBoot初始化4、导入依赖&lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 5、连接数据库spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 6、编写基本pojo类@Data @AllArgsConstructor @NoArgsConstructor public class User &#123; private Long id; private String name; private Integer age; private String email; &#125; 7、mapper接口@Repository // 代表持久层 public interface UserMapper extends BaseMapper&lt;User&gt; &#123; // 所有的CRUD操作都已经编写完成了 // 你不需要像以前的配置一大堆文件了！ &#125; 注意点：我们需要在主启动类上去扫描我们的mapper包下的所有接口@MapperScan(&quot;com.kuang.mapper&quot;) 测试类： @SpringBootTest class MybatisPlusApplicationTests &#123; // 继承了BaseMapper，所有的方法都来自己父类 // 我们也可以编写自己的扩展方法！ @Autowired private UserMapper userMapper; @Test void contextLoads() &#123; // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; &#125; 配置日志我们所有的sql现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl CRUD拓展1、插入操作// 测试插入 @Test public void testInsert()&#123; User user = new User(); user.setName(\"狂神说Java\"); user.setAge(3); user.setEmail(\"24736743@qq.com\"); int result = userMapper.insert(user); // 帮我们自动生成id System.out.println(result); // 受影响的行数 System.out.println(user); // 发现，id会自动回填 &#125; ？出现的问题：默认id为全局唯一id：ID_WORKER，是根据雪花算法生成的。 2、主键生成策略雪花算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！配置id自增方法：1、实体类字段上 @TableId(type = IdType.AUTO)2、数据库自增IdType解释： public enum IdType &#123; AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 &#125; 3、更新操作// 测试更新 @Test public void testUpdate()&#123; User user = new User(); // 通过条件自动拼接动态sql user.setId(6L); user.setName(\"关注公众号：狂神说\"); user.setAge(18); // 注意：updateById 但是参数是一个 对象！ int i = userMapper.updateById(user); System.out.println(i); &#125; 4、自动填充机制：创建时间、更新时间创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化！ 方式一：修改数据库设置（工作中不允许你直接修改数据库） 1、在表中新增字段 create_time, update_time（提供更新）2、再次测试插入方法，我们需要先把实体类同步！private Date createTime; private Date updateTime; 方式二：代码操作 1、只添加字段2、实体类字段属性上需要增加注解// 字段添加填充内容 @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; 3、处理器类处理注解package com.kuang.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j //日志注解 @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler &#123; // 插入时的填充策略 @Override public void insertFill(MetaObject metaObject) &#123; log.info(\"start insert fill.....\"); // setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject this.setFieldValByName(\"createTime\",new Date(),metaObject); this.setFieldValByName(\"updateTime\",new Date(),metaObject); &#125; // 更新时的填充策略 @Override public void updateFill(MetaObject metaObject) &#123; log.info(\"start update fill.....\"); this.setFieldValByName(\"updateTime\",new Date(),metaObject); &#125; &#125; 4、测试插入、更新操作 5、乐观锁 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 实现原理：添加version字段 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 乐观锁：1、先查询，获得版本号 version = 1 -- A update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 -- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！ update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 1、数据库添加version字段，int，默认值为12、实体类添加对应的字段@Version //乐观锁Version注解 private Integer version; 3、注册插件：编写配置类，把扫描声明放来这里，添加事务管理注解// 扫描我们的 mapper 文件夹 @MapperScan(\"com.kuang.mapper\") @EnableTransactionManagement @Configuration // 配置类 public class MyBatisPlusConfig &#123; // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; &#125; 4、测试// 测试乐观锁成功！ @Test public void testOptimisticLocker()&#123; // 1、查询用户信息 User user = userMapper.selectById(1L); // 2、修改用户信息 user.setName(\"kuangshen\"); user.setEmail(\"24736743@qq.com\"); // 3、执行更新操作 userMapper.updateById(user); &#125; // 测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2()&#123; // 线程 1 User user = userMapper.selectById(1L); user.setName(\"kuangshen111\"); user.setEmail(\"24736743@qq.com\"); // 模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(\"kuangshen222\"); user2.setEmail(\"24736743@qq.com\"); userMapper.updateById(user2); // 自旋锁来多次尝试提交！ userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！ &#125; 6、查询操作// 测试查询 @Test public void testSelectById()&#123; User user = userMapper.selectById(1L); System.out.println(user); &#125; // 测试批量查询！ @Test public void testSelectByBatchId()&#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println); &#125; // 按条件查询之一使用map操作 @Test public void testSelectByBatchIds()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 自定义要查询 map.put(\"name\",\"狂神说Java\"); map.put(\"age\",3); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println); &#125; 7、分页查询（内置）1、配置组件// 分页插件 @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; 2、直接使用Page对象// 测试分页查询 @Test public void testPage()&#123; // 参数一：当前页 // 参数二：页面大小 // 使用了分页插件之后，所有的分页操作也变得简单的！ Page&lt;User&gt; page = new Page&lt;&gt;(2,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal()); &#125; 8、删除操作1、根据id删除记录// 测试删除 @Test public void testDeleteById()&#123; userMapper.deleteById(1240620674645544965L); &#125; // 通过id批量删除 @Test public void testDeleteBatchId()&#123; userMapper.deleteBatchIds(Arrays.asList(1L,2L)); &#125; // 通过map删除 @Test public void testDeleteMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\",\"狂神说Java\"); userMapper.deleteByMap(map); &#125; 9、逻辑删除 物理删除 ：从数据库中直接移除逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！（原理：更新deleted字段，但同时查询也是将无结果）1、在数据表中增加一个 deleted 字段（int 默认0）2、实体类中增加属性@TableLogic //逻辑删除 private Integer deleted; 3、配置组件// 逻辑删除组件！ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; # 配置逻辑删除 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 10、性能分析插件我们在平时的开发中，会遇到一些慢sql。测试！ druid……作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间，MyBatisPlus也提供性能分析插件，如果超过这个时间就停止运行！1、导入插件/** * SQL执行效率插件 */ @Bean @Profile(&#123;\"dev\",\"test\"&#125;)// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() &#123; PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; &#125; 记住，要在SpringBoot中配置环境为dev或者 test 环境！2、测试使用@Test void contextLoads() &#123; // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; 11、条件构造器十分重要：Wrapper我们写一些复杂的sql就可以使用它来替代！1、限定非空条件@Test void contextLoads() &#123; // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper .isNotNull(\"name\") .isNotNull(\"email\") .ge(\"age\",12); userMapper.selectList(wrapper).forEach(System.out::println); // 和我们刚才学习的map对比一下 &#125; 2、限定字段等于某个值@Test void test2()&#123; // 查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(\"name\",\"狂神说\"); User user = userMapper.selectOne(wrapper); // 查询一个数据，出现多个结果使用List或者 Map System.out.println(user); &#125; 3、限定字段值为某个区间@Test void test3()&#123; // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(\"age\",20,30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); &#125; 4、模糊查询// 模糊查询 @Test void test4()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 左和右 t% wrapper .notLike(\"name\",\"e\") .likeRight(\"email\",\"t\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println); &#125; 5、id条件从子查询中得来@Test void test5()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // id 在子查询中查出来 wrapper.inSql(\"id\",\"select id from user where id&lt;3\"); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); &#125; 6、根据id进行排序@Test void test6()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 通过id进行升序排序 wrapper.orderByAsc(\"id\"); List&lt;User&gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); &#125; 12、代码自动生成器dao、pojo、service、controller都给我自己去编写完成！AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 代码：package com.kuang; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.po.TableFill; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import java.util.ArrayList; // 代码自动生成器 public class KuangCode &#123; public static void main(String[] args) &#123; // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath+\"/src/main/java\"); gc.setAuthor(\"狂神说\"); gc.setOpen(false); gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(\"%sService\"); // 去Service的I前缀 gc.setIdType(IdType.ID_WORKER); gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/kuang_community? useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\"); pc.setParent(\"com.kuang\"); pc.setEntity(\"entity\"); pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc); //4、策略配置（只需要改这里的表名即可） StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"blog_tags\",\"course\",\"links\",\"sys_settings\",\"user_record\",\"user_say\"); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 自动lombok； strategy.setLogicDeleteFieldName(\"deleted\"); //5、自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); //6、乐观锁 strategy.setVersionFieldName(\"version\"); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); // localhost:8080/hello_id_2 mpg.setStrategy(strategy); mpg.execute(); //执行 &#125; &#125; 2020年06月13日 晚上Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"mybatis-plus","slug":"mybatis-plus","permalink":"http://yoursite.com/tags/mybatis-plus/"}]},{"title":"JavaScript的简单回顾","slug":"JavaScript的简单回顾","date":"2020-06-09T05:39:35.000Z","updated":"2020-06-09T08:38:25.000Z","comments":true,"path":"2020/06/09/JavaScript的简单回顾/","link":"","permalink":"http://yoursite.com/2020/06/09/JavaScript的简单回顾/","excerpt":"","text":"前言：教学视频、笔记参考 一、快速入门1.1、两种引入方式内部标签&lt;script&gt; //.... &lt;script&gt; 外部引入&lt;script src=\"js/myjs.js\"&gt;&lt;/script&gt; 1.2、基本语法&lt;script&gt; &lt;!--JavaScript严格区分大小写--&gt; var score = 1 ; if (score &gt; 60 &amp;&amp; score &lt; 70)&#123; alert(\"60~70\"); &#125;else if(score &gt; 70 &amp;&amp; score &lt; 80)&#123; alert(\"70~80\"); &#125;else&#123; alert(\"other\") &#125; &lt;/script&gt; 1.3、数据类型· 变量：var a · number：js不区分小树和整数 · 字符串：'abc' \"abc\" · 布尔值：true | false · 逻辑运算： &amp;&amp; 两个都为真，结果为真 || 一个为真，结果为真 ! 真即假，假即真 · 比较运算符： == 等于（类型不一样，值一样，也会判断为true） === 绝对等于（类型一样，值一样，结果为true） · NaN === NaN，这个与所有的数值都不相等，包括自己 只能通过isNaN（NaN）来判断这个数是否是NaN · 尽量避免使用浮点数进行运算，存在精度问题！ · null 空 · undefined 未定义 · Java的数组必须是相同类型的对象~，JS中不需要这样 //保证代码的可读性，尽量使用[] var arr = [1,2,3,4,5,'hello',null,true]; //第二种定义方法 new Array(1,2,3,4,5,'hello'); · 对象 var person = &#123; name:'Tom', age:3, tags:['js','java','web','...'] &#125; · 取对象值 person.name &gt; \"Tom\" person.age &gt; 3 1.4、严格检查模式改用ES6&lt;script&gt; 'use strict'; //全局变量 let i=1 //ES6 let &lt;/script&gt; 二、数据类型2.1、字符串特殊转义字符\\' \\n \\t \\u4e2d \\u##### Unicode字符 \\x41 Ascall字符 多换字符串编写var msg = `hello world 你好呀 nihao ` 模板字符串let name = 'Tom'; let age = 3; var msg = `你好，$&#123;name&#125;` //tab 上面 esc下面 字符串长度str.length 大小写转换//注意，这里是方法，不是属性了 student.toUpperCase(); student.toLowerCase(); 取下标student.indexof('t') 切片substring，从0开始，取左不取右 student.substring(1)//从第一个字符串截取到最后一个字符串 student.substring(1,3)//[1,3) 2.2、数组Array可以包含任意的数据类型var arr = [1,2,3,4,5,6];//通过下标取值和赋值 长度arr.length //注意：假如给arr.lennth赋值，数组大小就会发生变化~，如果赋值过小，元素就会丢失 indexOf，通过元素获得下标索引arr.indexOf(2) 1 //字符串的\"1\"和数字 1 是不同的 slice()：截取Array的一部分，返回的一个新数组，类似于String中substring push()，pop() 进出栈原理push：压入到尾部 pop：弹出尾部的一个元素 unshift(),shift() 头部unshift：压入到头部 shift：弹出头部的一个元素 排序sort()(3)[\"B\",\"C\",\"A\"] arr.sort() (3)[\"A\",\"B\",\"C\"] 元素反转reverse()(3)[\"A\",\"B\",\"C\"] arr.reverse() (3)[\"C\",\"B\",\"A\"] concat()注意：concat()并没有修改数组，只是会返回一个新的数组 var a = [1,2,3] a.concat(4,5) 连接符join()在本例中，我们将创建一个数组，然后把它的所有元素放入一个字符串： &lt;script type=\"text/javascript\"&gt; var arr = new Array(3) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr.join()) &lt;/script&gt; =&gt; George,John,Thomas ------------------------------------------------ 在本例中，我们将使用分隔符来分隔数组中的元素： &lt;script type=\"text/javascript\"&gt; var arr = new Array(3) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr.join(\".\")) &lt;/script&gt; George.John.Thomas 多维数组：同java 2.3、对象基本格式var 对象名 = &#123; 属性名：属性值， 属性名：属性值， 属性名：属性值 &#125; //定义了一个person对象，它有四个属性 var person = &#123; name:\"Tom\", age:3, email:\"123456798@QQ.com\", score:66 &#125; 使用一个不存在的对象属性，不会报错！undefinedperson.haha &gt;&gt;&gt; undefined 动态的删减属性，通过delete删除对象属性delete person.name true 动态添加，直接给新的属性添加值即可person.haha = 'haha'; 'haha' 判断属性是否在这个对象中！xxx in xxx'age' in person true //继承 'toString' in person true 判断一个属性是否是这个对象自身拥有的：hasOwnProperty()person.hasOwnProperty('toString') false person.hasOwnProperty('age') true 2.4、流程控制if、while、for同Javavar age = 3; if(age&gt;3)&#123; alert(3); &#125;else if(age&lt;5)&#123; alert(5); &#125;else&#123; alert(haha); &#125; while(age &lt; 100)&#123; age = age + 1; console.log(age); &#125; for(let i = 0;i &lt; 100; i++)&#123; console.log(i); &#125; forEach循环var age = [12,3,45,123,5,3,6,4,8] age.forEach(function (value) &#123; console.log(value); &#125;) for…infor(var index in age)&#123; console.log(age[index]); &#125; 2.5、Map 和 Set ES6的新特性Map//ES6 //学成的成绩，学生的名字 var names = ['tom','jack','sam']; var scores = [100,90,80]; var map = new Map([['tom',100],['jack',90],['sam',80]]) var name = map.get('tom'); console.log(name);// map.set('admin',123456);//新增元素 console.log(map);//Map(4)&#123;\"tom\" =&gt; 100, \"jack\" =&gt; 90, \"sam\" =&gt; 80, \"admin\" =&gt; 123456&#125; map.delete('tom');//删除元素 console.log(map);//Map(3)&#123;\"jack\" =&gt; 90, \"sam\" =&gt; 80, \"admin\" =&gt; 123456&#125; Set：无需不重复的集合//set可以去重 var set = new Set([3,1,1,1,1,2]); set.add(4);//添加 console.log(set);//Set(4) &#123;3, 1, 2, 4&#125; set.delete(1);//删除 console.log(set);//Set(3) &#123;3, 2, 4&#125; console.log(set.has(3));//是否包含某个元素 2.6、Iterator遍历数组//通过for of / for in 下标 var arr = [3,4,5]; for(var x of arr)&#123; console.log(x) &#125; //存在一个bug arr.name = 123; for(var x of arr)&#123; console.log(x) &#125; 输出: 1 2 3 name 遍历map//遍历map for(let x of map)&#123; console.log(x); &#125; 遍历set//遍历set for(let x of set)&#123; console.log(x); &#125; 三、函数3.1、定义函数方式一function abs(x)&#123; return x; &#125; //一旦执行到return代表函数结束，返回结果。 //如果没有执行return，函数执行完也会返回结果，返回就是undefined 方式二var abs = function(x)&#123; return x; &#125; //function(x),这是一个匿名函数，但是赋值给abs。所以通过abs可以调用 参数问题//jJavaScript可以传任意个参数，也可以不传递参数。 //参数进来是否存在的问题？假设不存在参数，如何规避？ var abs = function (x) &#123; //参数个数 console.log(arguments.length); //手动抛出异常 if (typeof x !=='number')&#123; throw 'Not a Number'; &#125; return x; &#125; //arguments：代表传递进来所有的参数，是一个数组 问题：arguments 包含所有的参数，我们有时候想使用多余的参数来进行附加操作，需要排除已有参数//rest：获去除了已经定义的参数，ES6引入的新特性 function arg(a,b,...rest) &#123; console.log(a); console.log(b); console.log(rest); &#125; //rest参数只能写在最后面，必须用…标识 3.2、变量的作用域在Javascript中，var定义变量实际是有作用域的。假设在函数体中声明，则在函数体外不可以使用~（如果想要实现，则需要闭包）function abc() &#123; var x= 1; x = x + 1; &#125; x = x + 2 ;//Uncaught ReferenceError: x is not defined 如果两个函数使用相同变量名，只要在函数内部，就不冲突function abc1() &#123; var x= 1; x = x + 1; &#125; function abc2() &#123; var x= 2; x = x + 1; &#125; 内部函数可以询问外部函数的成员，反之则不行function abc3() &#123; var x= 1; //内部函数可以询问外部函数的成员，反之则不行 function abc3() &#123; var y = x + 1;//2 &#125; var z = y + 1;//Uncaught ReferenceError: x is not defined &#125; 假设：内部函数变量与外部函数变量重名function abc5() &#123; var x = 1; function abc6() &#123; var x = A; console.log('inner' + x);//outer1 &#125; console.log('outer'+x);//innerA abc6(); &#125; //不冲突，自己有就用自己的 提升变量作用域function abc8() &#123; var x = 'x' + y; console.log(x); var y = 'y'; &#125; //结果：undefined //说明：js执行引擎，自动提升了y的声明，但是不会提升y的赋值 function abc8() &#123; var y; var x = 'x' + y; console.log(x); y = 'y'; &#125; //这是在Javascript简历之初就存在的特性。养成规范：所有的变量定义都放在函数头部，不要乱放，便于代码维护； function abc()&#123; var x = 1, y = x + 1, z,i,a;//undefined &#125; 全局函数//全局变量 x = 1; function f()&#123; console.log(x); &#125; f(); console.log(x); 全局对象：windowvar x = 'xxx'; alert(x); alert(windws.x); //alert()这个函数本身也是一个window变量： var x = 'xxx'; window.alert(x); var old_alert = window.alert; // old_alert(x); window.alert = function () &#123; &#125;; //发现alert()失效了 window.alert(123); //恢复 window.alert = old_alert; window.alert(456); //Javascript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围，就会向外查找，如果在全局作用域都没有找到，报错RefrenceError 规范：由于我们所有的全局变量都会绑定到我们的window上。如果不同的js文件，使用了相同的全局变量，冲突-&gt;如何能够减少冲突？//唯一全局变量 var LiusxApp = &#123;&#125;; //定义全局变量 LiusxApp.name = 'xiaoming'; LiusxApp.add = function (a,b) &#123; return a + b; &#125; //把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突的问题。（jQuery） 局部作用域：letfunction aaa()&#123; for(var i = 0; i &lt; 100 ;i++)&#123; console.log(i); &#125; console.log(i+1);//问题，i 出了这个作用域还可以使用 &#125; //ES6：let关键字，解决局部作用域冲突问题！ function aaa()&#123; for(let i = 0; i &lt; 100 ;i++)&#123; console.log(i); &#125; console.log(i+1);//问题，i 出了这个作用域即刻失效 &#125; //建议大家都用let取定义局部作用域的变量 const：ES6之前，怎么定义常量：只有用全部大写字母命名的变量就是常量：建议不要修改这样的值const PI = '3.14';//只读效果 console.log(PI); PI = '123';//Uncaught TypeError: Assignment to constant variable. console.log(PI); 3.3、方法定义方法（方法就是把函数放在对象里面，对象中只有2个东西：属性和方法）var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: function () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; &#125; //属性 liusx.name; //方法，一定要带() liusx.age(); this的使用：没有上下午关系直接使用会NaN，但可以添加指向var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: function () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; &#125; //属性 liusx.name; //方法，一定要带() liusx.age(); function getAge () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: getAge &#125; //liusx.age() =&gt;ok //getAge() =&gt;NaN 控制this的指向function getAge () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: getAge &#125; //liusx.age() =&gt;ok //getAge() =&gt;NaN getAge.apply(liusx,[])//this，指向了liusx，参数为空 四、内部对象标准对象typeof 123 \"number\" typeof '123' \"string\" typeof true \"boolean\" typeof NaN \"number\" typeof [] \"object\" typeof &#123;&#125; \"object\" typeof Math.abs \"function\" typeof undefined \"undefined\" 4.1、Date的基本使用var now = new Date();// now.getFullYear();//年 now.getMonth();//月 now.getDate();//日 now.getDay();//星期几 now.getHours();//时 now.getMinutes();//分 now.getSeconds();//秒 now.getTime();//时间戳 全世界统一 1970 1.1 8:00:00 console.log(new Date(1589096655409));//时间戳转时间 //转换 //本地时间 now.toLocaleString(); \"2020/5/10 下午3:44:15\" //东八区 now.toGMTString(); \"Sun, 10 May 2020 07:44:15 GMT\" 4.2、JSON//JSON 字符串和 JS 对象的转换 var user = &#123; name: 'liusx', age: 3, sex: '男' &#125; //对象转换json字符串:&#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125; var jsonuUer = JSON.stringify(user); console.log(jsonuUer); //json 字符串转换为对象，参数为json字符串 var obj = JSON.parse('&#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125;'); console.log(obj); //JSON 和 JS 对象的区别： var obj = &#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125;; var json = '&#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125;'; 4.3、Ajax原生的Javascript写法，xhr异步请求 jQuery封装好的方法 axios请求 五、原型5.1、原型的概念（类似Java继承）//面向对象 var Student = &#123; name: 'liusx', age: 3, run:function () &#123; console.log(this.name+\"run.....\") &#125; &#125; var xiaoming = &#123; name: '小明' &#125; //小明的原型 是Student xiaoming.__proto__ = Student; //把属性继承给小明 xiaoming.run(); var Bird = &#123; fly: function () &#123; console.log(this.name + \"fly......\") &#125; &#125; //小明的原型 是Bird xiaoming.__proto__ = Bird; 5.2、class继承：class关键字，ES6引入//class继承 function Student(name) &#123; this.name = name; &#125; //给student新增一个方法 Student.prototype.hello = function () &#123; alert('hello'); &#125; 1、定义一个类，属性，方法//ES6 之后======极度类似Java class Student&#123; constructor(name)&#123; this.name = name; &#125; hello()&#123; alert('hello'); &#125; &#125; var xiaoming = new Student('小明'); var xiaoming = new Student('小红'); xiaoming.hello(); 2、继承//ES6 之后======极度类似Java class Student&#123; constructor(name)&#123; this.name = name; &#125; hello()&#123; alert('hello'); &#125; &#125; class XiaoStudent extends Student &#123; constructor(name,grade)&#123; super(name); this.grade = grade; &#125; myGrade()&#123; alert('我是一名小学生'); &#125; &#125; var xiaoming = new Student('小明'); xiaoming.hello(); var xiaohong = new XiaoStudent('小红',1); xiaohong.myGrade(); 5.3、原型链__proto__ //无限套娃，形成了链 六、操作BOM对象（重点）6.1、window（重要）：代表浏览器窗口window.alert(1) undefined window.innerHeight 722 window.innerWidth 1148 window.outerHeight 824 window.outerWidth 1536 // 大家可以调整浏览器窗口试试 6.2、Navigator：封装了浏览器信息//大多数时候，我们不会使用：Navigator 对象，因为会被认为修改！不建议使用这些属性判断和编写代码 navigator.appName \"Netscape\" navigator.appVersion \"5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\" navigator.userAgent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\" navigator.platform \"Win32\" 6.3、screen：代表屏幕尺寸screen.width 1536 screen.height 864 6.4、location（重要）：代表当前页面的URL信息host:\"www.baidu.com\" href:\"https://www.baidu.com/\" proticlo:\"https\" reload:f reload()// 刷新网页 // 设置新的地址 location.assign('https://Guzhz.github.io/') 6.5、document（内容：DOM）：代表当前页面，HTML DOM文档树document.title \"百度一下，你就知道\" 6.6、获取具体的文档数节点&lt;dl id=\"app\"&gt; &lt;dt&gt;Java&lt;/dt&gt; &lt;dt&gt;JavaSE&lt;/dt&gt; &lt;dt&gt;JavaScript&lt;/dt&gt; &lt;/dl&gt; &lt;script&gt; var dl = document.getElementById('app'); &lt;/script&gt; 6.7、获取：cookiedocument.cookie //劫持cookie原理 &lt;script src=\"aa.js\"&gt;&lt;/script&gt; &lt;!--恶意人员：获取你的cookie上传到它的服务器--&gt; //服务器端可以设置cookie：httpOnly 6.8、history（不建议使用）：代表浏览器的历史记录histor.forward();//前进 history.back();//后退 七、操作DOM对象（重点）7.1、获得Dom节点&lt;div id=\"father\"&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var h1 = document.getElementsByTagName(\"h1\"); //返回数组 var p1 = document.getElementById(\"p1\") var p2 = document.getElementsByClassName(\"p2\"); //返回数组 var father = document.getElementById(\"father\"); //获取父节点下所有的子节点 var childrens = father.children; //father.firstChild; //father.lastChild; &lt;/script&gt; 7.2、更新节点&lt;div id=\"id1\"&gt; &lt;/div&gt; &lt;script&gt; var id1 = document.getElementById('id1'); id1.innerText='456';//修改文本的值 id1.innerHTML='&lt;strong&gt;456&lt;/strong&gt;';//可以解析HTML文本标签 //操作CSS id1.style.color = 'yellow';// 属性使用 字符串 包裹 id1.style.fontSize = '20px';// - 转 驼峰命名问题 id1.style.padding = '2em' &lt;/script&gt; 7.3、删除节点：先获取父节点，再通过父节点删除自己&lt;div id=\"father\"&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var self = document.getElementById(\"p1\") var father = p1.parentElement; father.removeChild(self); //删除是一个动态的过程，先删除0，在删除2会找不到2节点，因为会重新排序 father.removeChild(father.children[0]); father.removeChild(father.children[1]) father.removeChild(father.children[2]) &lt;/script&gt; 7.4、插入节点我们获得了某个Dom节点，假设这个dom节点是空的，我们通过 innerHTML 就可以增加一个元素，但是如果这个DOM节点已经存在元素了，则会直接覆盖。追加：appendChild()&lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var js = document.getElementById('js'); var list = document.getElementById('list'); //追加到后面 list.appendChild(js); &lt;/script&gt; ----- 追加后效果为： &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;/div&gt; 创建一个新的标签，实现插入&lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js');//已经存在的节点 let list = document.getElementById('list'); //追加到后面 //list.appendChild(js); //通过JS 创建一个新的节点 let newP = document.createElement('p'); newP.id = 'newP'; newP.innerText = 'Hello,Sam'; list.appendChild(newP); //创建一个标签节点 let myScript = document.createElement('script'); myScript.setAttribute('type', 'text/javascript'); //给body标签创建样式1 let body = document.getElementsByTagName('body')[0]; body.setAttribute('style', 'background-color: yellow;'); //给body标签创建样式2 //let myStyle = document.createElement('style');//创建一个style标签 //myStyle.setAttribute('tyle', 'text/css'); //myStyle.innerHTML = 'body&#123;background-color: chartreuse;&#125;';//设置样式 //document.getElementsByTagName('head')[0].appendChild(myStyle); &lt;/script&gt; ---------------------------------------------------------------- 追加后效果为： &lt;body style=\"background-color: yellow;\"&gt; &lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"newP\"&gt;Hello,Sam&lt;/p&gt; &lt;script type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/div&gt; &lt;/body&gt; insertBefore()追加&lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js');//已经存在的节点 let list = document.getElementById('list'); let ee = document.getElementById('ee'); //要包含的节点. insertBefore(newNode,targetNode) list.insertBefore(js, ee); &lt;/script&gt; ---- 追加后效果为： &lt;body&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 八、操作表单（验证）8.1、表单：form DOM树文本框：text 下拉框：select 单选框：radio 多选框：checkbox 隐藏域：hidden 密码框：password … 表单的目的：提交信息 8.2、获得要提交的信息&lt;form action=\"#\" method=\"post\"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=\"text\" id=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type=\"radio\" name=\"sex\" value=\"man\" id=\"boy\"&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"woman\" id=\"girl\"&gt;女 &lt;/p&gt; &lt;script&gt; var input_text = document.getElementById('username'); //得到输入框的值：input_text.value //修改输入框的值：input_text.value = wudi var boy_radio = document.getElementById('boy'); var girl_radio = document.getElementById('girl'); //对于单选框、多选框等等固定的值， boy_radio.checked;//查看返回的结果，是否为true，如果为true，则被选中 girl_radio.checked = true;//赋值 &lt;/script&gt; &lt;/form&gt; //提交表单：MD5加密，表单优化 8.3、一般MD5加密&lt;script&gt; function sub() &#123; let username = document.getElementById('username'); let password = document.getElementById('password'); console.log(username); console.log(password); // MD5 算法 方案一： password.value = md5(password.value); console.log(password.value); &#125; &lt;/script&gt; //隐藏密码框+MD5加密： &lt;!-- 表单绑定提交事件 onsubmit = 绑定一个提交检查的函数，true，false 将这个结果返回给表单，使用 onsubmit 接收！ οnsubmit=\"return sub();\" --&gt; &lt;form action=\"#\" method=\"post\" onsubmit=\"return sub();\"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密码：&lt;/span&gt;&lt;input type=\"password\" id=\"password\"&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;/p&gt; &lt;button type=\"submit\" &gt;提交&lt;/button&gt; &lt;script&gt; function sub() &#123; let username = document.getElementById('username'); let password = document.getElementById('password'); let md5password = document.getElementById('md5-password'); //MD5 算法：隐藏表单域提交表单密码 md5password.value = md5(password.value); //可以校验判断表单内容，true：通过提交，false：阻止提交 return true; &#125; &lt;/script&gt; &lt;/form&gt; 九、jQuery jQuery API：http://jquery.cuishifeng.cn/ 9.1、初始jQuery（直接引用、使用js文件）&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"\" id=\"test-jquery\"&gt;点我&lt;/a&gt; &lt;script&gt; $('#test-jquery').click(function () &#123; alert('hello,jQuery') &#125;) &lt;/script&gt; &lt;/body&gt; 9.2、选择器&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //原生js，选择器少，麻烦且不好记 //id、标签、类 document.getElementById(); document.getElementsByTagName(); document.getElementsByClassName(); //jQuery 就是 css中的选择器 $('#id').click();//id选择器 $('div').click();//标签选择 $('.className').click();//class选择器 &lt;/script&gt; 9.3、操作DOM/* 节点文本操作; css操作; 元素的显示和隐藏：本质 display=none; …等等更多查看API */ &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"test-ul\"&gt; &lt;li id=\"js\" class=\"js\"&gt;Javascript&lt;/li&gt; &lt;li name=\"python\"&gt;Python&lt;/li&gt; &lt;li id=\"sh\"&gt;show_hide&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(\"#test-ul li[name='python']\").text();//获得值 $(\"#test-ul li[name='python']\").text('Python_new'); $('#test-ul').html();//获得值 $('test-ul').html('&lt;strong&gt;html_new&lt;/strong&gt;');//设置值 $('#js').css('color','red');//设置样式 $('#sh').show();//显示 $('#sh').hide();//隐藏 $(window).width(); $(window).height(); $(document).width(); $(document).height(); &lt;/script&gt; &lt;/body&gt; 2020年06月09日 晚上Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CSS3的简单回顾","slug":"CSS3的简单回顾","date":"2020-06-08T05:37:35.000Z","updated":"2020-06-08T06:35:25.000Z","comments":true,"path":"2020/06/08/CSS3的简单回顾/","link":"","permalink":"http://yoursite.com/2020/06/08/CSS3的简单回顾/","excerpt":"","text":"前言：教学视频参考 1、CSS3的三种导入方式 优先级：就近原则 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!--内部样式--&gt; &lt;style&gt; h1 &#123; color: green; &#125; &lt;/style&gt; &lt;!--外部样式--&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--行内样式：在标签元素中，编写一个style属性，编写样式即可--&gt; &lt;h1 style=\"color: red\"&gt;这是标签&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 拓展：CSS2.1导入式 &lt;style&gt; @import url(\"css/style.css\"); &lt;/style&gt; 2、选择器2.1、基本选择器标签选择器：选择一类标签 标签.&#123; &#125; class选择器：.类名&#123; &#125; id选择器：#.ID名&#123; &#125; 2.2、层次选择器 后代选择器，在某个元素的后面 &lt;style&gt; body p &#123; background: red; &#125; &lt;/style&gt; 子选择器，一代 &lt;style&gt; body&gt;p &#123; background: orange; &#125; &lt;/style&gt; 相邻兄弟选择器：只有一个，相邻（向下） &lt;style&gt; .active+p &#123; background: red &#125; &lt;/style&gt; &lt;body&gt; &lt;p class=\"active\"&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/body&gt; 通用兄弟选择器，当前选中元素的向下的所有兄弟元素 &lt;style&gt; .active~p &#123; background: red; &#125; &lt;/style&gt; &lt;body&gt; &lt;p class=\"active\"&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/body&gt; 2.3、结构伪类选择器 ul的第一个子元素 ul li:first-child &#123; background: aqua; &#125; ul的最后一个子元素 ul li:last-child &#123; background: blue; &#125; 选中pfather：定位到父元素，选择当前的第一个子元素p，子元素的第一位必须为p才生效 pfather:nth-child(1) &#123; background: orange; &#125; 选中父元素下的，第2个p元素 p:nth-of-type(2) &#123; background: red; &#125; 2.4、属性选择器（常用） class + id 结合 &lt;style&gt; .demo a &#123; display: block; height: 50px; width: 50px; float: left; border-radius: 10px; background: blue; text-align: center; color: beige; text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; &#125; &lt;/style&gt; 标签名[属性名=属性值]（正则: =、*=、^=、$=） &lt;style&gt; /*存在id的a标签*/ a[id] &#123; background: red; &#125; /* =表示绝对等于 *=表示包含... ^=表示以...开头 $=表示以...结尾 */ /*id=first的a标签*/ a[id=first] &#123; background: aqua; &#125; /*class属性值绝对等于\"links item2 first2\"*/ a[class=\"links item2 first2\"] &#123; background: orange; &#125; /*class属性值绝对包涵\"links\"*/ a[class *=\"links\"] &#123; background: black; &#125; /*选中href中以http开头的元素*/ a[href^=\"http\"] &#123; background: orange; &#125; &lt;/style&gt; &lt;p class=\"demo\"&gt; &lt;a href=\"http://www.baidu.com\" class=\"links item first\" id=\"first\"&gt;1&lt;/a&gt; &lt;a href=\"/adad/faf\" class=\"links item2 first2\"&gt;2&lt;/a&gt; &lt;a href=\"qwe123\" class=\"links item3 first3\"&gt;3&lt;/a&gt; &lt;a href=\"eweqe\" class=\"links item4 first4\"&gt;4&lt;/a&gt; &lt;a href=\"rrrrr\" class=\"links item5 first5\"&gt;5&lt;/a&gt; &lt;a href=\"ttt\" class=\"links item6 first6\"&gt;6&lt;/a&gt; &lt;a href=\"yyy\" class=\"links item7 first7\"&gt;7&lt;/a&gt; &lt;/p&gt; 3、美化网页元素3.1、字体 建立在标签上的处理，所以建议用span包裹 &lt;head&gt; &lt;style&gt; #title1 &#123; font-size: 50px; font-weight：blod; font-family: 楷体; /*常用写法：*/ font: oblique bloder 12px \"楷体\" &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=\"title1\"&gt;JAVA&lt;/span&gt; &lt;/body&gt; 3.2、文本 下划线 text-decoration:underline /*下划线*/ text-decoration:line-through /*中划线*/ text-decoration:overline /*上划线*/ text-decoration:none /*超链接去下划线*/ 图片、文字水平居中 img,span &#123; vertical-align: middle &#125; 3.3、文本，阴影和超链接伪类 超链接伪类 &lt;style&gt; /*超链接有默认的颜色*/ a &#123; text-decoration: none; color: #000000; &#125; a:hover &#123; /*鼠标悬浮的状态*/ color: orange; &#125; a:active &#123; /*鼠标按住未释放的状态*/ color: green &#125; a:visited &#123; /*点击之后的状态*/ color: red &#125; &lt;/style&gt; 阴影 左 下 半径 text-shadow:5px 5px 5px 颜色 3.4、利用列表ul li小设计：a进来变样式ul li &#123; height: 30px; list-style: none; /*none:去掉原点、circle:空心圆、decimal:数字、square:正方形*/ text-indent: 1em; /*缩进*/ &#125; a&#123; text-decoration: none; /*首先去掉下划线*/ font-size: 14px; color: #000; &#125; a:hover &#123; color: orange; text-decoration: underline /*进来再有下划线*/ &#125; /*放在div中，作为导航栏*/ &lt;div id=\"nav\"&gt;&lt;/div&gt;#nav &#123; width: 300px; &#125; 3.5、背景样式、图片background:red --------------------------------------------- background-image:url(\"\"); /*默认是全部平铺的*/ background-repeat:repeat-x /*水平平铺*/ background-repeat:repeat-y /*垂直平铺*/ background-repeat:no-repeat /*不平铺*/ --------------------------------------------- background:red url(\"url\") 270px 10px no-repeat /*综合使用*/ background-position:center /*定位：背景位置*/ 拓展：渐变网址：https://www.grablent.com径向渐变、圆形渐变 4、盒子模型4.1、什么是盒子模型margin：外边距 padding：内边距 border：边框 4.2、边框border：2px solid red 4.3、外边距的妙用：居中margin:0 0 0 0 /*表示上、右、下、左*/ margin:0 auto /*居中、auto表示左右自动*/ margin:4px /*表示上、右、下、左都为4px*/ margin:10px 20px 30px /*表示上为10px，左右为20px，下为30px*/ 开发中的常用操作/* 盒子的计算方式：margin+border+padding+内容的大小 */ /* body总有一个默认的外边距，开发中会先把内外边距置为0 */ margin:0; padding:0; text-decoration:none; 4.4、圆角边框：border-radius（顺时针），左上开始 圆圈：圆角=半径 border-radius: 有四个参数 5、浮动5.1、标准文档流 包涵关系：块级元素包裹行级元素块级元素：独占一行 h1~h6 、p、div、 列表…行内元素：不独占一行 span、a、img、strong 5.2、display（重要） block：块元素inline：行内元素inline-block：行内块元素none：消失注：这也是一种实现行内元素排列的方式，但是我们很多情况用float 5.3、float：浮动 参考：详细参考div&#123; float:left/right &#125; /*浮动后，不再属于标准中的元素，下面的元素会上移、但本身还会于上面的元素对其*/ /*假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)； 如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。*/ 清除浮动 clear/* right：右侧不允许有浮动元素 left： 左侧不允许有浮动元素 both： 两侧不允许有浮动元素 none： 两侧允许有浮动元素 对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。*/ 5.4、解决浮动后父级边框塌陷问题/* 方案一：增加父级元素的高度；*/ /* 方案二：增加一个空的div标签，清除本标签的浮动来实现补回原标签 */ &lt;style&gt; .clear&#123; clear:both; margin:0; padding:0; &#125; &lt;/style&gt; &lt;div class = \"clear\"&gt;&lt;/div&gt; /* 方案三：在父级元素中增加一个滚动条然后隐藏起来：overflow：hidden */ overflow:hidden /*隐藏*/ overflow：scoll /*滚动*/ /* 方案四：父类添加一个伪类:after */ #father:after&#123; content:''; display:block; clear:both; &#125; 浮动元素增加空div----&gt; 简单、代码尽量避免空div 设置父元素的高度-----&gt; 简单，元素假设没有了固定的高度，就会超出 overflow----&gt; 简单，下拉的一些场景避免使用 父类添加一个伪类:after（推荐）----&gt; 写法稍微复杂，但是没有副作用，推荐使用 5.5、display与float对比 display：方向不可以控制float：浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题。 6、定位6.1、相对定位（relative） 相对于自身的位置，它仍然在标准文档流中h2.pos_left&#123; location:relative top:-20px; left:20px; bottom:-10px; right:20px; &#125; 6.2、绝对定位： /* 总结：相对一父级或浏览器的位置，进行指定的偏移， 绝对定位的话，它不在标准文档流中，原来的位置不会被保留 */ div:nth-of-type(1)&#123;/*绝对定位：没有相对的父级元素，所以相对于浏览器*/ width: 100px; height: 100px; background:red; position: absolute; right: 0; bottom: 0; &#125; 6.3、固定定位div:nth-of-type(2)&#123; /*始终在右下角*/ width: 50px; height: 50px; background: yellow; position: fixed; right: 0; bottom: 0; &#125; 6.4、图层 z-index：默认是0，最高无限~999(最顶层).tipText&#123; color: white; z-index: 999; &#125; 6.5、透明度.tipBg&#123; background: orange; opacity: 0.5; /*背景透明度*/ filter: alpha(opacity=50); /*原理同上，这里解决ie的兼容性问题*/ &#125; 2020年06月06日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"HTML5的简单回顾","slug":"HTML5的简单回顾","date":"2020-06-06T05:37:35.000Z","updated":"2020-06-06T05:39:25.000Z","comments":true,"path":"2020/06/06/HTML5的简单回顾/","link":"","permalink":"http://yoursite.com/2020/06/06/HTML5的简单回顾/","excerpt":"","text":"前言：教学视频参考：https://www.bilibili.com/video/BV1x4411V75C 网页基本标签&lt;!--meta描述性标签，用来描述我们网站的一些信息--&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"keywords\" content=\"跟狂神学Java\"&gt; &lt;meta name=\"description\" content=\"可以学习java\"&gt; 粗体：&lt;strong&gt;&lt;/strong&gt; 斜体：&lt;em&gt;&lt;/em&gt; 空 &amp;nbsp; 大于号 &amp;gt; 小于号 &amp;lt; 版权符号 &amp;copy; &lt;!--图像标签： alt:图片描述--&gt; &lt;img src=\"../resources/image/1.jpg\" alt=\"我的图片\" title=\"悬停文字\" width=\"1366\" height=\"768\"&gt; target=\"_blank\" ：在新标签中打开 target=\"_self\" ：在自己的网页中打开 target=\"#MarkName\"：即跳转到锚点 &lt;!--锚链接：指定跳转到页面的某个位置，需要定义name属性作为标记--&gt; &lt;a name=\"top\"&gt;顶部&lt;/a&gt; &lt;!--跳转到标记--&gt; &lt;a href=\"#top\"&gt;回到顶部&lt;/a&gt; &lt;!--邮件连接：mailto--&gt; &lt;a href=\"mailto:936681921@qq.com\"&gt;点击联系我&lt;/a&gt; 行内元素和块元素块元素：无论内容有多少，元素自己独占一行 行内元素：内容撑开宽度，左右都是行内元素的可以排在一行 列表标签有序列表 &lt;ol&gt; &lt;li&gt;语文&lt;/li&gt; 1.语文 &lt;li&gt;数学&lt;/li&gt; 2.数学 &lt;li&gt;英语&lt;/li&gt; 3.英语 &lt;/ol&gt; 无序列表 &lt;ul&gt; &lt;li&gt;语文&lt;/li&gt; ● 语文 &lt;li&gt;数学&lt;/li&gt; ● 数学 &lt;li&gt;英语&lt;/li&gt; ● 英语 &lt;/ul&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;科目&lt;/dt&gt; 科目 &lt;dd&gt;语文&lt;/dd&gt; 语文 &lt;dd&gt;数学&lt;/dd&gt; 数学 &lt;dd&gt;英语&lt;/dd&gt; 英语 &lt;/dl&gt; 表格标签&lt;table&gt; ...&lt;/table&gt; 表格标签。 &lt;tr&gt;...&lt;/tr&gt; 行标签，代表一行。 &lt;td&gt;...&lt;/td&gt; 列标签，代表一列。 border=\"\" 表示表格线条宽度。 colspan=\"3\" 表示这一单元跨几列。 rowspan=\"2\" 表示这一单元跨几行。 视频和音频controls：控制调 autoplay：自动播放 &lt;video src=\"../resources/video/2.mp4\" controls autoplay&gt;&lt;/video&gt; &lt;audio src=\"../resources/audio/3.mp3\" controls autoplay&gt;&lt;/audio&gt; 结构分析&lt;header&gt; &lt;h2&gt;网页头部&lt;/h2&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;网页主体&lt;/h2&gt; &lt;/section&gt; &lt;footer&gt; &lt;h2&gt;网页脚步&lt;/h2&gt; &lt;/footer&gt; &lt;nav&gt;导航&lt;/nav&gt; iframe内联框架&lt;body&gt; &lt;!--单独使用--&gt; &lt;iframe src=\"www.baidu.com\" name=\"go\" frameborder=\"0\" width=\"1000\" height=\"800\"&gt;&lt;/iframe&gt; &lt;!--配合a标签使用--&gt; &lt;iframe src=\"\" name=\"go\" frameborder=\"0\" width=\"1000\" height=\"800\"&gt;&lt;/iframe&gt; &lt;a href=\"https://www.baidu.com\" target=\"go\" &gt;点击打开百度&lt;/a&gt; &lt;/body&gt; 表单&lt;body&gt; &lt;form action=\"\" method=\"\"&gt; action:填写表单内数据提交给的地址。 是提交表单数据的方式，get可以在url看见提交的内容，post的保密性稍高。 &lt;input type=\"\"&gt; &lt;/form&gt; type=\"text\" 默认文本框。 type=\"password\" 密码框，输入不显示密码。 type=\"search\" 搜索框。 type=\"submit\" 提交按钮，网页中点击提交。 type=\"reset\" 重置按钮，网页中点击后表单重置。 hidden:隐藏。 单选框： type=\"radio\" name=\"\":填入组名，网页内在同一组内的单选框只能选中一个，不在同一组则 相当于多选框。 value=\"\"：提交时显示的名字。 checked:默认选择本项选中。 多选框： type=\"checkbox\" name=\"\":填入组名。 value=\"\"：提交时显示的名字。 checked:默认选择本项选中。 普通按钮： type=\"button\": name=\"\":提交时的按钮名。 value=\"\"：在网页显示在按钮中的字符。 下拉列表框： &lt;select name=\"\"&gt;:name中填写列表名。 &lt;option value=\"\"&gt;:value填写单元名 &lt;option value=\"\"&gt;:value填写单元名 &lt;/select&gt; selected:默认选择本项选中。 文本域： &lt;textarea name=\"\"cols=\"30\" rows=\"10\" placeholder=\"\"&gt; name=\"\" :文本域名。文本域网页。 cols=\"30\" :列数。 rows=\"10\" :行数。 placeholder=\"\":默认显示内容，所有文本框可用。 文件域： &lt;input type=\"file\" name=\"files\"&gt; 滑块： &lt;input type=\"range\" name=\"range\" min=\"0\" max=\"100\" step=\"5\"&gt;滑块网 页 type=\"range\" min：表示滑块底部的数值。 max：表示滑块顶端的数值。 step：表示每次拖动滑块改变的数值。 数字验证： &lt;input type=\"number\" name=\"number\" min=\"0\" max=\"100\" step=\"1\"&gt;数字 验证网页 min：表示最低数字。 max：表示最大数字。 step：表示每次增加时改变的数值。 &lt;label for=\"\"&gt;此处可任意填写&lt;/label&gt; 给其他标签添加id=\"\"属性，然后将id中的字符填入for=\"\",点击其产生的字符 可指向对应id的文本框。 初级验证 type=\"email\" 邮箱输入框，带有简单的邮箱格式验证。 type=\"url\" url连接输入框，带有简单的格式验证。 type=\"number\" &lt;input type=\"number\" name=\"num\" max=\"100\" min=\"1\" step=\"1\"&gt; pattern=\"正则表达式验证，使用正则表达式验证文本框填写是否正确\" &lt;/body&gt; 2020年06月06日 下午Guzhz","categories":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/categories/学习记录/"}],"tags":[{"name":"Html5","slug":"Html5","permalink":"http://yoursite.com/tags/Html5/"}]},{"title":"新玩意儿","slug":"新玩意儿","date":"2020-03-26T13:50:30.000Z","updated":"2020-03-26T13:50:30.000Z","comments":true,"path":"2020/03/26/新玩意儿/","link":"","permalink":"http://yoursite.com/2020/03/26/新玩意儿/","excerpt":"","text":"耗时三天，搭建了人生的，第一个网站，感觉还不错。(#^.^#) Mood从郁闷到舒畅。 Weather阴天。 Date2019年3月26日 晚上 完结","categories":[{"name":"生活类","slug":"生活类","permalink":"http://yoursite.com/categories/生活类/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"一年了","slug":"一年了","date":"2020-02-24T16:49:04.000Z","updated":"2020-02-24T16:50:53.000Z","comments":true,"path":"2020/02/25/一年了/","link":"","permalink":"http://yoursite.com/2020/02/25/一年了/","excerpt":"","text":"时间飞逝，一眨眼，一年过去了。 好久没来，好久没写，其实心里一直想着，总要记录点什么，可是总是没能抽出时间过来。 有空再写吧，晚安。 Mood挺好的。 Weather晴天。 Date2020年2月24日 晚上 完结","categories":[{"name":"生活类","slug":"生活类","permalink":"http://yoursite.com/categories/生活类/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"Github&Gitee使用教程","slug":"Github&Gitee使用教程","date":"2019-05-13T03:37:35.000Z","updated":"2019-05-13T03:38:25.000Z","comments":true,"path":"2019/05/13/Github&Gitee使用教程/","link":"","permalink":"http://yoursite.com/2019/05/13/Github&Gitee使用教程/","excerpt":"","text":"前言：注册GitHub有一段时间了，之前有按照教程操作过，不过后来一段时间不用又不熟练了。以至于后期突然使用时出现一些错误，导致本地文件一直提交不了。今天又熟悉了一次，这里做个笔记，以至于后面在忘记可以回顾一下。 一、操作前准备 Github环境搭建 配置共存Github/Gitee环境共存Github/Gitee环境，需要切换全局的 user.name 和 user.email git config - -global - -list（先查看变量）git config - -global user.name “账户名” （再修改变量）git config - -global user.email “邮箱” 二、Github/Gitee部署详细步骤【无仓库：新建远程仓库、初始化本地仓库、两者建立连接、添加并部署】 创建仓库，勾选上RENAME name -&gt; description -&gt; public -&gt; Init -&gt; create “+” -&gt; 介绍 -&gt; 使用Readme文件初始化这个仓库 -&gt; 创建 git init （初始化本地仓库） git add .（有空格） git status（可查看代码的状态） git commit -m “说明”（把文件提交的本地仓库） git remote add origin [url]（连接远程仓库，这个为新建的仓库地址） git pull - -rebase origin master （本地仓库为空，远程仓库不为空，需要pull合并同步，这里–为“双杠”） git push origin master（部署） 【有本地仓库/克隆操作（已建立连接）：在仓库文件夹下进行以下操作】 改动文件后 ↓ git add . git status git commit -m “说明” git push origin master 三、常用命令 git status git add . git commit -m “说明” git push origin master git clone [url] git pull （拉去远程库更新本地库） 2020年4月11日 下午Guzhz","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Hexo的使用","slug":"Hexo的使用","date":"2019-05-09T03:37:35.000Z","updated":"2019-05-09T03:38:25.000Z","comments":true,"path":"2019/05/09/Hexo的使用/","link":"","permalink":"http://yoursite.com/2019/05/09/Hexo的使用/","excerpt":"","text":"前言：Hexo是一个主题框架，用于搭建博客，这里做个笔记，以至于后面忘记了可以回顾一下如何操作。 一、详细搭建参考 搭建参考一搭建参考二markdown语法参考主题推荐 二、域名的绑定与解绑绑定：免费一年的域名网 1、在myblog\\source（source目录下的文件为源文件)目录下新建CNAME(无后缀)2、把域名写进去即可，www加不加都行。 解绑： 1、只生效一次的解绑方法：直接删除github项目上的CNAME文件，但是更新后重新部署后又会生成2、永久解绑方法：删除主题source目录下的CNAME，删除/清空source目录下的CNAME文件后重新部署，setting里删除手动指定的域名。 三、我的博客详细分类操作步骤： 1. 在项目的根目录下（myblog) 2. 右键打开：Git Bash 3. 新文章 ：myblog\\source\\_posts 下编写md文件 hexo g (生成) hexo s (本地浏览) hexo d (部署到github) 博客一：VScode、有道云笔记 myblog → 主目录 myblog_bak → 主目录备份 Picture-bed → 图床仓库 博客二：有道云笔记编写，VScode编辑 虚拟机桌面的“blog”文件 已同步到坚果云 test = &gt; 测试仓库 blog\\source\\_posts =&gt; 源文件 blog\\themes\\diaspora\\source\\img =&gt; 图库(图床)，不需要额外的图床 source -&gt; MD File =&gt; md文件 2020年4月11日 凌晨Guzhz","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]}]}