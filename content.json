{"meta":{"title":"Guzhz's House","subtitle":"Simply to do something.","description":null,"author":"Guzhz","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-03-26T17:19:54.435Z","updated":"2019-03-26T17:19:54.435Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2020-08-04T10:03:21.000Z","updated":"2020-08-04T10:04:01.477Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"","date":"2019-03-26T12:47:50.243Z","updated":"2019-03-26T12:47:50.243Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VUE学习（八）：axios使用","slug":"VUE学习（八）：axios使用","date":"2020-08-04T08:49:04.922Z","updated":"2020-08-04T07:09:16.221Z","comments":true,"path":"2020/08/04/VUE学习（八）：axios使用/","link":"","permalink":"http://yoursite.com/2020/08/04/VUE学习（八）：axios使用/","excerpt":"","text":"axios：网络请求1、安装：npm install axios –save2、基本使用import axios from 'axios' axios(&#123; //没有参数 //httpbin.org url: 'http://152.136.185.210:8000/api/z8/home/multidata', method: 'get' //默认是post &#125;).then(res =&gt;&#123; console.log(res) &#125;) axios(&#123; url: 'http://152.136.185.210:8000/api/z8/home/data', params: &#123; //有参数 type: 'pop', page: 1 &#125; &#125;).then(res =&gt; &#123; console.log(res) &#125;) 3、并发请求（改使用全局配置）axios.defaults.baseURL = 'http://152.136.185.210:8000/api/z8' axios.defaults.timeout = 5000 // 2.axios并发请求 axios.all([axios(&#123; //axios.all() url: '/home/multidata' &#125;), axios(&#123; url: '/home/data', params: &#123; type: 'pop', page: 4 &#125; &#125;)]) // .then(results =&gt; &#123; // console.log(results[0]); // console.log(results[1]); // &#125;) // 另一种写法 .then(axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2); &#125;)) 4、创建独立实例（解决多个全局配置问题）//创建实例并配置全局 const instance1 = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //使用实例 instance1(&#123; url: '/home/multidata' &#125;).then(res =&gt; &#123; console.log(res); &#125;) //使用实例 instance1(&#123; url: '/home/data', params: &#123; type: 'pop', page: 1 &#125; &#125;).then(res =&gt; &#123; console.log(res); &#125;) 5、封装模块network -&gt; request.js 方法一：回调函数方式（config, success, failure）//request.js //导出实例，为了保证拓展性，就不使用default import axios from 'axios' export function request(config, success, failure) &#123; //1、创建实例 const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //2、真正发送网络请求，config为请求的数据 instance(config) .then(res =&gt; &#123; success(res) &#125;) .catch(err =&gt; &#123; failure(err) &#125;) &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; url: '/home/multidata' &#125;, res =&gt; &#123; console.log(res); &#125;, err =&gt; &#123; console.log(err); &#125;) 方法二：回调函数方式（config） -&gt; (baseConfig, function(),function)import axios from 'axios' export function request(config) &#123; //1、创建实例 const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //2、真正发送网络请求，config为请求的数据 instance(config.baseConfig) .then(res =&gt; &#123; config.success(res) &#125;) .catch(err =&gt; &#123; config.failure(err) &#125;) &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; baseConfig: &#123; url: '/home/multidata' &#125;, success: function (res) &#123; console.log(res); &#125;, failure: function (err) &#123; console.log(err); &#125; &#125;) 方法三：使用Promise方式import axios from 'axios' export function request(config) &#123; return new Promise((resolve, reject) =&gt; &#123; const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) instance(config) .then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; url: '/home/multidata' &#125;).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 方法四：优化Promise方式import axios from 'axios' export function request(config) &#123; const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) return instance(config) //因为本身返回的就是Promise &#125; //使用 import &#123;request&#125; from \"./network/request\"; request(&#123; url: '/home/multidata' &#125;).then(res =&gt; &#123; console.log(res); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 6、拦截器的使用export function request(config) &#123; const instance = axios.create(&#123; baseURL: 'http://152.136.185.210:8000/api/z8', timeout: 5000 &#125;) //axios请求拦截 //一般拦截：不符合服务器的要求的信息需要修改、在界面中显示请求图标结束后取消掉、某些请求需要特殊信息token instance.interceptors.request.use(config =&gt; &#123; console.log(config); //成功走这里 return config //一定要放行 &#125;, err =&gt; &#123; //失败走这里，一般不会走这里 console.log(err); &#125;) //响应拦截 instance.interceptors.response.use(res =&gt; &#123; console.log(res); return res.data //只需要取出data &#125;, err =&gt; &#123; console.log(err); &#125;) return instance(config) &#125; 2020年08月4日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（七）：VueX的使用","slug":"VUE学习（七）：VueX的使用","date":"2020-08-02T17:49:04.000Z","updated":"2020-08-03T16:50:53.000Z","comments":true,"path":"2020/08/03/VUE学习（七）：VueX的使用/","link":"","permalink":"http://yoursite.com/2020/08/03/VUE学习（七）：VueX的使用/","excerpt":"","text":"VueX：管理组件间的共享资源1、安装和使用：npm install vuex@3.0.1 –save 1、新建store包，放在index.js里 import Vue from 'vue' import Vuex from 'vuex' //安装插件 Vue.use(Vuex) //创建对象 const store = new Vuex.Store(&#123; state: &#123; counter: 1000 &#125;, mutations: &#123; //记录处理记录 &#125;, actions: &#123; //异步处理，对接后端 &#125;, getters:&#123; &#125;, modules: &#123; &#125; &#125;) //导出 export default store 2、main.js，通过vue使用vuex插件 import store from './store' //导入对应的包即可 Vue.prototype.$store = store 3、使用共享数据（不建议直接修改） &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;/h2&gt; 4、安装devtools浏览器插件（谷歌商店）进行调试 //定义处理方法（这个方法经过vuex插件 mutations: &#123; //记录处理记录 increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;, //通过提交的方式，字符串参数为方法名 methods: &#123; add() &#123; this.$store.commit('increment') &#125;, minus() &#123; this.$store.commit('decrement') &#125; &#125; 2、state：管理状态 单一状态树，即vuex本身不建议创建多个，只需要一个即可，方便管理 3、getters：计算属性 | 函数参数：state、(getters) 可以理解为计算属性，对数据的复杂处理，然后按照属性的方式进行调用 getters:&#123; powerCounter(state) &#123; return state.counter * state.counter &#125; &#125;, 妙用：需要对已有的方法进行进一步处理，可以再写个方法传getters进去，然后调用指定的方法进行处理 more20stu(state) &#123; return state.students.filter(s =&gt; s.age&gt;20) &#125;, more20stuLength(state, getters) &#123; //只接受state和getters，两个参数 return getters.more20stu.length; &#125; 需求：调动getters的方法时，需要指定参数 思想：因为getters不接受自定义参数，则可以通过嵌套函数，由函数处理传进来的参数，然后return回去 &lt;h2&gt;超过指定年龄的学生：&#123;&#123;$store.getters.moreAgeStu(17)&#125;&#125;&lt;/h2&gt; //17就传到function里面了 moreAgeStu(state) &#123; return function (age) &#123; return state.students.filter(s =&gt; s.age &gt; age); &#125; &#125; 4、mutations：| 函数参数：state、%| 调用：commit 1、修改state参数时使用 2、传递参数 //App.vue addStudent() &#123; const stu = &#123;id: 5, name: 'eee', age: 111&#125; this.$store.commit('addStudent',stu) &#125; addStudent(state, stu) &#123; state.students.push(stu) &#125; 3、提交风格（传对象） addCount(count) &#123; //直接传数字 // this.$store.commit('incrementCount',count) //传对象 this.$store.commit(&#123; type: 'incrementCount', count &#125;) &#125;, //接收的时候也是对象，需要在对象里取出对应的值，注意：传的type会自动查找指定函数 incrementCount(state,payload) &#123; console.log(payload); state.counter += payload.count; &#125;, 4、响应式系统：需要提前初始化好才会是响应式；如果动态添加属性，则不会响应式（观察者模式） 解决： &gt; 添加： 响应式：Vue.set(state.info, 'key', 'value') //对象 &gt; 删除： 非响应式：delete state.info.age 响应式：Vue.delete(state.info, 'age') 5、类型常量（解决方法名可能写错的问题） //新建mutation-types.js，统一常量名然后导出 export const INCREMENT = 'increment' import &#123;INCREMENT&#125; from \"./store/mutations-types\"; //Vue.vue使用 add() &#123; this.$store.commit(INCREMENT) &#125;, //index.js使用 [INCREMENT](state) &#123; //用括号包起来 state.counter++ &#125;, 5、actions：异步操作 | 函数参数：context，payload | 调用：dispatch原理：把异步请求放在actions里，在actions的方法里通过commit请求mutations，vue通过dispatch调用actions的方法 //按钮点击修改 updateInfo() &#123; this.$store.dispatch('aUpdateInfo','我是payload') &#125; //来到actions actions: &#123; //异步处理，对接后端 //上下文，理解为store对象 aUpdateInfo(context,payload) &#123; setTimeout(() =&gt; &#123; console.log(payload); context.commit('updateInfo') &#125;, 1000) &#125; &#125;, //来到mutations updateInfo(state) &#123; state.info.name = 'hhh' &#125; 高操作：点击按钮后，来到actions发送请求，然后放回Promise对象，对象存放回调信息，然后在一开始的按钮函数里then()拿出信息 //按钮 updateInfo() &#123; //需求：请求完了，要返回一个回调信息 new Promise this.$store .dispatch('aUpdateInfo','我是携带的信息') .then(res =&gt; &#123; console.log('----------------------') console.log(res); &#125;) &#125; //回调 aUpdateInfo(context,payload) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(payload); context.commit('updateInfo') resolve('回调信息') &#125;, 1000) &#125;) &#125; 我的payload 我是携带的信息 ---------------------- 回调信息 6、modules：嵌套子模块modules: &#123; a: moduleA &#125; const moduleA = &#123; state: &#123; name: 'zhangsan', &#125;, mutations: &#123; updateName(state, payload) &#123; //使用方法一样： this.$store.commit('updateName','lisi') state.name = payload &#125; &#125;, getters: &#123; //使用方法一样：&#123;&#123;$store.getters.fullName&#125;&#125; fullName(state) &#123; return state.name + '1111' &#125;, fullName2(state, getters) &#123; return getters.fullName + '2222' &#125;, fullName3(state, gettters, rootState) &#123; //多了一个参数，可以拿到根的state return gettters.fullName2 + rootState.counter &#125; &#125;, actions: &#123; aUpdateName(context) &#123; //context不再是store对象，而是指本模块，commit也只能是自己的 setTimeout(() =&gt; &#123; context.commit('updateName','wangwu') &#125;,1000) &#125; &#125; &#125; 7、文件目录组织1、对象的解构const obj = &#123; name: 'hh', age: 18, height: 1.88, address: '洛杉矶' &#125; const &#123;name,height,age&#125; = obj; //不用按顺序，按需取出 cosole.log(name) //直接使用 2、拆分store |--modules |--moduleA.js |mutations.js |mutations-types.js |getters.js |actions.js |index.js 2020年08月4日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（六）：Promise的使用","slug":"VUE学习（六）：Promise的使用","date":"2020-07-31T17:49:04.000Z","updated":"2020-08-01T16:50:53.000Z","comments":true,"path":"2020/08/01/VUE学习（六）：Promise的使用/","link":"","permalink":"http://yoursite.com/2020/08/01/VUE学习（六）：Promise的使用/","excerpt":"","text":"Promise的使用1. Promise的基本使用&lt;script&gt; //Promise：优雅的解决嵌套请求问题，使代码看起来更清晰，即链式编程 //什么情况下会用到Promise？ //有异步操作时，用Promise对这个异步操作进行封装 new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; //成功的时候执行，然后走then // resolve('hello world') //失败则调用reject reject('error message') &#125;, 1000) &#125;).then((data) =&gt; &#123; // 拿到数据，然后处理 console.log(data); console.log(data); console.log(data); console.log(data); console.log(data); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;) &lt;/script&gt; 2. Promise的另一种写法&lt;script&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve('hello resolve') reject('error message') &#125;,1000) &#125;).then(data =&gt; &#123; console.log(data); &#125;, err =&gt; &#123; console.log(err); &#125;) &lt;/script&gt; 3. Promise的链式调用&lt;script&gt; new Promise((resolve, reject) =&gt; &#123; //1 setTimeout(() =&gt; &#123; resolve() &#125;,1000) &#125;).then(() =&gt; &#123; console.log('第一次处理'); return new Promise((resolve, reject) =&gt; &#123; //2 setTimeout(() =&gt; &#123; resolve() &#125;,1000) &#125;) &#125;).then(() =&gt; &#123; console.log('第二次处理'); return new Promise((resolve, reject) =&gt; &#123; //3 setTimeout(() =&gt; &#123; resolve() &#125;,1000) &#125;) &#125;).then(() =&gt; &#123; console.log(\"第三次处理\"); &#125;) &lt;/script&gt; 4. Promise的简洁写法&lt;script&gt; //需求：aaa-&gt;自己处理10行 //处理：aaa111-&gt;自己处理10行 //处理：aaa111222 -&gt; 自己处理 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('aaa') &#125;,1000) &#125;).then(res =&gt; &#123; //1 console.log(res + '第一次处理'); //2，对结果进行第一次处理 return Promise.resolve(res + '111') &#125;).then(res =&gt; &#123; console.log(res + '第二次处理'); return Promise.resolve(res + '222') &#125;).then(res =&gt; &#123; console.log(res + \"第三次处理\"); &#125;).catch(err =&gt; &#123; console.log(err); &#125;) &lt;/script&gt; //&gt; return new Promise((resolve, reject) =&gt; &#123; resolve(res + '111') &#125;) //&gt; return Promise.resolve(res + '111') //reject同理 //&gt; return res + '111' //throw 'err message' 5. Promise的all方法的使用&lt;script&gt; //处理多个请求的结果，传入可迭代的容器：数组，数组存放请求 //伪代码 Promise.all([ new Promise((resolve, reject) =&gt; &#123; $ajax([ url: 'url1', success: function (data) &#123; resolve(data) &#125; ]) &#125;), new Promise((resolve, reject) =&gt; &#123; $ajax([ url: 'url2', success: function (data) &#123; resolve(data) &#125; ]) &#125;) ]).then(results =&gt; &#123; //这里的参数也是数组 console.log(results[0]); console.log(results[1]); &#125;) &lt;/script&gt; //模拟使用 &lt;script&gt; //处理多个请求的结果，传入可迭代的容器：数组，数组存放请求 Promise.all([ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123;name: 'result1', age: 18&#125;) &#125;,2000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"result2\") &#125;,1000) &#125;) ]).then(results =&gt; &#123; //这里的参数也是数组 console.log(results[0].age); console.log(results[1]); &#125;) &lt;/script&gt; 2020年08月4日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（五）：vue-router的使用","slug":"VUE学习（五）：vue-router的使用","date":"2020-07-29T15:49:04.000Z","updated":"2020-07-29T16:50:53.000Z","comments":true,"path":"2020/07/29/VUE学习（五）：vue-router的使用/","link":"","permalink":"http://yoursite.com/2020/07/29/VUE学习（五）：vue-router的使用/","excerpt":"","text":"一、vue-router的使用1、使用方法 1、components文件夹新建vue文件； 2、index.js添加映射路径（导入组件）； 3、App.vue使用组件 2、改hash路径为history路径 index.js -&gt; Router对象：mode: ‘history’, 3、router-link的使用&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;我是app组件&lt;/h2&gt; &lt;!--默认a标签，tag指定标签，replace：replaceState（禁止来回返回）--&gt; &lt;router-link to=\"/home\" tag=\"button\" replace&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\" tag=\"button\" replace&gt;关于&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 4、router-link-active//当&lt;router-link&gt;对应的路由匹配成功时，会自动给元素设置一个router-link-active的class，可以对这个类进行样式设置 .router-link-active &#123; color: red; &#125; //修改默认的名称：index.js，使用linkActiveClass: 'active'，则会修改陈active .active &#123; color: red; &#125; 5、绑定方法，使用this.$router.push(‘/home’)跳转页面&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h2&gt;我是app组件&lt;/h2&gt; &lt;button @click=\"clickHome\"&gt;首页&lt;/button&gt; &lt;button @click=\"clickAbout\"&gt;关于&lt;/button&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; export default &#123; name: 'App', methods: &#123; clickHome() &#123; this.$router.replace('/home').catch(err =&gt; &#123;&#125;); //区别push console.log('clickHome'); &#125;, clickAbout() &#123; this.$router.replace('/about').catch(err =&gt; &#123;&#125;); console.log('clickAbout'); &#125; &#125; &#125; 6、$router、$route、routes的区别 1、$router：代指Router对象，使用：this.$router； 2、$route：指当前正在活跃(使用)的路由：通过this.$route.params.参数，可以拿到参数 3、routes：index.js路由管理里面，Router对象里的属性，也是映射管理； 7、动态路由（路由传参）&lt;router-link v-bind:to=\"'/user/'+uId\"&gt;用户&lt;/router-link&gt; data() &#123; return &#123; uId: 'ss' &#125; &#125;, ------User.vue------ &lt;template&gt; &lt;div&gt; &lt;h2&gt;我是用户界面&lt;/h2&gt; &lt;p&gt;我是用户的相关信息，略略略&lt;/p&gt; &lt;h2&gt;&#123;&#123;userId&#125;&#125;&lt;/h2&gt; &lt;!--展示--&gt; &lt;h2&gt;&#123;&#123;$route.params.uId&#125;&#125;&lt;/h2&gt; &lt;!--直接拿--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: \"user\", computed: &#123; userId() &#123; return this.$route.params.uId //获得参数 &#125; &#125; &#125; &lt;/script&gt; 8、路由的懒加载 把不同的路由拆分为多个js文件，不一起打包，用到的时候再加载。 /*懒加载*/ const Home = () =&gt; import('../components/Home') const About = () =&gt; import('../components/About') const User = () =&gt; import('../components/User') 在index.js里，把之前直接引入的方式，改为声明为一个变量（常量），用到时候再引用，即加载 9、嵌套子路由 1、新建vue：HomeNews.vue/HomeMessage.vue 2、配置子路由映射children[{},{}] ，不需要”/“ 3、父vue模板，也加上 4、注意：router-link to=”完整路径” &#123; path: '/home', component: Home, children: [ &#123; path: 'news', //不需要加 '/' component: HomeNews &#125;, &#123; path: 'message', //不需要加 '/' component: HomeMessage &#125; ] &#125;, &lt;template&gt; &lt;div&gt; &lt;h2&gt;我是首页&lt;/h2&gt; &lt;p&gt;我是首页内容，嘻嘻嘻&lt;/p&gt; &lt;router-link to=\"/home/news\"&gt;新闻&lt;/router-link&gt; &lt;router-link to=\"/home/message\"&gt;消息&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; 10、路由参数传递1. 方式一：restful风格&lt;router-link v-bind:to=\"'/user/'+uId\"&gt;用户&lt;/router-link&gt; &#123; path: '/user/:uId', component: User &#125;, &#123;&#123;$route.params.uId&#125;&#125; 2. 方式二：query传递&lt;router-link v-bind:to=\"&#123;path: '/profile', query: &#123;name: 'guzhz', age: 18&#125;&#125;\"&gt;档案&lt;/router-link&gt; &#123;&#123;$route.query.name&#125;&#125; &#123;&#123;$route.query.age&#125;&#125; 11、全局导航守卫1. 生命周期的方式实现created() &#123; console.log('组件被创建的时候回调'); document.title = '首页'; &#125;, mounted() &#123; console.log('dom被挂载的时候回调'); &#125;, updated() &#123; console.log('界面刷新则回调'); &#125; 2. 前置钩子：全局导航守卫（cil4里则用to.name即可）//router调用beforeEach，参数是一个函数 //matched[0],解决嵌套的时候undefined的问题 router.beforeEach((to, from ,next) =&gt; &#123; document.title = to.matched[0].meta.title; next(); //必须调用，才能下一步 &#125;) //在各自的route里面添加meta(元数据，描述数据的数据) &#123; path: '/user/:uId', component: User, meta: &#123; title: '用户' &#125; &#125;, 3. 补充：后置钩子（没有next）router.afterEach((to,from) =&gt; &#123; console.log('after'); &#125;) 4. 补充：独享钩子//对指定的route配置 beforeEnter: (to, from, next) =&gt; &#123; console.log('beforeEnter'); next(); &#125;, 5. 补充：组件补充12、keep-alive的使用：提供组件缓存&lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; //有缓存activated()和deactivated()才能使用 1. 嵌套子组件引发问题 问题：嵌套的子组件由于缺省设定的问题，导致切换回来的时候，子组件永远是缺省的那个 思路：去掉缺省值，动态添加默认显示的子组件，同时记录路径，使切换回来的时候仍然是切换走的时候那个子组件 //index.js的Home的route去掉写死的缺省值 children: [ // &#123; // path: '', // redirect: 'news' // &#125;, &#123; path: 'news', //不需要加 '/' component: HomeNews &#125;, &#123; path: 'message', //不需要加 '/' component: HomeMessage &#125; ], //Home.vue，data()添加一个路径变量记录路径：path data() &#123; return &#123; message: '你好啊', path: '/home/news' &#125; &#125;, //Home.vue配合activated()活跃时动态创建，beforeRouteLeave()离开时记录path activated() &#123; console.log('activated'); this.$router.push(this.path).catch(err =&gt; &#123;&#125;); &#125;, deactivated()&#123; //这个方法来不及获取path路径，所以不能使用 &#125; beforeRouteLeave(to, from, next) &#123; this.path = this.$route.path; next(); &#125; 2. 排除个别不需要缓存&lt;keep-alive exclude=\"Profile,User\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 二、vue-router底部栏项目知识点1. 目录文件管理与逻辑分离 1、共同的vue放在components里 2、主要视图放在views里，然后详细页面再分包 3、App.vue如果太多代码，还可以继续抽离 4、大组件继续拆分小组件，用插槽 5、div(设置属性)包裹插槽，可以避免属性被覆盖 2. 获得活跃路径和动态修改样式//父传子&lt;tab-bar-item path=\"/profile\" activeColor=\"blue\"&gt; props: &#123; path: String, activeColor: &#123; type: String, default: 'deeppink' &#125; &#125;, computed: &#123; isActive() &#123; //获得活跃路径 return this.$route.path.indexOf(this.path) !== -1; &#125;, activeStyle() &#123; return this.isActive ? &#123;color: this.activeColor&#125; : &#123;&#125; &#125; &#125;, 3. 点击跳转&lt;div class=\"tab-bar-item\" @click=\"itemClick\"&gt; //父传子，path methods: &#123; itemClick() &#123; this.$router.push(this.path).catch(err =&gt; &#123;&#125;); &#125; &#125; 4. 文件路径起别名 1、webpack.base.conf.js修改 &gt; resolve: &#123; &gt; extensions: ['.js', '.vue', '.json'], &gt; alias: &#123; &gt; '@': resolve('src'), &gt; 'assets': resolve('src/assets'), &gt; 'components': resolve('src/components'), &gt; 'views': resolve('src/views'), &gt; &#125; &gt; &#125;, &gt; 2、使用 &gt; //如果是import from 的路径则直接使用别名 &gt; import TabBar from \"components/tabbar/TabBar\"; &gt; import TabBarItem from \"components/tabbar/TabBarItem\"; &gt; &gt; //src引用，则需要在别名前面加“~” &gt; &lt;img slot=\"item-icon\" src=\"~assets/img/tabbar/category.svg\" alt=\"\"&gt; &gt; 2020年08月4日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（四）：脚手架和箭头函数的使用","slug":"VUE学习（四）：脚手架和箭头函数的使用","date":"2020-07-28T15:49:04.000Z","updated":"2020-07-28T16:50:53.000Z","comments":true,"path":"2020/07/28/VUE学习（四）：脚手架和箭头函数的使用/","link":"","permalink":"http://yoursite.com/2020/07/28/VUE学习（四）：脚手架和箭头函数的使用/","excerpt":"","text":"一、脚手架2/3的使用1. 安装cil3：npm install @vue/cli -g 拉取2.x：npm install @vue/cli-init -g 2. 初始化cli2：vue init webpack xxxruntime-compiler和runtime-only的区别 runtime-compiler：template -&gt; ast -&gt; render -&gt; vdom -&gt; UI（） runtime-only：render -&gt; vdom -&gt; UI （性能高，代码量少） 1、vue文件的template不需要解析了 2、因为被vue-template-compiler解析成render函数了 3. 初始化cil3：vue create xxx 可视化界面 &gt; vue ui cil3把许多配置文件隐藏起来了，需要配置则在根目录下创建： vue.config.js（固定名字，红色） git commit -m “添加文件”（绿色） 二、箭头函数的使用1. 基本使用const sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; console.log(sum(1, 2)); 2. 只有一个参数，括号可以省略const power = num =&gt; &#123; return num * num; &#125; console.log(power(100)); 3. 内容只有一行代码const mul = (num1,num2) =&gt; num1 * num2; console.log(mul(20, 20)); 4. 没有参数，没有返回值const print = () =&gt; console.log('hello'); print() 5. 箭头函数的this的使用问题：箭头函数中的this是如何查找的？ 答案：向外层作用域查找，一层层查找this，知道有this的定义 const obj = &#123; aaa() &#123; setTimeout(function () &#123; setTimeout(function () &#123; console.log(this); //window，这种无参格式都是window &#125;); setTimeout(() =&gt; &#123; console.log(this); //上一层是function()，所以this也是window &#125;); &#125;); setTimeout(() =&gt; &#123; setTimeout(function () &#123; console.log(this); //window &#125;); setTimeout(() =&gt; &#123; console.log(this); //上一层没有，再上一层是aaa，所以this是aaa &#125;) &#125;) &#125; &#125;; 2020年08月4日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（三）：webpack详解","slug":"VUE学习（三）：webpack详解","date":"2020-07-27T15:49:04.000Z","updated":"2020-07-27T16:50:53.000Z","comments":true,"path":"2020/07/27/VUE学习（三）：webpack详解/","link":"","permalink":"http://yoursite.com/2020/07/27/VUE学习（三）：webpack详解/","excerpt":"","text":"一、传统的模块化1. 导入导出//commonJS 导出：module.exports = &#123;add&#125; 导入：const &#123;add&#125; = require('./mathUtils.js'); //es6 导出：export const name = '哈哈哈'; 导入：import &#123;name&#125; from './info'; 2. 打包 webpack ./src/main.js ./dist/bundle.js 二、webpack初体验1. 自定义打包命令：webpack（配置固定路径）//npm init 生成 package.json const path = require('path'); // 需要用到node依赖path module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname,'dist'), //绝对路径 filename: 'bundle.js' &#125; &#125; 2、映射路径为局部命令：npm run build1. 由于实际开发中大多数是用到局部webpack版本，则需要使用局部webpack 2. 使用局部命令 (1)修改package.json里的scripts，添加自定义命令 \"scripts\": &#123; \"build\": \"webpack\" &#125;, 3、配置开发环境 npm install webpack@3.6.0 –save-dev 安装开发环境的webpack，局部命令则优先去node_modules里面找webpack包 三、webpack的各种加载器 webpack官网：https://www.webpackjs.com/loaders 1. 依赖css main.js依赖：require(‘./css/normal.css’); npm install css-loader@2.0.2 –save-dev npm install style-loader –save-dev //同时需要样式加载器 修改webpack.config.js module: &#123; rules: [ &#123; test: /\\.css$/, // 使用多个loader，是从右向左读，先css在style use: ['style-loader','css-loader'] &#125; ] &#125; 2. 依赖less npm install –save-dev less-loader@4.1.0 less 2. &#123; test: /\\.less$/, use: [&#123; loader: \"style-loader\" // creates style nodes from JS strings &#125;, &#123; loader: \"css-loader\" // translates CSS into CommonJS &#125;, &#123; loader: \"less-loader\" // compiles Less to CSS &#125;] &#125; 3.1 依赖图片 npm install –save-dev url-loader@1.1.2 2. rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; //图片大小，小于limit时，会转化成base64形式并直接使用 limit: 8192 &#125; &#125; ] &#125; ] 3.2 依赖图片 -&gt; 依赖文件 如果大于limit，需要用到file-loader但不需要配置 npm install file-loader@3.0.1 –save-dev 问题一：自动生成的图片在dist文件夹里，而写的路径在img里解决：需要配置图片路径，自动拼接dist/才能显示 webpack.config.js： output: &#123; path: path.resolve(__dirname,'dist'), //绝对路径 filename: 'bundle.js', publicPath: 'dist/' &#125;, //后续需要把index.html放到dist中，就不要配置了 问题二：解决文件命名问题 options: &#123; limit: 8192, name: 'img/[name].[hash:8].[ext]' &#125; 4. ES6转ES5npm install –save-dev babel-loader@7 babel-core babel-preset-es2015 &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125; &#125; &#125; 改： options: &#123; presets: ['es2015'] &#125; 四、依赖.vue npm install vue –save（不加-dev，是因为开发和发布都需要用） 配置 resolve: &#123; //起别名，指定路径 alias: &#123; 'vue$': 'vue/dist/vue.esm.js' //(runtime-compiler 而不使用 runtime-only（不能编译template）) &#125; &#125; resolve: &#123; //去后缀 extensions: ['.js','.css','.vue'], 五、index.js代码抽离1. 对象化&lt;div id=\"app\"&gt; &lt;/div&gt; 2. 写成对象 const App = &#123; template: ` &lt;div&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data() &#123; return &#123; message: 'Hello,Webpack', name: '哈哈哈' &#125; &#125;, methods: &#123; btnClick() &#123;&#125; &#125; &#125;; 3. new Vue(&#123; el: '#app', //编译后，会直接把div替换掉 template: '&lt;App/&gt;', //使用 components: &#123; //注册 App &#125; &#125;); 2. 文件化 新建vue/app.js,把App代码拿过去，用导入导出的方式使用 3. 演变成：使用app.vue 安装npm install –save-dev vue-loader vue-template-compiler 配置webpack.config.js &#123; test: /\\.vue$/, use: ['vue-loader'] &#125; // webpack.config.js const VueLoaderPlugin = require('vue-loader/lib/plugin') module.exports = &#123; // ... plugins: [ new VueLoaderPlugin() ] &#125; 六、插件的使用1. 版权插件const webpack = require('webpack'); plugins: [ new VueLoaderPlugin(),new webpack.BannerPlugin('最终版权归Guzhz所有') ] 2. 打包生成index.html到dist中的插件安装：npm install html-webpack-plugin –save-dev const HtmlWebpackPlugin = require('html-webpack-plugin'); new HtmlWebpackPlugin(&#123; template: 'index.html' //不在需要手动引入script（删除） &#125;) 注意：删除配置的 publicPath: &#39;dist/&#39; 3. 丑化插件uglifyjs安装：npm install uglifyjs-webpack-plugin@1.1.1 –save-dev const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin'); new UglifyjsWebpackPlugin() 4. 搭建本地服务器（热部署）安装：webpack-dev-server@2.9.1 devServer: { contextBase: &apos;./dist&apos;, inline: true //实时监听 } 把上面注释掉，配置webpack.json命令&quot;dev&quot;: &quot;webpack-dev-server --open&quot; 启动：npm run dev 部署：npm run build 5. 合并插件：环境的分离安装：npm install webpack-merge@4.1.5 –save-dev prod: const UglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin'); const WebpackMerge = require('webpack-merge'); const baseConfig = require('./base.config'); module.exports = WebpackMerge(baseConfig, &#123; plugins: [ new UglifyjsWebpackPlugin() ] &#125;); dev: const WebpackMerge = require('webpack-merge'); const baseConfig = require('./base.config'); module.exports = WebpackMerge (baseConfig, &#123; devServer: &#123; contextBase: './dist', inline: true //实时监听 &#125; &#125;); 配置： package.json \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config ./build/prod.config.js\", \"dev\": \"webpack-dev-server --open --config ./build/dev.config.js\" &#125;, path: path.resolve(__dirname,'../dist'), //绝对路径 2020年08月4日 中午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（二）：组件化开发","slug":"VUE学习（二）：组件化开发","date":"2020-07-26T15:49:04.000Z","updated":"2020-07-26T16:50:53.000Z","comments":true,"path":"2020/07/26/VUE学习（二）：组件化开发/","link":"","permalink":"http://yoursite.com/2020/07/26/VUE学习（二）：组件化开发/","excerpt":"","text":"一、组件使用1.1、组件化的基本使用（Vue.extend）&lt;div id=\"app\"&gt; //使用 &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt; &lt;/div&gt; &lt;hr&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //创建组件构造器对象 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;我的内容&lt;/p&gt; &lt;p&gt;我的内容，嘻嘻嘻&lt;/p&gt; &lt;/div&gt;` &#125;); //注册为全局组件 Vue.component('my-cpn', cpnC) const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125; &#125;) &lt;/script&gt; 底层实现原理就是通过，Vue.extend实现的 1.2、全局组件和局部组件&lt;script&gt; //在外部则为全局组件，多个vue对象都可用 const cpnC = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;哈哈哈哈&lt;/p&gt; &lt;/div&gt; ` &#125;); //全局注册 // Vue.component('cpn',cpnC); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, //局部注册 components: &#123; cpn: cpnC &#125; &#125;); //多个Vue对象可以使用全局组件 const app2 = new Vue(&#123; el: '#app2' &#125;) &lt;/script&gt; 1.3、父组件和子组件&lt;script&gt; const cpnC1 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;子组件&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;/div&gt; ` &#125;); const cpnC2 = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;父组件&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;cpn1&gt;&lt;/cpn1&gt; &lt;/div&gt; `, components: &#123; //C2注册C1 cpn1: cpnC1 &#125; &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, components: &#123; //root组件使用C2(同时使用了C1) cpn2: cpnC2, //root组件也使用C1，则也要注册 cpn1: cpnC1 &#125; &#125;) &lt;/script&gt; 1.4、组件的语法糖注册方式（Vue.component）//开发中也是用这种方式，但底层还是使用Vue.extend &lt;script&gt; //全局创建并注册，名字叫cpn1 Vue.component('cpn1',&#123; template: ` &lt;div&gt; &lt;h2&gt;语法糖写法&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;/div&gt; ` &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, //局部创建并注册，名字叫cpn2 components: &#123; 'cpn2': &#123; template: ` &lt;div&gt; &lt;h2&gt;局部组件语法糖写法&lt;/h2&gt; &lt;h2&gt;哈哈哈&lt;/h2&gt; &lt;/div&gt; ` &#125; &#125; &#125;) &lt;/script&gt; 1.5、组件模板的分离写法（开发中使用）1、分离创建 &lt;script type=\"text/x-template\" id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;html分离写法&lt;/p&gt; &lt;/div&gt; &lt;/script&gt; 2、template标签创建 &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;p&gt;template标签分离写法&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //创建并注册为全局 Vue.component('cpn',&#123; template: '#cpn' &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125; &#125;) &lt;/script&gt; 1.6、组件中的数据存放问题//函数、返回值为对象（存放属性） &lt;script&gt; Vue.component('cpn',&#123; template: '#cpn', data() &#123; return &#123; title: '我是大标题ccc' &#125; &#125; &#125;); &lt;/script&gt; 1.7、组件中的data为什么是函数&lt;div id=\"app\"&gt; &lt;!--创建三个实例对象，互不影响--&gt; &lt;!--所以设计data为函数。就是为了互不干扰--&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;当前计数：&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('cpn',&#123; template: '#cpn', data() &#123; return &#123; //每次都new一个对象 counter: 0 &#125; &#125;, methods: &#123; increment() &#123; this.counter++; &#125;, decrement() &#123; this.counter--; &#125; &#125; &#125;); const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125; &#125;) &lt;/script&gt; 二、组件通信2.1、父组件向子组件传递参数（props）//在引用cpn时传递参数并起名字，子组件用的props接收，然后就在template里使用 &lt;div id=\"app\"&gt; &lt;cpn :cmovies=\"movies\" :cmessage=\"message\"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;p&gt;&#123;&#123;cmovies&#125;&#125;&lt;/p&gt; &lt;h2&gt;&#123;&#123;cmessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; //父传子 props const cpn = &#123; template: '#cpn', // props: ['cmovies','cmessage'], //1 数组类型 props: &#123; // cmovies: Array, /*限定为数组*/ //2 限定类型 // cmessage: String cmovies: &#123; //3 限定类型同时设置默认值 type: Array, default() &#123; //高级版本必须以函数的形式返回 return [] &#125; &#125;, cmessage: &#123; type: String, default: 'aaaaaaaaaaa', required: true //必须传值 &#125; &#125; &#125; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊1', movies: ['aaa','bbb','ccc'] //定义数据 &#125;, components: &#123; cpn: cpn &#125; &#125;) &lt;/script&gt; 2.2、父传子（props中的驼峰标识）&lt;div id=\"app\"&gt; &lt;!--html不能识别驼峰，需要把cInfo - 改为c-info--&gt; &lt;cpn :c-info=\"info\" :child-my-message=\"message\"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;!--有多个参数需要显示，必须用东西包起来--&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;cInfo&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;childMyMessage&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; props: &#123; cInfo: &#123; type: Object, default() &#123; return &#123;&#125; &#125; &#125;, childMyMessage: &#123; type: String, default: '' &#125; &#125; 2.3、子传父（自定义事件$emit）&lt;div id=\"app\"&gt; &lt;!--不写参数默认传item过去--&gt; &lt;cpn @item-click=\"cpnClick\"&gt;&lt;/cpn&gt; //使用方法名绑定自己的方法 &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;!--有多个参数需要显示，必须用东西包起来--&gt; &lt;div&gt; &lt;!--通过自定义事件，把参数传下去--&gt; &lt;button v-for=\"item in categorys\" @click=\"btnClick(item)\"&gt; &#123;&#123;item.name&#125;&#125; &lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const cpn = &#123; template: '#cpn', data() &#123; return &#123; categorys: [ &#123;id: 'aaa',name: '热门推荐'&#125;, &#123;id: 'bbb',name: '手机数码'&#125;, &#123;id: 'ccc',name: '家用家电'&#125;, &#123;id: 'ddd',name: '电脑办公'&#125; ] &#125; &#125;, methods: &#123; //在这里把具体参数传给父组件 btnClick(item) &#123; //(方法名，参数) this.$emit('item-click',item); &#125; &#125; &#125; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, components: &#123; cpn &#125;, methods: &#123; //取得具体参数 cpnClick(item)&#123; console.log(item.name); &#125; &#125; &#125;) &lt;/script&gt; 2.4、父子组件通信案例&lt;div id=\"app\"&gt; &lt;cpn :number1=\"num1\" :number2=\"num2\" @dnumber1tofather=\"num1change\" @dnumber2tofather=\"num2change\"&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;父组件-传给props：&#123;&#123;number1&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" v-model=\"dnumber1\"&gt;--&gt; &lt;h2&gt;子组件-props赋值给data:&#123;&#123;dnumber1&#125;&#125;&lt;/h2&gt; &lt;input type=\"text\" :value=\"dnumber1\" @input=\"num1Input\"&gt; &lt;!--拆分,通过方法发送$emit()--&gt; &lt;hr&gt; &lt;h2&gt;父组件-传给props：&#123;&#123;number2&#125;&#125;&lt;/h2&gt; &lt;!-- &lt;input type=\"text\" v-model=\"dnumber2\"&gt;--&gt; &lt;h2&gt;子组件-props赋值给data:&#123;&#123;dnumber2&#125;&#125;&lt;/h2&gt; &lt;input type=\"text\" :value=\"dnumber2\" @input=\"num2Input\"&gt; &lt;!--拆分,通过方法发送$emit()--&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; num1: 1, num2: 0 &#125;, methods: &#123; num1change(value) &#123; this.num1 = parseFloat(value); &#125;, num2change(value) &#123; this.num2 = parseFloat(value); &#125; &#125;, components: &#123; cpn: &#123; template: '#cpn', //不能直接绑定到props里，会报错，需要绑定到data里 props: &#123; number1: Number, number2: Number &#125;, data() &#123; return &#123; dnumber1: this.number1, dnumber2: this.number2 &#125; &#125;, methods: &#123; num1Input(event) &#123; this.dnumber1 = event.target.value; this.$emit('dnumber1tofather',this.dnumber1); this.dnumber2 = this.dnumber1*100; //num1 * 100 -&gt; num2 ，控制num2 this.$emit('dnumber2tofather',this.dnumber2); &#125;, num2Input(event) &#123; this.dnumber2 = event.target.value; this.$emit('dnumber2tofather',this.dnumber2); this.dnumber1 = this.dnumber2/100; //num1 * 100 -&gt; num2 ，控制num2 this.$emit('dnumber1tofather',this.dnumber1); &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 需求： 1、父传子 2、子双向绑定 3、子同步父 4、通过子参数1修改子参数2，子参数参数1是子参数2的100倍，子参数2是子参数1的1/100，同时子同步父 总结： 1、父传子，子取得的参数不能直接绑定到子的props中，会报错，需要绑定到子的data中。 2、拆分v-model为v-bind和v-on，并通过@input=\"num1Input\"实时监听输入的数据，绑定方法，通过$emit修改父 3、父接受，修改父参数。 4、父参数修改时要注意类型不同的问题，需要把string转化为int 2.5、父子组件通信案例watch的使用//不拆分，直接双向绑定 &lt;input type=\"text\" v-model=\"dnumber1\"&gt; &lt;input type=\"text\" v-model=\"dnumber2\"&gt; //使用watch自己监听变量是否改变：有两个参数（newVaule，oldValue） watch: &#123; //配合v-model，实时绑定，监听变量是否发生改变 dnumber1(newValue) &#123; this.dnumber2 = this.dnumber1*100; //一旦改变，就可以监听到dnumber2 this.$emit('dnumber1tofather',newValue); //改变自身的props &#125;, dnumber2(newValue) &#123; this.dnumber1 = this.dnumber2/100; //num1 * 100 -&gt; num2 ，控制num2 this.$emit('dnumber2tofather',newValue); &#125; &#125; 2.6、父访问子（$children和$refs）//需求：多个子组件，点击按钮获得子组件的参数 &lt;div id=\"app\"&gt; &lt;cpn ref=\"aaa\"&gt;&lt;/cpn&gt; &lt;cpn ref=\"bbb\"&gt;&lt;/cpn&gt; &lt;cpn ref=\"ccc\"&gt;&lt;/cpn&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, methods: &#123; btnClick() &#123; //$children 不好，不常用，一旦多个子组件顺序发生变化，则可能获得的组件会错乱 // console.log(this.$children); // for (let c of this.$children) &#123; // console.log(c.name); // c.showMessage(); // &#125; //开发中用$ref，绑定ref属性作为key，可以不受索引的影响 =&gt; 默认是空对象 console.log(this.$refs.aaa.name); &#125; &#125;, components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; name: '我是子组件的name' &#125; &#125;, methods: &#123; showMessage() &#123; console.log('showMessage的内容被访问了'); &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 2.7 子访问父（$parent和$root）//代码大意：ccpn通过按钮访问cpn的参数，和vue(root)的参数 &lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; 我是cpn组件 &lt;ccpn&gt;&lt;/ccpn&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=\"ccpn\"&gt; &lt;div&gt; &lt;h2&gt;我是子子组件&lt;/h2&gt; &lt;button @click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, //cpn------------ components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; name: '我的cpn的name' &#125; &#125;, //ccpn--------------- components: &#123; ccpn: &#123; template: '#ccpn', methods: &#123; btnClick() &#123; //1、访问父组件 // console.log(this.$parent); // console.log(this.$parent.name); //2、直接访问根组件$root console.log(this.$root); console.log(this.$root.message); &#125; &#125; &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 三、插槽使用3.1、slot-插槽的基本使用&lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;/cpn&gt; //直接替代 &lt;cpn&gt; //多个一起替代 &lt;i&gt;嘻嘻嘻&lt;/i&gt; &lt;div&gt;可以多个&lt;/div&gt; &lt;div&gt;一起替代&lt;/div&gt; &lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是组件&lt;/h2&gt; &lt;p&gt;我是组件、哈哈哈&lt;/p&gt; &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt; &lt;!--插槽并有默认值--&gt; &lt;hr&gt; &lt;/div&gt; &lt;/template&gt; 3.2、slot-具名插槽的使用//顾名思义，为了解决多个插槽，如何指定使用某个插槽，的问题 &lt;div id=\"app\"&gt; &lt;!--不指定名字则把没有名字的都替换掉--&gt; &lt;cpn&gt; //先插入，再指定名字 &lt;span slot=\"center\"&gt;标题&lt;/span&gt; &lt;!--指定使用中间那个--&gt; &lt;button slot=\"left\"&gt;返回&lt;/button&gt; &lt;!--指定使用左边那个--&gt; &lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;!--name：指定哪一个--&gt; &lt;div&gt; &lt;slot name=\"left\"&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt; &lt;slot name=\"center\"&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt; &lt;slot name=\"right\"&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt; &lt;hr&gt; &lt;/div&gt; &lt;/template&gt; 3.3、关于插槽，父子参数的编译作用域//总结：是谁，就用谁的参数，父不能直接使用子的参数，反之亦然 &lt;div id=\"app\"&gt; &lt;!--变量是在vue实例里找的，这些cpn当于普通标签--&gt; &lt;cpn v-show=\"isShow\"&gt;&lt;/cpn&gt; //可以显示 &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;h2&gt;我是标题&lt;/h2&gt; &lt;div&gt;我是内容，哈哈哈&lt;/div&gt; &lt;!--这个变量就在组件里找，这里是false--&gt; &lt;button v-show=\"isShow\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; isShow: true &#125;, components: &#123; cpn: &#123; template: '#cpn' &#125;, data() &#123; return &#123; isShow: false &#125; &#125; &#125; &#125;) 3.4、编译作用域插槽的案例（解决参数传递）&lt;!--需求：获得子组件的data，另起格式排列，主要是获得data--&gt; &lt;div id=\"app\"&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt; &lt;!--通过slot传递参数，2.5.x以下必须使用template包裹--&gt; &lt;template slot-scope=\"slot\"&gt; &lt;span&gt;&#123;&#123;slot.data.join(' - ')&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;!--通过slot传递参数，2.5.x以下必须使用template包裹--&gt; &lt;template slot-scope=\"slot\"&gt; &lt;!--拿到插槽对象--&gt; &lt;span&gt;&#123;&#123;slot.data.join(' * ')&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt; &lt;/div&gt; &lt;template id=\"cpn\"&gt; &lt;div&gt; &lt;!--把数据传上去--&gt; &lt;slot :data=\"pLanguages\"&gt; &lt;!--起名字为data（随意）--&gt; &lt;ul&gt; &lt;li v-for=\"item in pLanguages\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊' &#125;, components: &#123; cpn: &#123; template: '#cpn', data() &#123; return &#123; pLanguages: ['C','Javascript','C++','C#','Python'] &#125; &#125; &#125; &#125; &#125;) &lt;/script&gt; 2020年07月26日 晚上Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"VUE学习（一）：基础语法","slug":"VUE学习（一）：基础语法","date":"2020-07-26T14:49:04.000Z","updated":"2020-07-26T16:50:53.000Z","comments":true,"path":"2020/07/26/VUE学习（一）：基础语法/","link":"","permalink":"http://yoursite.com/2020/07/26/VUE学习（一）：基础语法/","excerpt":"","text":"前言：本笔记为VUE基础语法的使用。B站视频链接 一、插值的操作1.1、Mustache语法&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;，嘻嘻嘻！&lt;/h2&gt; &lt;h2&gt;&#123;&#123;first + \" \" + end&#125;&#125;&lt;/h2&gt; &lt;h2&gt;&#123;&#123;counter * 3&#125;&#125;&lt;/h2&gt; &lt;/div&gt; 直接包裹变量、变量拼接、变量数学运算 1.2、v-once指令的使用&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 v-once&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--不可以被修改--&gt; &lt;/div&gt; 使用了v-once后，变量被修改，值不影响 1.3、v-html指令的使用&lt;h2 v-html=\"url\"&gt;&lt;/h2&gt; url: '&lt;a href=\"http://www.baidu.com\"&gt;百度一下&lt;/a&gt;' 1.4、v-text指令的使用&lt;h2 v-text=\"message\"&gt;&lt;/h2&gt; 不用Mustache语法包裹 1.5、v-pre指令的使用&lt;h2 v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--不解析 Previous--&gt; 原样输出内容：&#123;&#123;message&#125;&#125; -&gt; &#123;&#123;message&#125;&#125; 1.6、v-cloak指令的使用&lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;div id=\"app\" v-cloak&gt; &lt;!--消除闪烁问题，斗篷--&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; 二、动态绑定属性：v-bind2.1、v-bind（:）&lt;div id=\"app\"&gt; &lt;a v-bind:href=\"myhref\"&gt;bilibili&lt;/a&gt; &lt;!--语法糖：只写“:”--&gt; &lt;/div&gt; data: &#123; message: '你好啊', myhref: 'https://www.bilibili.com/' &#125; VUE托管属性、绑定属性 2.2、v-bind动态绑定class属性（对象语法）&lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"&#123;active: isActive, line: isLine&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;button v-on:click=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; data: &#123; message: '你好啊', isActive: true, isLine: true &#125;, methods: &#123; btnClick: function () &#123; this.isActive = !this.isActive; &#125;, getClasses: function () &#123; return &#123;active: this.isActive, line: this.isLine&#125; &#125; &#125; 效果：点击按钮，切换active 2.3、v-bind动态绑定class属性（数组语法）&lt;div id=\"app\"&gt; &lt;h2 class=\"title\" :class=\"['active','line']\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //这里为字符串 &lt;h2 class=\"title\" :class=\"[active,line]\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //这里为数组变量 &lt;h2 class=\"title\" :class=\"getClasses()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //通过方法获得数组变量 &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊', active: 'aaa', line: 'bbb' &#125;, methods: &#123; getClasses: function () &#123; return [this.active,this.line] &#125; &#125; &#125;) &lt;/script&gt; 2.4、v-bind动态绑定style属性（对象语法）&lt;div id=\"app\"&gt; &lt;h2 :style=\"&#123;fontSize: finalSize + 'px',background: finalColor&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 :style=\"getStyle()\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;h2 :style=\"&#123;'font-size': '50px'&#125;\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊', finalSize: 100, finalColor: 'red' &#125;, methods: &#123; getStyle: function () &#123; return &#123;fontSize: this.finalSize + 'px',background: this.finalColor&#125; &#125; &#125; &#125;) &lt;/script&gt; 2.5、v-bind动态绑定style属性（数组语法）&lt;div id=\"app\"&gt; &lt;h2 :style=\"[baseStyle]\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; message: '你好啊', baseStyle: &#123;background: 'red'&#125; &#125; &#125;) &lt;/script&gt; 比较少用、这种用法相当于套娃 三、计算属性：computed（有缓存、效率高）3.1、计算属性的基本用法&lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; computed: &#123; //计算属性，注重“属性”，命名方式不用get set，直接用就可以了 fullName: function () &#123; return this.firstName + ' ' + this.lastName &#125; &#125; 3.2、计算属性的复杂操作&lt;div id=\"app\"&gt; &lt;h2&gt;总价格：&#123;&#123;totalPrice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; books: [ &#123;id: 110,name: 'Unix编程艺术',price: 119&#125;, &#123;id: 111,name: '代码大全',price: 105&#125;, &#123;id: 112,name: '计算机原理',price: 98&#125;, &#123;id: 113,name: '现代操作系统',price: 97&#125;, ] &#125;, //有缓存，效率高 computed: &#123; totalPrice: function () &#123; let result = 0; for (let i = 0; i&lt;this.books.length; i++)&#123; result += this.books[i].price; &#125; return result; &#125; &#125; &#125;) &lt;/script&gt; 3.3、计算属性的setter和gettercomputed: &#123; //简写,默认是get fullName: function () &#123; console.log('fullName'); return this.firstName +' '+ this.lastName; &#125; &#125; // 原理写法，一般我们用不到set，所以省略 computed: &#123; fullName: function () &#123; set() &#123; console.log('只要值改变，就会默认调用') &#125; get() &#123; console.log('fullName'); return this.firstName +' '+ this.lastName; &#125; &#125; &#125; 四、事件监听：v-on4.1、v-on的基本使用：计数器&lt;div id=\"app\"&gt; &lt;h2&gt;计数器：&#123;&#123;counter&#125;&#125;&lt;/h2&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: \"#app\", data: &#123; counter: 0 &#125;, methods: &#123; increment() &#123; this.counter++; &#125;, decrement() &#123; this.counter--; &#125; &#125; &#125;) &lt;/script&gt; 4.2、v-on的参数问题无参：两者一样 @click=\"btn1Click\" @click=\"btn1Click()\" 有参： 正常： @click=\"btn2Click(123)\" undefined： @click=\"btn2Click()\" 传进去了event：@click=\"btn2Click\" 指定获得event：@click=\"btn3Click(123,$event)\" 4.3、v-on的修饰符1：.stop的使用：阻止冒泡，点击div不冒泡button（div包裹button） &lt;div @click=\"divClick\"&gt; aa &lt;button @click.stop=\"btnClick\"&gt;按钮&lt;/button&gt; &lt;/div&gt; 2：.prevent的使用：阻止提交 &lt;form action=\"http://www.baidu.com\"&gt; &lt;input type=\"submit\" value=\"提交\" @click.prevent=\"submitClick\"&gt; &lt;/form&gt; 3：@keyup键帽监听：弹起键帽执行事件 &lt;input type=\"text\" @keyup.enter=\"keyUp\"&gt; //指定为enter键 4：.once：只能点击一次 &lt;button @click.once=\"btn2Click\"&gt;按钮2&lt;/button&gt; 五、条件判断5.1、if else-if else&lt;h2 v-if=\"score&gt;=90\"&gt;优秀&lt;/h2&gt; &lt;h2 v-else-if=\"score&gt;=80\"&gt;良好&lt;/h2&gt; &lt;h2 v-else-if=\"score&gt;=60\"&gt;及格&lt;/h2&gt; &lt;h2 v-else&gt;不及格&lt;/h2&gt; 5.2、用户登录切换案例：问题（组件复用导致input值滞留）需求：不需要复用，则加入key属性，给每个input添加key后则不会被复用 &lt;div id=\"app\"&gt; &lt;span v-if=\"isUser\"&gt; &lt;label for=\"username\"&gt;用户账号&lt;/label&gt; &lt;input type=\"text\" id=\"username\" placeholder=\"账号\" key=\"username\"&gt; &lt;!--标识，不一样则不复用--&gt; &lt;/span&gt; &lt;span v-else&gt; &lt;label for=\"email\"&gt;用户邮箱&lt;/label&gt; &lt;input type=\"text\" id=\"email\" placeholder=\"邮箱\" key=\"email\"&gt; &lt;/span&gt; //思想：直接取反即可，不需要写方法 &lt;button @click=\"isUser = !isUser\"&gt;切换类型&lt;/button&gt; &lt;/div&gt; data: &#123; isUser: true &#125; 5.3、v-if和v-show的区别&lt;div id=\"app\"&gt; &lt;h2 id=\"aaa\" v-show=\"false\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--修改样式 display:none--&gt; &lt;h2 id=\"bbb\" v-if=\"false\"&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;!--移除dom 不解析--&gt; &lt;/div&gt; 六、循环遍历：v-for6.1、v-for遍历数组&lt;ul&gt; &lt;li v-for=\"(i,index) in names\"&gt;&#123;&#123;index+1&#125;&#125;.&#123;&#123;i&#125;&#125;&lt;/li&gt; //取得下标从1开始显示 &lt;/ul&gt; data: &#123; names: ['aa','bb','cc','dd'] &#125; 6.2、v-for遍历对象&lt;!-- value在左 ，一个item默认取value值--&gt; &lt;ul&gt; &lt;li v-for=\"(value,key) in info\"&gt;&#123;&#123;key&#125;&#125; = &#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 也取下标 --&gt; &lt;ul&gt; = &lt;li v-for=\"(value,key,index) in info\"&gt;&#123;&#123;index&#125;&#125;.&#123;&#123;key&#125;&#125; = &#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; data: &#123; info: &#123; name: 'aa', age: 18, height: 1.88 &#125; &#125; 6.3、哪些数组方法是响应式响应式： 1、追加push()：this.letters.push('aaa'); 2、删除最后一个pop()：this.letters.pop(); 3、删除第一个shift()：this.letters.shift(); 4、在前面追加unshift()：this.letters.unshift('aaa','bbb'); * 5、切片splice(位置、删除个数（空则删除后面所有）、插入)： - this.letters.splice(1,1); //删除第二个元素 - this.letters.splice(1,3,'cc','dd','ee') //替换三个 - this.letters.splice(1,0,\"aaa\",'ccc'); //二号位插入两个 6、排序：sort()：this.letters.sort(); 7、反转：reverse()：this.letters.reverse(); 非响应式： 直接通过下标修改值：this.letters[0] = 'aaa'; 解决：1、this.letters.splice(0,1,\"aaa\"); //替换 2、Vue.set(this.letters,0,'aaaaaa'); //对象、索引、修改值 七、书籍购物车案例知识点7.1、for循环的另一种用法（js)//of直接取值 for (let book of this.books) &#123; totalPrice += book.price * book.count; &#125; 7.2、VUE高级函数用法需求：过滤数组的为100以内然后乘2的累加值。 const nums = [10,20,30,50,100,200,300]; //分开写法 let newNums = nums.filter(function (n) &#123; return n&lt;100; //条件过滤 &#125;); let newNums2 = newNums.map(function (n) &#123; return n*2; //进一步操作 &#125;); //两个参数，第一个与上一个的返回值有关。默认从0为第一次遍历的上一个个值， let total = newNums2.reduce(function (previousValue,n) &#123; return previousValue + n; //递归遍历 &#125;,0); //合并写法： let total = nums.filter(n =&gt; n&lt;100).map(n =&gt; n*2).reduce((pre,n) =&gt; pre+n); 7.3、filters过滤器//使用 &lt;td&gt;&#123;&#123;item.price | showPrice&#125;&#125;&lt;/td&gt; //指定格式显示 filters: &#123; showPrice(price) &#123; return \"￥\" + price.toFixed(2); //保留两位小数 &#125; &#125; 八、双向绑定：v-model8.1、v-model的基本使用&lt;!--双向绑定：同步修改--&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; message: '你好啊' 8.2、v-model的原理//v-bind和v-on的结合体：原理就是修改了input内容的值，通过v-on绑定事件修改了值，然后用v-bind显示值 &lt;input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\"&gt; //内容监听的简写 8.3、v-model结合radio类型&lt;!--双向绑定同一个变量，默认就互斥，可以不需要name--&gt; &lt;input type=\"radio\" id=\"male\" value=\"男\" v-model=\"sex\"&gt;男 &lt;input type=\"radio\" id=\"female\" value=\"女\" v-model=\"sex\"&gt;女 &lt;h2&gt;性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt; sex: '女' //默认 8.4、v-model结合checkbox类型//checkbox单选：同意协议场景，同意了则给点击 &lt;input type=\"checkbox\" id=\"agree\" v-model=\"isAgree\"&gt;同意协议 &lt;button :disabled=\"!isAgree\"&gt;下一步&lt;/button&gt; isAgree: false, //选中了则改为true //checkbox多选 &lt;input type=\"checkbox\" value=\"唱\" v-model=\"hobbies\"&gt;唱 &lt;input type=\"checkbox\" value=\"跳\" v-model=\"hobbies\"&gt;跳 &lt;input type=\"checkbox\" value=\"rap\" v-model=\"hobbies\"&gt;rap &lt;input type=\"checkbox\" value=\"篮球\" v-model=\"hobbies\"&gt;篮球 &lt;h2&gt;您的爱好是：&#123;&#123;hobbies&#125;&#125;&lt;/h2&gt; hobbies: [], //选中了则存到数组中 //值绑定：使用场景为，不写死，动态获取，给定初始值 &lt;label :for=\"item\" v-for=\"item in originHobbies\"&gt; &lt;input type=\"checkbox\" :value=\"item\" :id=\"item\" v-model=\"hobbies\"&gt;&#123;&#123;item&#125;&#125; &lt;/label&gt; originHobbies: ['唱','跳','rap','篮球','足球','排球'] 8.5、v-model结合select类型 &lt;!--单选--&gt; &lt;select name=\"fruit\" v-model=\"fruit\"&gt; &lt;option value=\"苹果\"&gt;苹果&lt;/option&gt; &lt;option value=\"香蕉\"&gt;香蕉&lt;/option&gt; &lt;option value=\"榴莲\"&gt;榴莲&lt;/option&gt; &lt;option value=\"葡萄\"&gt;葡萄&lt;/option&gt; &lt;option value=\"西瓜\"&gt;西瓜&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;你选中的是：&#123;&#123;fruit&#125;&#125;&lt;/h2&gt; fruit: '香蕉', //默认选中香蕉 &lt;!--多选--&gt; &lt;select name=\"fruits\" id=\"\" v-model=\"fruits\" multiple&gt; //按住ctrl多选 &lt;option value=\"苹果\"&gt;苹果&lt;/option&gt; &lt;option value=\"香蕉\"&gt;香蕉&lt;/option&gt; &lt;option value=\"榴莲\"&gt;榴莲&lt;/option&gt; &lt;option value=\"葡萄\"&gt;葡萄&lt;/option&gt; &lt;option value=\"西瓜\"&gt;西瓜&lt;/option&gt; &lt;/select&gt; &lt;h2&gt;你选中的是：&#123;&#123;fruits&#125;&#125;&lt;/h2&gt; fruits: [] //用数组存值 8.6、v-model修饰符的使用//1、修饰符.lazy：懒加载 &lt;input type=\"text\" v-model.lazy=\"message\"&gt; &lt;!--不实时，回车、或者失去焦点才同步--&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; //2、修饰符.number：改变input默认获得string类型为number类型（免去转化） &lt;input type=\"number\" v-model.number=\"age\"&gt; &lt;h2&gt;&#123;&#123;typeof age&#125;&#125;类型：&#123;&#123;age&#125;&#125;&lt;/h2&gt; //3、修饰符.trim：去首尾空格 &lt;input type=\"text\" v-model.trim=\"name\"&gt; message: '你好啊', age: 0, name: '' 2020年07月26日 凌晨Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"在线订餐系统知识点总结","slug":"在线订餐系统知识点总结","date":"2020-07-12T14:49:04.000Z","updated":"2020-08-04T15:26:53.264Z","comments":true,"path":"2020/07/12/在线订餐系统知识点总结/","link":"","permalink":"http://yoursite.com/2020/07/12/在线订餐系统知识点总结/","excerpt":"","text":"项目背景：在线订餐系统是基于springboot和bootstrap的JavaEE项目，主要实现用户订餐，管理员接单等操作。 SpringBoot基本配置1、阿里巴巴druid配置&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; spring: datasource: username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/springboot_orderfood_end?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=true type: com.alibaba.druid.pool.DruidDataSource initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 2、整合swagger&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; Config配置类添加注解：@EnableSwagger2 使用 http://localhost:8080/swagger-ui.html#/ MybatisPlus以及代码生成器1、基本依赖&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2、配置文件mybatis-plus: # 日志log configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: # 配置逻辑删除 db-config: logic-delete-value: 1 logic-not-delete-value: 0 # 如果手写mapper映射文件，需要配置扫描路径 mapper-locations: classpath:/com/guzhz/mapper/xml/*.xml 3、代码生成器类 //代码生成器CodeGenerator public class CodeGenerator &#123; public static void main(String[] args) &#123; String tableName = \"order_detail\"; String deletedCol = \"md_deleted\"; String versionCol = \"md_version\"; AutoGenerator mpg = new AutoGenerator(); GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"Guzhz\"); gc.setFileOverride(false); gc.setOpen(false); gc.setSwagger2(true); gc.setBaseResultMap(true); gc.setBaseColumnList(true); gc.setServiceName(\"%sService\"); gc.setIdType(IdType.AUTO); gc.setDateType(DateType.ONLY_DATE); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/springboot_orderfood_end?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=true\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setParent(\"com.guzhz\"); pc.setEntity(\"entity\"); pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc); //4、策略配置（只需要改这里的表名即可） StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 自动lombok； strategy.setLogicDeleteFieldName(deletedCol); //逻辑删除字段 strategy.setInclude(new String[]&#123;tableName&#125;); //可以传入多个值 //5、自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); //6、乐观锁 strategy.setVersionFieldName(versionCol); //乐观锁字段名 strategy.setRestControllerStyle(true); //restful api风格控制器 strategy.setControllerMappingHyphenStyle(true); //url中驼峰转连字符 mpg.setStrategy(strategy); mpg.execute(); &#125; &#125; 4、实体类关键成员的注解@TableLogic private Integer mdDeleted; @Version private Integer mdVersion; @JsonFormat(pattern=\"yyyy-MM-dd HH:mm:ss\",timezone = \"GMT+8\") @DateTimeFormat(pattern=\"yyyy-MM-dd HH:mm:ss\") @TableField(value = \"od_createTime\",fill = FieldFill.INSERT) private Date odCreateTime; 5、配置分页、乐观锁的配置类@MapperScan(\"com.guzhz.mapper\") @ConditionalOnClass(value = &#123;PaginationInterceptor.class&#125;) @Configuration // 配置类 public class Config &#123; // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; /*配置分页插件*/ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; &#125; 6、自动更新时间配置类//自动更新时间 @Slf4j //日志注解 @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; //实体类成员 this.setFieldValByName(\"odCreateTime\",new Date(),metaObject); &#125; @Override public void updateFill(MetaObject metaObject) &#123; &#125; &#125; 7、时间个格式化json包//时间格式化 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.1&lt;/version&gt; &lt;/dependency&gt; th:text=\"$&#123;#dates.format(order.getOdCreateTime(),'yyyy-MM-dd HH:mm:ss')&#125;\" SpringSecurity51、基本依赖&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置类@EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Resource TbUserServiceImpl tbUserService; @Override //授权规则 protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests().antMatchers(\"/\",\"/index\",\"/main\",\"/search\").permitAll() .antMatchers(\"/userInfo\",\"/insertUserInfo\",\"/edUserInfo\",\"/deleteUser/**\").hasAnyRole(\"admin\") .antMatchers(\"/menuManage\",\"/deleteOneMenu/**\",\"/upLoadImg\",\"/insertMenu\",\"/updateMenu\").hasAnyRole(\"admin\") .antMatchers(\"/insertType\",\"/updateType\",\"/deleteType\").hasAnyRole(\"admin\") .antMatchers(\"/orderManage\",\"/changeStatusToOne\").hasAnyRole(\"admin\") .antMatchers(\"/myInfo\",\"/updateMyImg\",\"/updateMyInfo\").hasAnyRole(\"admin\",\"user\") .antMatchers(\"/shoppingCart\",\"/shoppingCart-plus\",\"/shoppingCart-minus\",\"/addShoppingCart\").hasAnyRole(\"user\") .antMatchers(\"/toOrder\",\"/myOrder\",\"/changeStatusToTwo\").hasAnyRole(\"user\"); http.formLogin().loginPage(\"/toLogin\").usernameParameter(\"uUsername\").passwordParameter(\"uPassword\") .loginProcessingUrl(\"/login\") //表单提交的请求，可以不需要路由（走security的路由） .failureUrl(\"/toLogin?error=true\"); http.csrf().disable(); //取消ajax拦截（post），如果改为post/get则可能不会报错 http.logout().logoutSuccessUrl(\"/toLogin\"); //解决中文乱码问题 CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\"UTF-8\"); filter.setForceEncoding(true); http.addFilterBefore(filter, CsrfFilter.class); /* //开启记住我功能 http.rememberMe().rememberMeParameter(\"remember\");*/ &#125; @Override //验证规则 protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(tbUserService).passwordEncoder(new NoPasswordEncoder()); &#125; &#125; 3、取消加密类public class NoPasswordEncoder implements PasswordEncoder &#123; @Override public String encode(CharSequence charSequence) &#123; //不做任何加密处理 return charSequence.toString(); &#125; @Override public boolean matches(CharSequence charSequence, String s) &#123; //charSequence是前端传过来的密码，s是数据库中查到的密码 if (charSequence.toString().equals(s)) &#123; return true; &#125; return false; &#125; &#125; 4、TbUserServiceImpl实现类对接数据库（implements TbUserService）@Service public class TbUserServiceImpl extends ServiceImpl&lt;TbUserMapper, TbUser&gt; implements TbUserService , UserDetailsService&#123; //security验证用户名 @Override public UserDetails loadUserByUsername(String uUsername) throws UsernameNotFoundException &#123; //我们自己定义的 TbUserServiceImpl 需要实现 UserDetailsService 接口，实现该接口，就要实现接口中的方法， // 也就是 loadUserByUsername ，这个方法的参数就是用户在登录的时候传入的用户名， // 根据用户名去查询用户信息（查出来之后，系统会自动进行密码比对） //根据前端传过来的uUsername找到对应的user TbUser user = tbUserMapper.selectOne(new QueryWrapper&lt;TbUser&gt;().eq(\"u_username\", uUsername)); if (user==null)&#123; throw new UsernameNotFoundException(\"用户不存在!\"); &#125; return user; &#125; &#125; 5、在后台获取当前用户的session信息public class UpdateSession &#123; //刷新权限 public static void reloadUserAuthority(HttpSession session , TbUser user)&#123; //1.从HttpServletRequest中获取SecurityContextImpl对象 SecurityContextImpl securityContextImpl = (SecurityContextImpl) session.getAttribute(\"SPRING_SECURITY_CONTEXT\"); //2.从SecurityContextImpl中获取Authentication对象 Authentication authentication = securityContextImpl.getAuthentication(); //3.初始化UsernamePasswordAuthenticationToken实例 ，这里的参数user就是我们要更新的用户信息 UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(user, authentication.getCredentials()); auth.setDetails(authentication.getDetails()); //4.重新设置SecurityContextImpl对象的Authentication securityContextImpl.setAuthentication(auth); &#125; //获得当前session对象，用于判断是否跨用户访问,返回当前所登录的用户的id； public static Integer getSessionUId(HttpSession session)&#123; SecurityContextImpl securityContextImpl = (SecurityContextImpl) session.getAttribute(\"SPRING_SECURITY_CONTEXT\"); Authentication authentication = securityContextImpl.getAuthentication(); TbUser user = (TbUser) authentication.getPrincipal(); return user.getUId(); &#125; &#125; 6、前端获取权限//导入命名空间 xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\" //获得权限 sec:authorize=\"hasRole('admin')\" //获得内存中的值 $&#123;#authentication.getPrincipal().uId&#125;&#125; 多表联合查询//自定义接口 @Mapper public interface MenuDetailMapper extends BaseMapper&lt;MenuDetail&gt; &#123; List&lt;MenuDetail&gt; selectByType(int mtId); &#125; &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.guzhz.mapper.MenuDetailMapper\"&gt; &lt;!-- 通用查询映射结果 --&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.guzhz.entity.MenuDetail\"&gt; &lt;id column=\"md_id\" property=\"mdId\" /&gt; &lt;result column=\"md_name\" property=\"mdName\" /&gt; &lt;result column=\"md_price\" property=\"mdPrice\" /&gt; &lt;result column=\"md_amount\" property=\"mdAmount\" /&gt; &lt;result column=\"md_url\" property=\"mdUrl\" /&gt; &lt;result column=\"md_new\" property=\"mdNew\" /&gt; &lt;result column=\"md_star\" property=\"mdStar\" /&gt; &lt;result column=\"md_deleted\" property=\"mdDeleted\" /&gt; &lt;result column=\"md_version\" property=\"mdVersion\" /&gt; &lt;result column=\"mt_id\" property=\"mtId\"/&gt; &lt;association property=\"menuType\" javaType=\"com.guzhz.entity.MenuType\"&gt; &lt;id column=\"mt_id\" property=\"mtId\"/&gt; &lt;result column=\"mt_name\" property=\"mtName\"/&gt; &lt;result column=\"mt_deleted\" property=\"mtDeleted\"/&gt; &lt;result column=\"mt_version\" property=\"mtVersion\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 通用查询结果列 --&gt; &lt;sql id=\"Base_Column_List\"&gt; md_id, md_name, md_price, md_amount, md_url, md_new, md_star, md_deleted, md_version &lt;/sql&gt; &lt;select id=\"selectByType\" parameterType=\"int\" resultMap=\"BaseResultMap\"&gt; select md_id, md_name, md_price, md_amount, md_url, md_new, md_star, md_deleted, md_version, b.mt_id, mt_name, mt_deleted, mt_version from menu_detail a, menu_type b where a.mt_id = b.mt_id and b.mt_id = #&#123;mtId&#125; &lt;/select&gt; &lt;/mapper&gt; 文件上传1、配置类@Configuration public class MyWebAppConfigurer implements WebMvcConfigurer &#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/images/**\").addResourceLocations(\"file:F:/Study/Book6/JavaEE/images/\"); &#125; &#125; 2、实现类@Repository public class FileUpload &#123; public static String uploadFile(MultipartFile upLoadFile)&#123; if (upLoadFile.isEmpty()) &#123; System.out.println(\"文件为空空\"); return null; &#125; String filePath = \"F:\\\\Study\\\\Book6\\\\JavaEE\\\\images\"; //获取原始文件名 String fileName = upLoadFile.getOriginalFilename(); /*新的文件名*/ fileName = UUID.randomUUID().toString().replace(\"-\", \"\") + fileName.substring(fileName.lastIndexOf(\".\")); File file = new File(filePath,fileName); if (!file.getParentFile().exists()) &#123; file.getParentFile().mkdirs(); System.out.println(\"创建成功！\"); &#125; try &#123; upLoadFile.transferTo(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String imgPath = \"/images/\"+fileName; return imgPath; &#125; &#125; 3、工具类public class RandomNo &#123; public static String getRandomNo()&#123; SimpleDateFormat sdf=new SimpleDateFormat(\"yyyyMMddHHmmss\"); String newDate=sdf.format(new Date()); String result=\"\"; Random random=new Random(); for(int i=0;i&lt;3;i++)&#123; result+=random.nextInt(10); &#125; return newDate+result; &#125; &#125; 前端知识总结1、bootStrap、JQuery三件套&lt;link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\"&gt; &lt;script src=\"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"&gt;&lt;/script&gt; //semantic-ui &lt;link href=\"https://cdn.bootcss.com/semantic-ui/2.4.1/semantic.min.css\" rel=\"stylesheet\"&gt; //图标库 &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.0.9/css/all.css\"&gt; 2、思想：获得循环出来的值，通过Ajax请求把必要元素放进a标签里，设置为input hidden，绑定点击事件 &lt;a onclick=\"getDetail(this)\" id=\"getDetail\" href=\"#successTips\" data-toggle=\"modal\" class=\"add-to-cart\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdName()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdAmount()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdPrice()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdUrl()&#125;\"&gt; &lt;input type=\"hidden\" th:value=\"$&#123;menu.getMdId()&#125;\"&gt; &lt;input type=\"hidden\" sec:authorize=\"isAuthenticated()\" th:value=\"$&#123;#authentication.getPrincipal().uId&#125; \"&gt; &lt;!--登录后获得用户id--&gt; &lt;input type=\"hidden\" sec:authorize=\"isAuthenticated()\" th:value=\"$&#123;#authentication.getPrincipal().uRole&#125; \"&gt; &lt;!--登录后判断账号权限--&gt; &lt;/a&gt; &lt;script&gt; function getDetail(a) &#123; let list = $(a).children('input'); //获得当前元素下的所有子input if (list.length == 5)&#123; //5个说明处于未登录状态 alert(\"请先登录，再订餐哦~\"); $(a).attr(\"href\",\"#\"); return ; &#125; if($(list[6]).val() == \"ROLE_admin\")&#123; alert(\"你就是老板啦，你不能下单哦~\"); $(a).attr(\"href\",\"#\"); return ; &#125;if($(list[1]).val() == \"0\")&#123; alert(\"加入购物车失败！该菜品已售罄，等待补货！\"); $(a).attr(\"href\",\"#\"); return ; &#125; else&#123; let mdName = $(list[0]).val(); let mdPrice = $(list[2]).val(); $('#tips-name').html(\"【名称】\"+mdName); $('#tips-price').html(\"【价格】\"+mdPrice+'元'); /*发起请求*/ let postData = &#123;&#125;; postData['scName'] = mdName; postData['scAmount'] = 1; postData['scPrice'] = mdPrice; postData['scImg'] = $(list[3]).val(); postData['mdId'] = $(list[4]).val(); postData['uId'] = $(list[5]).val(); $.ajax(&#123; url: \"/addShoppingCart\", type: 'POST', data: postData, success: function (arg) &#123; if(arg == \"0\")&#123; $('#myModalLabel').text(\"当前菜品加购已达到上限！\") &#125;else if(arg == \"1\")&#123; $('#myModalLabel').text(\"加入成功！\") &#125;else&#123; $('#myModalLabel').text(\"数量加+1成功！\") &#125; // window.location.reload(); &#125; &#125;) &#125; &#125; &lt;/script&gt; 3、技巧：修改头像&lt;!--更新头像模态框--&gt; //修改点：模态框的id，img的id，模块脚的button &lt;div class=\"modal fade\" id=\"headImgModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\" aria-hidden=\"true\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\" style=\"margin: 0 auto;width: 450px\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\"&gt;&amp;times;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;修改头像&lt;/h4&gt; &lt;/div&gt; &lt;form action=\"\"&gt; &lt;div class=\"modal-body text-center\"&gt; &lt;span&gt; &lt;!--预览图片位置，默认图片--&gt; &lt;img id=\"headImg\" style=\"width: 250px;height: 250px\" th:src=\"@&#123;$&#123;#authentication.getPrincipal().uUrl&#125;&#125;\" class=\"img-rounded\"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;!--点击选择文件 触发隐藏form，通过id--&gt; &lt;button type=\"button\" class=\"btn btn-default\" onclick=\"$('#updateHeadImg').click();\"&gt;浏览&lt;/button&gt; &lt;!--点击提交表单--&gt; &lt;button type=\"button\" class=\"btn btn-primary\" id=\"submitBtn\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 隐藏form --&gt; //修改点：form的id，form的action，input的id &lt;form id=\"updateHeadImgForm\" th:action=\"@&#123;'/updateMyImg?uId='+$&#123;#authentication.getPrincipal().uId&#125;&#125;\" method=\"post\" enctype=\"multipart/form-data\" class=\"form\"&gt; &lt;input type=\"file\" id=\"updateHeadImg\" name=\"updateHeadImg\" style=\"display: none\"&gt; &lt;/form&gt; &lt;!-- 触发模态框按钮 --&gt; &lt;button onclick=\"tips()\" th:name=\"$&#123;#authentication.getPrincipal().uId&#125;\" style=\"margin-right: 75px; float: right\" class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#headImgModal\"&gt; &lt;span class=\"glyphicon glyphicon-picture\"&gt;&lt;/span&gt;修改头像 &lt;/button&gt; &lt;script&gt; $(\"#updateHeadImg\").change(function () &#123; //点击“浏览”后会触发隐藏文件表单。监听一旦发生改变则 var file = this.files[0]; // 获取input上传的图片数据; console.log(file); var url = window.URL.createObjectURL(file); // 得到file对象路径，可当成普通的文件路径一样使用，赋值给src; $(\"#headImg\").attr(\"src\", url); //修改模态框的头像 &#125;); // JQ点击提交表单 $(\"#submitBtn\").on(\"click\", function () &#123; var file = $(\"#updateHeadImg\").val(); // 获取input上传的图片数据; if(file!='')&#123; alert(\"修改头像成功，正在前往登录页~\"); $('#updateHeadImgForm').submit(); &#125;else&#123; alert('请先浏览图片！') &#125; &#125;); &lt;/script&gt; 4、简单的模态框的使用//关键点：id，下单按钮的事件绑定 &lt;!--填充收货信息模态框--&gt; &lt;div class=\"modal fade\" id=\"fillInfoModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\"&gt; &lt;div class=\"modal-dialog\" role=\"document\"&gt; &lt;div class=\"modal-content\" style=\"margin: 0 auto;width: 450px\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;h4 class=\"modal-title\" id=\"addTypeModalLabel\"&gt;请编辑收货信息（可前往个人中心修改）：&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;!--模块体填充数据--&gt; &lt;form action=\"\"&gt; &lt;input type=\"hidden\" id=\"fill-uId\" th:value=\"$&#123;#authentication.getPrincipal().uId&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-name\" class=\"control-label\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-name\" th:value=\"$&#123;#authentication.getPrincipal().uName&#125;\" name=\"odName\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-phone\" class=\"control-label\"&gt;手机号：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-phone\" th:value=\"$&#123;#authentication.getPrincipal().uPhone&#125;\" name=\"odPhone\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-address\" class=\"control-label\"&gt;地址：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-address\" th:value=\"$&#123;#authentication.getPrincipal().uAddress&#125;\" name=\"odAddress\" class=\"form-control\" &gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"fill-remarks\" class=\"control-label\"&gt;备注：&lt;/label&gt; &lt;input type=\"text\" id=\"fill-remarks\" name=\"odRemarks\" class=\"form-control\" placeholder=\"有啥要求可以备注说明哦~\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;关闭&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\" onclick=\"toOrder()\"&gt;确认下单&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; function toOrder() &#123; let postData = &#123;&#125;; let uId = $('#fill-uId').val(); let odName = $('#fill-name').val(); let odPhone = $('#fill-phone').val(); let odAddress = $('#fill-address').val(); let odRemarks = $('#fill-remarks').val(); if (odName === \"\") &#123; alert(\"姓名不能为空！\"); return; &#125; if (odPhone === \"\") &#123; alert(\"手机号不能为空\"); return; &#125; if (odAddress === \"\") &#123; alert(\"地址不能为空\"); return; &#125; postData['odName'] = odName; postData['odPhone'] = odPhone; postData['odAddress'] = odAddress; postData['odRemarks'] = odRemarks; postData['uId'] = uId; console.log(postData); $.ajax(&#123; url: \"/toOrder\", type: 'POST', data: postData, success: function (arg) &#123; alert(arg); window.location.reload(); &#125; &#125;); &#125; &lt;/script&gt; 5、表格获取单元数据、简单的删除提示&lt;button class=\"btn btn-warning\" id=\"edit_table_btn\" data-toggle=\"modal\" data-target=\"#edUser\" onclick=\"getData()\"&gt; &lt;span class=\"glyphicon glyphicon-pencil\"&gt;&lt;/span&gt;编辑 &lt;/button&gt; &lt;script&gt; /*被绑定的按钮，先执行onclick，获得表格当前行的值并设置为模态框的值*/ function getData() &#123; $(\"#userInfoTable tbody\").on(\"click\", \"tr\", function () &#123; let data = new Array(); let td = $(this).find(\"td\"); for (let i = 0; i &lt; td.length; i++) &#123; data.push(td.eq(i).text()); &#125; $('#ed-uId').attr('value',data[0]); console.log(data[0]); $('#ed-uUsername').attr('value',data[2]); $('#ed-uPassword').attr('value',data[3]); $('#ed-uName').attr('value',data[4]); $('#ed-uPhone').attr('value',data[5]); $('#ed-uAddress').attr('value',data[6]); &#125;); &lt;/script&gt; &lt;a th:href=\"@&#123;'/deleteUser/'+$&#123;user.getUId()&#125;&#125;\" onClick=\"return confirm('确定删除?');\"&gt; &lt;button class=\"btn btn-danger\"&gt;&lt;span class=\"glyphicon glyphicon-remove\"&gt;&lt;/span&gt; 删除&lt;/button&gt; &lt;/a&gt; 6、翻页&lt;div class=\"container\"&gt; &lt;div class=\"row clearfix\"&gt; &lt;div class=\"col-md-12 column\" style=\"text-align: center;\"&gt; &lt;div style=\"font-size: 16px;color:grey;\"&gt; 总查询到&amp;nbsp;&lt;span th:text=\"$&#123;page.getTotal()&#125;\"&gt;&lt;/span&gt;&amp;nbsp;条数据 &lt;/div&gt; &lt;!--遍历页数--&gt; &lt;!--th:each=\"i:$&#123;#numbers.sequence(1,page.getPages())&#125;\"--&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a th:if=\"$&#123;!page.hasPrevious()&#125;\" href=\"javascript:alert('已经是第一页啦！');\"&gt;上一页&lt;/a&gt; &lt;a th:if=\"$&#123;page.hasPrevious()&#125;\" th:href=\"@&#123;'/userInfo?pageNum='+ $&#123;page.getCurrent() - 1&#125;&#125;\"&gt;上一页&lt;/a&gt; &lt;/li&gt; &lt;li th:each=\"i:$&#123;#numbers.sequence(1,page.getPages())&#125;\"&gt; &lt;a th:if=\"$&#123;page.getCurrent() == i&#125;\" th:href=\"@&#123;'/uuserInfo?pageNum='+ $&#123;i&#125;&#125;\" th:text=\"$&#123;i&#125;\" style=\"background: #aefff8\"&gt;&lt;/a&gt; &lt;a th:if=\"$&#123;!(page.getCurrent() == i)&#125;\" th:href=\"@&#123;'/userInfo?pageNum='+ $&#123;i&#125;&#125;\" th:text=\"$&#123;i&#125;\"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a th:if=\"$&#123;!page.hasNext()&#125;\" href=\"javascript:alert('已经是最后一页啦！');\"&gt;下一页&lt;/a&gt; &lt;a th:if=\"$&#123;page.hasNext()&#125;\" th:href=\"@&#123;'/userInfo?pageNum='+ $&#123;page.getCurrent() + 1&#125;&#125;\"&gt;下一页&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2020年07月12日 晚上Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"MyBatisPlus学习笔记","slug":"MyBatisPlus学习笔记","date":"2020-06-13T08:50:30.000Z","updated":"2020-06-26T13:50:30.000Z","comments":true,"path":"2020/06/13/MyBatisPlus学习笔记/","link":"","permalink":"http://yoursite.com/2020/06/13/MyBatisPlus学习笔记/","excerpt":"","text":"前言：MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！ 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作， BaseMapper 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分CRUD 操作，更有强大的条件构造器，满足各类使用需求, 以后简单的CRUD操作，它不用自己编写了！ 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（自动帮你生成代码） 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速入门1、创建数据库2、创建表(id自增)DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO user (id, name, age, email) VALUES (1, 'Jone', 18, 'test1@baomidou.com'), (2, 'Jack', 20, 'test2@baomidou.com'), (3, 'Tom', 28, 'test3@baomidou.com'), (4, 'Sandy', 21, 'test4@baomidou.com'), (5, 'Billie', 24, 'test5@baomidou.com'); -- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 3、编写项目，初始化项目，使用SpringBoot初始化4、导入依赖&lt;!-- 数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 5、连接数据库spring.datasource.username=root spring.datasource.password=123456 spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 6、编写基本pojo类@Data @AllArgsConstructor @NoArgsConstructor public class User &#123; private Long id; private String name; private Integer age; private String email; &#125; 7、mapper接口@Repository // 代表持久层 public interface UserMapper extends BaseMapper&lt;User&gt; &#123; // 所有的CRUD操作都已经编写完成了 // 你不需要像以前的配置一大堆文件了！ &#125; 注意点：我们需要在主启动类上去扫描我们的mapper包下的所有接口@MapperScan(&quot;com.kuang.mapper&quot;) 测试类： @SpringBootTest class MybatisPlusApplicationTests &#123; // 继承了BaseMapper，所有的方法都来自己父类 // 我们也可以编写自己的扩展方法！ @Autowired private UserMapper userMapper; @Test void contextLoads() &#123; // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; &#125; 配置日志我们所有的sql现在是不可见的，我们希望知道它是怎么执行的，所以我们必须要看日志！mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl CRUD拓展1、插入操作// 测试插入 @Test public void testInsert()&#123; User user = new User(); user.setName(\"狂神说Java\"); user.setAge(3); user.setEmail(\"24736743@qq.com\"); int result = userMapper.insert(user); // 帮我们自动生成id System.out.println(result); // 受影响的行数 System.out.println(user); // 发现，id会自动回填 &#125; ？出现的问题：默认id为全局唯一id：ID_WORKER，是根据雪花算法生成的。 2、主键生成策略雪花算法：snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。可以保证几乎全球唯一！配置id自增方法：1、实体类字段上 @TableId(type = IdType.AUTO)2、数据库自增IdType解释： public enum IdType &#123; AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 &#125; 3、更新操作// 测试更新 @Test public void testUpdate()&#123; User user = new User(); // 通过条件自动拼接动态sql user.setId(6L); user.setName(\"关注公众号：狂神说\"); user.setAge(18); // 注意：updateById 但是参数是一个 对象！ int i = userMapper.updateById(user); System.out.println(i); &#125; 4、自动填充机制：创建时间、更新时间创建时间、修改时间！这些个操作一遍都是自动化完成的，我们不希望手动更新！阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化！ 方式一：修改数据库设置（工作中不允许你直接修改数据库） 1、在表中新增字段 create_time, update_time（提供更新）2、再次测试插入方法，我们需要先把实体类同步！private Date createTime; private Date updateTime; 方式二：代码操作 1、只添加字段2、实体类字段属性上需要增加注解// 字段添加填充内容 @TableField(fill = FieldFill.INSERT) private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private Date updateTime; 3、处理器类处理注解package com.kuang.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j //日志注解 @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler &#123; // 插入时的填充策略 @Override public void insertFill(MetaObject metaObject) &#123; log.info(\"start insert fill.....\"); // setFieldValByName(String fieldName, Object fieldVal, MetaObject metaObject this.setFieldValByName(\"createTime\",new Date(),metaObject); this.setFieldValByName(\"updateTime\",new Date(),metaObject); &#125; // 更新时的填充策略 @Override public void updateFill(MetaObject metaObject) &#123; log.info(\"start update fill.....\"); this.setFieldValByName(\"updateTime\",new Date(),metaObject); &#125; &#125; 4、测试插入、更新操作 5、乐观锁 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题，再次更新值测试悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！ 实现原理：添加version字段 取出记录时，获取当前 version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 乐观锁：1、先查询，获得版本号 version = 1 -- A update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 -- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！ update user set name = \"kuangshen\", version = version + 1 where id = 2 and version = 1 1、数据库添加version字段，int，默认值为12、实体类添加对应的字段@Version //乐观锁Version注解 private Integer version; 3、注册插件：编写配置类，把扫描声明放来这里，添加事务管理注解// 扫描我们的 mapper 文件夹 @MapperScan(\"com.kuang.mapper\") @EnableTransactionManagement @Configuration // 配置类 public class MyBatisPlusConfig &#123; // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; &#125; 4、测试// 测试乐观锁成功！ @Test public void testOptimisticLocker()&#123; // 1、查询用户信息 User user = userMapper.selectById(1L); // 2、修改用户信息 user.setName(\"kuangshen\"); user.setEmail(\"24736743@qq.com\"); // 3、执行更新操作 userMapper.updateById(user); &#125; // 测试乐观锁失败！多线程下 @Test public void testOptimisticLocker2()&#123; // 线程 1 User user = userMapper.selectById(1L); user.setName(\"kuangshen111\"); user.setEmail(\"24736743@qq.com\"); // 模拟另外一个线程执行了插队操作 User user2 = userMapper.selectById(1L); user2.setName(\"kuangshen222\"); user2.setEmail(\"24736743@qq.com\"); userMapper.updateById(user2); // 自旋锁来多次尝试提交！ userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！ &#125; 6、查询操作// 测试查询 @Test public void testSelectById()&#123; User user = userMapper.selectById(1L); System.out.println(user); &#125; // 测试批量查询！ @Test public void testSelectByBatchId()&#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); users.forEach(System.out::println); &#125; // 按条件查询之一使用map操作 @Test public void testSelectByBatchIds()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 自定义要查询 map.put(\"name\",\"狂神说Java\"); map.put(\"age\",3); List&lt;User&gt; users = userMapper.selectByMap(map); users.forEach(System.out::println); &#125; 7、分页查询（内置）1、配置组件// 分页插件 @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125; 2、直接使用Page对象// 测试分页查询 @Test public void testPage()&#123; // 参数一：当前页 // 参数二：页面大小 // 使用了分页插件之后，所有的分页操作也变得简单的！ Page&lt;User&gt; page = new Page&lt;&gt;(2,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal()); &#125; 8、删除操作1、根据id删除记录// 测试删除 @Test public void testDeleteById()&#123; userMapper.deleteById(1240620674645544965L); &#125; // 通过id批量删除 @Test public void testDeleteBatchId()&#123; userMapper.deleteBatchIds(Arrays.asList(1L,2L)); &#125; // 通过map删除 @Test public void testDeleteMap()&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\",\"狂神说Java\"); userMapper.deleteByMap(map); &#125; 9、逻辑删除 物理删除 ：从数据库中直接移除逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1 管理员可以查看被删除的记录！防止数据的丢失，类似于回收站！（原理：更新deleted字段，但同时查询也是将无结果）1、在数据表中增加一个 deleted 字段（int 默认0）2、实体类中增加属性@TableLogic //逻辑删除 private Integer deleted; 3、配置组件// 逻辑删除组件！ @Bean public ISqlInjector sqlInjector() &#123; return new LogicSqlInjector(); &#125; # 配置逻辑删除 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 10、性能分析插件我们在平时的开发中，会遇到一些慢sql。测试！ druid……作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间，MyBatisPlus也提供性能分析插件，如果超过这个时间就停止运行！1、导入插件/** * SQL执行效率插件 */ @Bean @Profile(&#123;\"dev\",\"test\"&#125;)// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() &#123; PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不执行 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; &#125; 记住，要在SpringBoot中配置环境为dev或者 test 环境！2、测试使用@Test void contextLoads() &#123; // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); users.forEach(System.out::println); &#125; 11、条件构造器十分重要：Wrapper我们写一些复杂的sql就可以使用它来替代！1、限定非空条件@Test void contextLoads() &#123; // 查询name不为空的用户，并且邮箱不为空的用户，年龄大于等于12 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper .isNotNull(\"name\") .isNotNull(\"email\") .ge(\"age\",12); userMapper.selectList(wrapper).forEach(System.out::println); // 和我们刚才学习的map对比一下 &#125; 2、限定字段等于某个值@Test void test2()&#123; // 查询名字狂神说 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(\"name\",\"狂神说\"); User user = userMapper.selectOne(wrapper); // 查询一个数据，出现多个结果使用List或者 Map System.out.println(user); &#125; 3、限定字段值为某个区间@Test void test3()&#123; // 查询年龄在 20 ~ 30 岁之间的用户 QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.between(\"age\",20,30); // 区间 Integer count = userMapper.selectCount(wrapper);// 查询结果数 System.out.println(count); &#125; 4、模糊查询// 模糊查询 @Test void test4()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 左和右 t% wrapper .notLike(\"name\",\"e\") .likeRight(\"email\",\"t\"); List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(wrapper); maps.forEach(System.out::println); &#125; 5、id条件从子查询中得来@Test void test5()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // id 在子查询中查出来 wrapper.inSql(\"id\",\"select id from user where id&lt;3\"); List&lt;Object&gt; objects = userMapper.selectObjs(wrapper); objects.forEach(System.out::println); &#125; 6、根据id进行排序@Test void test6()&#123; QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); // 通过id进行升序排序 wrapper.orderByAsc(\"id\"); List&lt;User&gt; users = userMapper.selectList(wrapper); users.forEach(System.out::println); &#125; 12、代码自动生成器dao、pojo、service、controller都给我自己去编写完成！AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 代码：package com.kuang; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.IdType; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; import com.baomidou.mybatisplus.generator.config.GlobalConfig; import com.baomidou.mybatisplus.generator.config.PackageConfig; import com.baomidou.mybatisplus.generator.config.StrategyConfig; import com.baomidou.mybatisplus.generator.config.po.TableFill; import com.baomidou.mybatisplus.generator.config.rules.DateType; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import java.util.ArrayList; // 代码自动生成器 public class KuangCode &#123; public static void main(String[] args) &#123; // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath+\"/src/main/java\"); gc.setAuthor(\"狂神说\"); gc.setOpen(false); gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(\"%sService\"); // 去Service的I前缀 gc.setIdType(IdType.ID_WORKER); gc.setDateType(DateType.ONLY_DATE); gc.setSwagger2(true); mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/kuang_community? useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(\"blog\"); pc.setParent(\"com.kuang\"); pc.setEntity(\"entity\"); pc.setMapper(\"mapper\"); pc.setService(\"service\"); pc.setController(\"controller\"); mpg.setPackageInfo(pc); //4、策略配置（只需要改这里的表名即可） StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(\"blog_tags\",\"course\",\"links\",\"sys_settings\",\"user_record\",\"user_say\"); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 自动lombok； strategy.setLogicDeleteFieldName(\"deleted\"); //5、自动填充配置 TableFill gmtCreate = new TableFill(\"gmt_create\", FieldFill.INSERT); TableFill gmtModified = new TableFill(\"gmt_modified\", FieldFill.INSERT_UPDATE); ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;(); tableFills.add(gmtCreate); tableFills.add(gmtModified); strategy.setTableFillList(tableFills); //6、乐观锁 strategy.setVersionFieldName(\"version\"); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); // localhost:8080/hello_id_2 mpg.setStrategy(strategy); mpg.execute(); //执行 &#125; &#125; 2020年06月13日 晚上Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"JavaScript的简单回顾","slug":"JavaScript的简单回顾","date":"2020-06-09T08:50:30.000Z","updated":"2020-08-04T13:50:30.000Z","comments":true,"path":"2020/06/09/JavaScript的简单回顾/","link":"","permalink":"http://yoursite.com/2020/06/09/JavaScript的简单回顾/","excerpt":"","text":"前言：教学视频、笔记参考 一、快速入门1.1、两种引入方式内部标签&lt;script&gt; //.... &lt;script&gt; 外部引入&lt;script src=\"js/myjs.js\"&gt;&lt;/script&gt; 1.2、基本语法&lt;script&gt; &lt;!--JavaScript严格区分大小写--&gt; var score = 1 ; if (score &gt; 60 &amp;&amp; score &lt; 70)&#123; alert(\"60~70\"); &#125;else if(score &gt; 70 &amp;&amp; score &lt; 80)&#123; alert(\"70~80\"); &#125;else&#123; alert(\"other\") &#125; &lt;/script&gt; 1.3、数据类型· 变量：var a · number：js不区分小树和整数 · 字符串：'abc' \"abc\" · 布尔值：true | false · 逻辑运算： &amp;&amp; 两个都为真，结果为真 || 一个为真，结果为真 ! 真即假，假即真 · 比较运算符： == 等于（类型不一样，值一样，也会判断为true） === 绝对等于（类型一样，值一样，结果为true） · NaN === NaN，这个与所有的数值都不相等，包括自己 只能通过isNaN（NaN）来判断这个数是否是NaN · 尽量避免使用浮点数进行运算，存在精度问题！ · null 空 · undefined 未定义 · Java的数组必须是相同类型的对象~，JS中不需要这样 //保证代码的可读性，尽量使用[] var arr = [1,2,3,4,5,'hello',null,true]; //第二种定义方法 new Array(1,2,3,4,5,'hello'); · 对象 var person = &#123; name:'Tom', age:3, tags:['js','java','web','...'] &#125; · 取对象值 person.name &gt; \"Tom\" person.age &gt; 3 1.4、严格检查模式改用ES6&lt;script&gt; 'use strict'; //全局变量 let i=1 //ES6 let &lt;/script&gt; 二、数据类型2.1、字符串特殊转义字符\\' \\n \\t \\u4e2d \\u##### Unicode字符 \\x41 Ascall字符 多换字符串编写var msg = `hello world 你好呀 nihao ` 模板字符串let name = 'Tom'; let age = 3; var msg = `你好，$&#123;name&#125;` //tab 上面 esc下面 字符串长度str.length 大小写转换//注意，这里是方法，不是属性了 student.toUpperCase(); student.toLowerCase(); 取下标student.indexof('t') 切片substring，从0开始，取左不取右 student.substring(1)//从第一个字符串截取到最后一个字符串 student.substring(1,3)//[1,3) 2.2、数组Array可以包含任意的数据类型var arr = [1,2,3,4,5,6];//通过下标取值和赋值 长度arr.length //注意：假如给arr.lennth赋值，数组大小就会发生变化~，如果赋值过小，元素就会丢失 indexOf，通过元素获得下标索引arr.indexOf(2) 1 //字符串的\"1\"和数字 1 是不同的 slice()：截取Array的一部分，返回的一个新数组，类似于String中substring push()，pop() 进出栈原理push：压入到尾部 pop：弹出尾部的一个元素 unshift(),shift() 头部unshift：压入到头部 shift：弹出头部的一个元素 排序sort()(3)[\"B\",\"C\",\"A\"] arr.sort() (3)[\"A\",\"B\",\"C\"] 元素反转reverse()(3)[\"A\",\"B\",\"C\"] arr.reverse() (3)[\"C\",\"B\",\"A\"] concat()注意：concat()并没有修改数组，只是会返回一个新的数组 var a = [1,2,3] a.concat(4,5) 连接符join()在本例中，我们将创建一个数组，然后把它的所有元素放入一个字符串： &lt;script type=\"text/javascript\"&gt; var arr = new Array(3) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr.join()) &lt;/script&gt; =&gt; George,John,Thomas ------------------------------------------------ 在本例中，我们将使用分隔符来分隔数组中的元素： &lt;script type=\"text/javascript\"&gt; var arr = new Array(3) arr[0] = \"George\" arr[1] = \"John\" arr[2] = \"Thomas\" document.write(arr.join(\".\")) &lt;/script&gt; George.John.Thomas 多维数组：同java 2.3、对象基本格式var 对象名 = &#123; 属性名：属性值， 属性名：属性值， 属性名：属性值 &#125; //定义了一个person对象，它有四个属性 var person = &#123; name:\"Tom\", age:3, email:\"123456798@QQ.com\", score:66 &#125; 使用一个不存在的对象属性，不会报错！undefinedperson.haha &gt;&gt;&gt; undefined 动态的删减属性，通过delete删除对象属性delete person.name true 动态添加，直接给新的属性添加值即可person.haha = 'haha'; 'haha' 判断属性是否在这个对象中！xxx in xxx'age' in person true //继承 'toString' in person true 判断一个属性是否是这个对象自身拥有的：hasOwnProperty()person.hasOwnProperty('toString') false person.hasOwnProperty('age') true 2.4、流程控制if、while、for同Javavar age = 3; if(age&gt;3)&#123; alert(3); &#125;else if(age&lt;5)&#123; alert(5); &#125;else&#123; alert(haha); &#125; while(age &lt; 100)&#123; age = age + 1; console.log(age); &#125; for(let i = 0;i &lt; 100; i++)&#123; console.log(i); &#125; forEach循环var age = [12,3,45,123,5,3,6,4,8] age.forEach(function (value) &#123; console.log(value); &#125;) for…infor(var index in age)&#123; console.log(age[index]); &#125; 2.5、Map 和 Set ES6的新特性Map//ES6 //学成的成绩，学生的名字 var names = ['tom','jack','sam']; var scores = [100,90,80]; var map = new Map([['tom',100],['jack',90],['sam',80]]) var name = map.get('tom'); console.log(name);// map.set('admin',123456);//新增元素 console.log(map);//Map(4)&#123;\"tom\" =&gt; 100, \"jack\" =&gt; 90, \"sam\" =&gt; 80, \"admin\" =&gt; 123456&#125; map.delete('tom');//删除元素 console.log(map);//Map(3)&#123;\"jack\" =&gt; 90, \"sam\" =&gt; 80, \"admin\" =&gt; 123456&#125; Set：无需不重复的集合//set可以去重 var set = new Set([3,1,1,1,1,2]); set.add(4);//添加 console.log(set);//Set(4) &#123;3, 1, 2, 4&#125; set.delete(1);//删除 console.log(set);//Set(3) &#123;3, 2, 4&#125; console.log(set.has(3));//是否包含某个元素 2.6、Iterator遍历数组//通过for of / for in 下标 var arr = [3,4,5]; for(var x of arr)&#123; console.log(x) &#125; //存在一个bug arr.name = 123; for(var x of arr)&#123; console.log(x) &#125; 输出: 1 2 3 name 遍历map//遍历map for(let x of map)&#123; console.log(x); &#125; 遍历set//遍历set for(let x of set)&#123; console.log(x); &#125; 三、函数3.1、定义函数方式一function abs(x)&#123; return x; &#125; //一旦执行到return代表函数结束，返回结果。 //如果没有执行return，函数执行完也会返回结果，返回就是undefined 方式二var abs = function(x)&#123; return x; &#125; //function(x),这是一个匿名函数，但是赋值给abs。所以通过abs可以调用 参数问题//jJavaScript可以传任意个参数，也可以不传递参数。 //参数进来是否存在的问题？假设不存在参数，如何规避？ var abs = function (x) &#123; //参数个数 console.log(arguments.length); //手动抛出异常 if (typeof x !=='number')&#123; throw 'Not a Number'; &#125; return x; &#125; //arguments：代表传递进来所有的参数，是一个数组 问题：arguments 包含所有的参数，我们有时候想使用多余的参数来进行附加操作，需要排除已有参数//rest：获去除了已经定义的参数，ES6引入的新特性 function arg(a,b,...rest) &#123; console.log(a); console.log(b); console.log(rest); &#125; //rest参数只能写在最后面，必须用…标识 3.2、变量的作用域在Javascript中，var定义变量实际是有作用域的。假设在函数体中声明，则在函数体外不可以使用~（如果想要实现，则需要闭包）function abc() &#123; var x= 1; x = x + 1; &#125; x = x + 2 ;//Uncaught ReferenceError: x is not defined 如果两个函数使用相同变量名，只要在函数内部，就不冲突function abc1() &#123; var x= 1; x = x + 1; &#125; function abc2() &#123; var x= 2; x = x + 1; &#125; 内部函数可以询问外部函数的成员，反之则不行function abc3() &#123; var x= 1; //内部函数可以询问外部函数的成员，反之则不行 function abc3() &#123; var y = x + 1;//2 &#125; var z = y + 1;//Uncaught ReferenceError: x is not defined &#125; 假设：内部函数变量与外部函数变量重名function abc5() &#123; var x = 1; function abc6() &#123; var x = A; console.log('inner' + x);//outer1 &#125; console.log('outer'+x);//innerA abc6(); &#125; //不冲突，自己有就用自己的 提升变量作用域function abc8() &#123; var x = 'x' + y; console.log(x); var y = 'y'; &#125; //结果：undefined //说明：js执行引擎，自动提升了y的声明，但是不会提升y的赋值 function abc8() &#123; var y; var x = 'x' + y; console.log(x); y = 'y'; &#125; //这是在Javascript简历之初就存在的特性。养成规范：所有的变量定义都放在函数头部，不要乱放，便于代码维护； function abc()&#123; var x = 1, y = x + 1, z,i,a;//undefined &#125; 全局函数//全局变量 x = 1; function f()&#123; console.log(x); &#125; f(); console.log(x); 全局对象：windowvar x = 'xxx'; alert(x); alert(windws.x); //alert()这个函数本身也是一个window变量： var x = 'xxx'; window.alert(x); var old_alert = window.alert; // old_alert(x); window.alert = function () &#123; &#125;; //发现alert()失效了 window.alert(123); //恢复 window.alert = old_alert; window.alert(456); //Javascript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围，就会向外查找，如果在全局作用域都没有找到，报错RefrenceError 规范：由于我们所有的全局变量都会绑定到我们的window上。如果不同的js文件，使用了相同的全局变量，冲突-&gt;如何能够减少冲突？//唯一全局变量 var LiusxApp = &#123;&#125;; //定义全局变量 LiusxApp.name = 'xiaoming'; LiusxApp.add = function (a,b) &#123; return a + b; &#125; //把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突的问题。（jQuery） 局部作用域：letfunction aaa()&#123; for(var i = 0; i &lt; 100 ;i++)&#123; console.log(i); &#125; console.log(i+1);//问题，i 出了这个作用域还可以使用 &#125; //ES6：let关键字，解决局部作用域冲突问题！ function aaa()&#123; for(let i = 0; i &lt; 100 ;i++)&#123; console.log(i); &#125; console.log(i+1);//问题，i 出了这个作用域即刻失效 &#125; //建议大家都用let取定义局部作用域的变量 const：ES6之前，怎么定义常量：只有用全部大写字母命名的变量就是常量：建议不要修改这样的值const PI = '3.14';//只读效果 console.log(PI); PI = '123';//Uncaught TypeError: Assignment to constant variable. console.log(PI); 3.3、方法定义方法（方法就是把函数放在对象里面，对象中只有2个东西：属性和方法）var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: function () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; &#125; //属性 liusx.name; //方法，一定要带() liusx.age(); this的使用：没有上下午关系直接使用会NaN，但可以添加指向var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: function () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; &#125; //属性 liusx.name; //方法，一定要带() liusx.age(); function getAge () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: getAge &#125; //liusx.age() =&gt;ok //getAge() =&gt;NaN 控制this的指向function getAge () &#123; var now = new Date().getFullYear(); return now-this.bitrh; &#125; var liusx = &#123; name: 'Sam', bitrh: 2020, //方法 age: getAge &#125; //liusx.age() =&gt;ok //getAge() =&gt;NaN getAge.apply(liusx,[])//this，指向了liusx，参数为空 四、内部对象标准对象typeof 123 \"number\" typeof '123' \"string\" typeof true \"boolean\" typeof NaN \"number\" typeof [] \"object\" typeof &#123;&#125; \"object\" typeof Math.abs \"function\" typeof undefined \"undefined\" 4.1、Date的基本使用var now = new Date();// now.getFullYear();//年 now.getMonth();//月 now.getDate();//日 now.getDay();//星期几 now.getHours();//时 now.getMinutes();//分 now.getSeconds();//秒 now.getTime();//时间戳 全世界统一 1970 1.1 8:00:00 console.log(new Date(1589096655409));//时间戳转时间 //转换 //本地时间 now.toLocaleString(); \"2020/5/10 下午3:44:15\" //东八区 now.toGMTString(); \"Sun, 10 May 2020 07:44:15 GMT\" 4.2、JSON//JSON 字符串和 JS 对象的转换 var user = &#123; name: 'liusx', age: 3, sex: '男' &#125; //对象转换json字符串:&#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125; var jsonuUer = JSON.stringify(user); console.log(jsonuUer); //json 字符串转换为对象，参数为json字符串 var obj = JSON.parse('&#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125;'); console.log(obj); //JSON 和 JS 对象的区别： var obj = &#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125;; var json = '&#123;\"name\":\"liusx\",\"age\":3,\"sex\":\"男\"&#125;'; 4.3、Ajax原生的Javascript写法，xhr异步请求 jQuery封装好的方法 axios请求 五、原型5.1、原型的概念（类似Java继承）//面向对象 var Student = &#123; name: 'liusx', age: 3, run:function () &#123; console.log(this.name+\"run.....\") &#125; &#125; var xiaoming = &#123; name: '小明' &#125; //小明的原型 是Student xiaoming.__proto__ = Student; //把属性继承给小明 xiaoming.run(); var Bird = &#123; fly: function () &#123; console.log(this.name + \"fly......\") &#125; &#125; //小明的原型 是Bird xiaoming.__proto__ = Bird; 5.2、class继承：class关键字，ES6引入//class继承 function Student(name) &#123; this.name = name; &#125; //给student新增一个方法 Student.prototype.hello = function () &#123; alert('hello'); &#125; 1、定义一个类，属性，方法//ES6 之后======极度类似Java class Student&#123; constructor(name)&#123; this.name = name; &#125; hello()&#123; alert('hello'); &#125; &#125; var xiaoming = new Student('小明'); var xiaoming = new Student('小红'); xiaoming.hello(); 2、继承//ES6 之后======极度类似Java class Student&#123; constructor(name)&#123; this.name = name; &#125; hello()&#123; alert('hello'); &#125; &#125; class XiaoStudent extends Student &#123; constructor(name,grade)&#123; super(name); this.grade = grade; &#125; myGrade()&#123; alert('我是一名小学生'); &#125; &#125; var xiaoming = new Student('小明'); xiaoming.hello(); var xiaohong = new XiaoStudent('小红',1); xiaohong.myGrade(); 5.3、原型链__proto__ //无限套娃，形成了链 六、操作BOM对象（重点）6.1、window（重要）：代表浏览器窗口window.alert(1) undefined window.innerHeight 722 window.innerWidth 1148 window.outerHeight 824 window.outerWidth 1536 // 大家可以调整浏览器窗口试试 6.2、Navigator：封装了浏览器信息//大多数时候，我们不会使用：Navigator 对象，因为会被认为修改！不建议使用这些属性判断和编写代码 navigator.appName \"Netscape\" navigator.appVersion \"5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\" navigator.userAgent \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36\" navigator.platform \"Win32\" 6.3、screen：代表屏幕尺寸screen.width 1536 screen.height 864 6.4、location（重要）：代表当前页面的URL信息host:\"www.baidu.com\" href:\"https://www.baidu.com/\" proticlo:\"https\" reload:f reload()// 刷新网页 // 设置新的地址 location.assign('https://Guzhz.github.io/') 6.5、document（内容：DOM）：代表当前页面，HTML DOM文档树document.title \"百度一下，你就知道\" 6.6、获取具体的文档数节点&lt;dl id=\"app\"&gt; &lt;dt&gt;Java&lt;/dt&gt; &lt;dt&gt;JavaSE&lt;/dt&gt; &lt;dt&gt;JavaScript&lt;/dt&gt; &lt;/dl&gt; &lt;script&gt; var dl = document.getElementById('app'); &lt;/script&gt; 6.7、获取：cookiedocument.cookie //劫持cookie原理 &lt;script src=\"aa.js\"&gt;&lt;/script&gt; &lt;!--恶意人员：获取你的cookie上传到它的服务器--&gt; //服务器端可以设置cookie：httpOnly 6.8、history（不建议使用）：代表浏览器的历史记录histor.forward();//前进 history.back();//后退 七、操作DOM对象（重点）7.1、获得Dom节点&lt;div id=\"father\"&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var h1 = document.getElementsByTagName(\"h1\"); //返回数组 var p1 = document.getElementById(\"p1\") var p2 = document.getElementsByClassName(\"p2\"); //返回数组 var father = document.getElementById(\"father\"); //获取父节点下所有的子节点 var childrens = father.children; //father.firstChild; //father.lastChild; &lt;/script&gt; 7.2、更新节点&lt;div id=\"id1\"&gt; &lt;/div&gt; &lt;script&gt; var id1 = document.getElementById('id1'); id1.innerText='456';//修改文本的值 id1.innerHTML='&lt;strong&gt;456&lt;/strong&gt;';//可以解析HTML文本标签 //操作CSS id1.style.color = 'yellow';// 属性使用 字符串 包裹 id1.style.fontSize = '20px';// - 转 驼峰命名问题 id1.style.padding = '2em' &lt;/script&gt; 7.3、删除节点：先获取父节点，再通过父节点删除自己&lt;div id=\"father\"&gt; &lt;h1&gt;标题一&lt;/h1&gt; &lt;p id=\"p1\"&gt;p1&lt;/p&gt; &lt;p class=\"p2\"&gt;p2&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var self = document.getElementById(\"p1\") var father = p1.parentElement; father.removeChild(self); //删除是一个动态的过程，先删除0，在删除2会找不到2节点，因为会重新排序 father.removeChild(father.children[0]); father.removeChild(father.children[1]) father.removeChild(father.children[2]) &lt;/script&gt; 7.4、插入节点我们获得了某个Dom节点，假设这个dom节点是空的，我们通过 innerHTML 就可以增加一个元素，但是如果这个DOM节点已经存在元素了，则会直接覆盖。追加：appendChild()&lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var js = document.getElementById('js'); var list = document.getElementById('list'); //追加到后面 list.appendChild(js); &lt;/script&gt; ----- 追加后效果为： &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;/div&gt; 创建一个新的标签，实现插入&lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js');//已经存在的节点 let list = document.getElementById('list'); //追加到后面 //list.appendChild(js); //通过JS 创建一个新的节点 let newP = document.createElement('p'); newP.id = 'newP'; newP.innerText = 'Hello,Sam'; list.appendChild(newP); //创建一个标签节点 let myScript = document.createElement('script'); myScript.setAttribute('type', 'text/javascript'); //给body标签创建样式1 let body = document.getElementsByTagName('body')[0]; body.setAttribute('style', 'background-color: yellow;'); //给body标签创建样式2 //let myStyle = document.createElement('style');//创建一个style标签 //myStyle.setAttribute('tyle', 'text/css'); //myStyle.innerHTML = 'body&#123;background-color: chartreuse;&#125;';//设置样式 //document.getElementsByTagName('head')[0].appendChild(myStyle); &lt;/script&gt; ---------------------------------------------------------------- 追加后效果为： &lt;body style=\"background-color: yellow;\"&gt; &lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;p id=\"newP\"&gt;Hello,Sam&lt;/p&gt; &lt;script type=\"text/javascript\"&gt;&lt;/script&gt; &lt;/div&gt; &lt;/body&gt; insertBefore()追加&lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let js = document.getElementById('js');//已经存在的节点 let list = document.getElementById('list'); let ee = document.getElementById('ee'); //要包含的节点. insertBefore(newNode,targetNode) list.insertBefore(js, ee); &lt;/script&gt; ---- 追加后效果为： &lt;body&gt; &lt;div id=\"list\"&gt; &lt;p id=\"se\"&gt;JavaSE&lt;/p&gt; &lt;p id=\"js\"&gt;Javascript&lt;/p&gt; &lt;p id=\"ee\"&gt;JavaEE&lt;/p&gt; &lt;p id=\"me\"&gt;JavaME&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 八、操作表单（验证）8.1、表单：form DOM树文本框：text 下拉框：select 单选框：radio 多选框：checkbox 隐藏域：hidden 密码框：password … 表单的目的：提交信息 8.2、获得要提交的信息&lt;form action=\"#\" method=\"post\"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=\"text\" id=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type=\"radio\" name=\"sex\" value=\"man\" id=\"boy\"&gt;男 &lt;input type=\"radio\" name=\"sex\" value=\"woman\" id=\"girl\"&gt;女 &lt;/p&gt; &lt;script&gt; var input_text = document.getElementById('username'); //得到输入框的值：input_text.value //修改输入框的值：input_text.value = wudi var boy_radio = document.getElementById('boy'); var girl_radio = document.getElementById('girl'); //对于单选框、多选框等等固定的值， boy_radio.checked;//查看返回的结果，是否为true，如果为true，则被选中 girl_radio.checked = true;//赋值 &lt;/script&gt; &lt;/form&gt; //提交表单：MD5加密，表单优化 8.3、一般MD5加密&lt;script&gt; function sub() &#123; let username = document.getElementById('username'); let password = document.getElementById('password'); console.log(username); console.log(password); // MD5 算法 方案一： password.value = md5(password.value); console.log(password.value); &#125; &lt;/script&gt; //隐藏密码框+MD5加密： &lt;!-- 表单绑定提交事件 onsubmit = 绑定一个提交检查的函数，true，false 将这个结果返回给表单，使用 onsubmit 接收！ οnsubmit=\"return sub();\" --&gt; &lt;form action=\"#\" method=\"post\" onsubmit=\"return sub();\"&gt; &lt;p&gt; &lt;span&gt;用户名：&lt;/span&gt;&lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/p&gt; &lt;p&gt; &lt;span&gt;密码：&lt;/span&gt;&lt;input type=\"password\" id=\"password\"&gt; &lt;input type=\"hidden\" id=\"md5-password\" name=\"password\"&gt; &lt;/p&gt; &lt;button type=\"submit\" &gt;提交&lt;/button&gt; &lt;script&gt; function sub() &#123; let username = document.getElementById('username'); let password = document.getElementById('password'); let md5password = document.getElementById('md5-password'); //MD5 算法：隐藏表单域提交表单密码 md5password.value = md5(password.value); //可以校验判断表单内容，true：通过提交，false：阻止提交 return true; &#125; &lt;/script&gt; &lt;/form&gt; 九、jQuery jQuery API：http://jquery.cuishifeng.cn/ 9.1、初始jQuery（直接引用、使用js文件）&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"\" id=\"test-jquery\"&gt;点我&lt;/a&gt; &lt;script&gt; $('#test-jquery').click(function () &#123; alert('hello,jQuery') &#125;) &lt;/script&gt; &lt;/body&gt; 9.2、选择器&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //原生js，选择器少，麻烦且不好记 //id、标签、类 document.getElementById(); document.getElementsByTagName(); document.getElementsByClassName(); //jQuery 就是 css中的选择器 $('#id').click();//id选择器 $('div').click();//标签选择 $('.className').click();//class选择器 &lt;/script&gt; 9.3、操作DOM/* 节点文本操作; css操作; 元素的显示和隐藏：本质 display=none; …等等更多查看API */ &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"test-ul\"&gt; &lt;li id=\"js\" class=\"js\"&gt;Javascript&lt;/li&gt; &lt;li name=\"python\"&gt;Python&lt;/li&gt; &lt;li id=\"sh\"&gt;show_hide&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(\"#test-ul li[name='python']\").text();//获得值 $(\"#test-ul li[name='python']\").text('Python_new'); $('#test-ul').html();//获得值 $('test-ul').html('&lt;strong&gt;html_new&lt;/strong&gt;');//设置值 $('#js').css('color','red');//设置样式 $('#sh').show();//显示 $('#sh').hide();//隐藏 $(window).width(); $(window).height(); $(document).width(); $(document).height(); &lt;/script&gt; &lt;/body&gt; 2020年06月09日 晚上Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"CSS3的简单回顾","slug":"CSS3的简单回顾","date":"2020-06-08T08:49:04.000Z","updated":"2020-08-04T06:56:47.000Z","comments":true,"path":"2020/06/08/CSS3的简单回顾/","link":"","permalink":"http://yoursite.com/2020/06/08/CSS3的简单回顾/","excerpt":"","text":"前言：教学视频参考 1、CSS3的三种导入方式 优先级：就近原则 &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;!--内部样式--&gt; &lt;style&gt; h1 &#123; color: green; &#125; &lt;/style&gt; &lt;!--外部样式--&gt; &lt;link rel=\"stylesheet\" href=\"css/style.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--行内样式：在标签元素中，编写一个style属性，编写样式即可--&gt; &lt;h1 style=\"color: red\"&gt;这是标签&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 拓展：CSS2.1导入式 &lt;style&gt; @import url(\"css/style.css\"); &lt;/style&gt; 2、选择器2.1、基本选择器标签选择器：选择一类标签 标签.&#123; &#125; class选择器：.类名&#123; &#125; id选择器：#.ID名&#123; &#125; 2.2、层次选择器 后代选择器，在某个元素的后面 &lt;style&gt; body p &#123; background: red; &#125; &lt;/style&gt; 子选择器，一代 &lt;style&gt; body&gt;p &#123; background: orange; &#125; &lt;/style&gt; 相邻兄弟选择器：只有一个，相邻（向下） &lt;style&gt; .active+p &#123; background: red &#125; &lt;/style&gt; &lt;body&gt; &lt;p class=\"active\"&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/body&gt; 通用兄弟选择器，当前选中元素的向下的所有兄弟元素 &lt;style&gt; .active~p &#123; background: red; &#125; &lt;/style&gt; &lt;body&gt; &lt;p class=\"active\"&gt;p1&lt;p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;/body&gt; 2.3、结构伪类选择器 ul的第一个子元素 ul li:first-child &#123; background: aqua; &#125; ul的最后一个子元素 ul li:last-child &#123; background: blue; &#125; 选中pfather：定位到父元素，选择当前的第一个子元素p，子元素的第一位必须为p才生效 pfather:nth-child(1) &#123; background: orange; &#125; 选中父元素下的，第2个p元素 p:nth-of-type(2) &#123; background: red; &#125; 2.4、属性选择器（常用） class + id 结合 &lt;style&gt; .demo a &#123; display: block; height: 50px; width: 50px; float: left; border-radius: 10px; background: blue; text-align: center; color: beige; text-decoration: none; margin-right: 5px; font: bold 20px/50px Arial; &#125; &lt;/style&gt; 标签名[属性名=属性值]（正则: =、*=、^=、$=） &lt;style&gt; /*存在id的a标签*/ a[id] &#123; background: red; &#125; /* =表示绝对等于 *=表示包含... ^=表示以...开头 $=表示以...结尾 */ /*id=first的a标签*/ a[id=first] &#123; background: aqua; &#125; /*class属性值绝对等于\"links item2 first2\"*/ a[class=\"links item2 first2\"] &#123; background: orange; &#125; /*class属性值绝对包涵\"links\"*/ a[class *=\"links\"] &#123; background: black; &#125; /*选中href中以http开头的元素*/ a[href^=\"http\"] &#123; background: orange; &#125; &lt;/style&gt; &lt;p class=\"demo\"&gt; &lt;a href=\"http://www.baidu.com\" class=\"links item first\" id=\"first\"&gt;1&lt;/a&gt; &lt;a href=\"/adad/faf\" class=\"links item2 first2\"&gt;2&lt;/a&gt; &lt;a href=\"qwe123\" class=\"links item3 first3\"&gt;3&lt;/a&gt; &lt;a href=\"eweqe\" class=\"links item4 first4\"&gt;4&lt;/a&gt; &lt;a href=\"rrrrr\" class=\"links item5 first5\"&gt;5&lt;/a&gt; &lt;a href=\"ttt\" class=\"links item6 first6\"&gt;6&lt;/a&gt; &lt;a href=\"yyy\" class=\"links item7 first7\"&gt;7&lt;/a&gt; &lt;/p&gt; 3、美化网页元素3.1、字体 建立在标签上的处理，所以建议用span包裹 &lt;head&gt; &lt;style&gt; #title1 &#123; font-size: 50px; font-weight：blod; font-family: 楷体; /*常用写法：*/ font: oblique bloder 12px \"楷体\" &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span id=\"title1\"&gt;JAVA&lt;/span&gt; &lt;/body&gt; 3.2、文本 下划线 text-decoration:underline /*下划线*/ text-decoration:line-through /*中划线*/ text-decoration:overline /*上划线*/ text-decoration:none /*超链接去下划线*/ 图片、文字水平居中 img,span &#123; vertical-align: middle &#125; 3.3、文本，阴影和超链接伪类 超链接伪类 &lt;style&gt; /*超链接有默认的颜色*/ a &#123; text-decoration: none; color: #000000; &#125; a:hover &#123; /*鼠标悬浮的状态*/ color: orange; &#125; a:active &#123; /*鼠标按住未释放的状态*/ color: green &#125; a:visited &#123; /*点击之后的状态*/ color: red &#125; &lt;/style&gt; 阴影 左 下 半径 text-shadow:5px 5px 5px 颜色 3.4、利用列表ul li小设计：a进来变样式ul li &#123; height: 30px; list-style: none; /*none:去掉原点、circle:空心圆、decimal:数字、square:正方形*/ text-indent: 1em; /*缩进*/ &#125; a&#123; text-decoration: none; /*首先去掉下划线*/ font-size: 14px; color: #000; &#125; a:hover &#123; color: orange; text-decoration: underline /*进来再有下划线*/ &#125; /*放在div中，作为导航栏*/ &lt;div id=\"nav\"&gt;&lt;/div&gt;#nav &#123; width: 300px; &#125; 3.5、背景样式、图片background:red --------------------------------------------- background-image:url(\"\"); /*默认是全部平铺的*/ background-repeat:repeat-x /*水平平铺*/ background-repeat:repeat-y /*垂直平铺*/ background-repeat:no-repeat /*不平铺*/ --------------------------------------------- background:red url(\"url\") 270px 10px no-repeat /*综合使用*/ background-position:center /*定位：背景位置*/ 拓展：渐变网址：https://www.grablent.com径向渐变、圆形渐变 4、盒子模型4.1、什么是盒子模型margin：外边距 padding：内边距 border：边框 4.2、边框border：2px solid red 4.3、外边距的妙用：居中margin:0 0 0 0 /*表示上、右、下、左*/ margin:0 auto /*居中、auto表示左右自动*/ margin:4px /*表示上、右、下、左都为4px*/ margin:10px 20px 30px /*表示上为10px，左右为20px，下为30px*/ 开发中的常用操作/* 盒子的计算方式：margin+border+padding+内容的大小 */ /* body总有一个默认的外边距，开发中会先把内外边距置为0 */ margin:0; padding:0; text-decoration:none; 4.4、圆角边框：border-radius（顺时针），左上开始 圆圈：圆角=半径 border-radius: 有四个参数 5、浮动5.1、标准文档流 包涵关系：块级元素包裹行级元素块级元素：独占一行 h1~h6 、p、div、 列表…行内元素：不独占一行 span、a、img、strong 5.2、display（重要） block：块元素inline：行内元素inline-block：行内块元素none：消失注：这也是一种实现行内元素排列的方式，但是我们很多情况用float 5.3、float：浮动 参考：详细参考div&#123; float:left/right &#125; /*浮动后，不再属于标准中的元素，下面的元素会上移、但本身还会于上面的元素对其*/ /*假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)； 如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。*/ 清除浮动 clear/* right：右侧不允许有浮动元素 left： 左侧不允许有浮动元素 both： 两侧不允许有浮动元素 none： 两侧允许有浮动元素 对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。*/ 5.4、解决浮动后父级边框塌陷问题/* 方案一：增加父级元素的高度；*/ /* 方案二：增加一个空的div标签，清除本标签的浮动来实现补回原标签 */ &lt;style&gt; .clear&#123; clear:both; margin:0; padding:0; &#125; &lt;/style&gt; &lt;div class = \"clear\"&gt;&lt;/div&gt; /* 方案三：在父级元素中增加一个滚动条然后隐藏起来：overflow：hidden */ overflow:hidden /*隐藏*/ overflow：scoll /*滚动*/ /* 方案四：父类添加一个伪类:after */ #father:after&#123; content:''; display:block; clear:both; &#125; 浮动元素增加空div----&gt; 简单、代码尽量避免空div 设置父元素的高度-----&gt; 简单，元素假设没有了固定的高度，就会超出 overflow----&gt; 简单，下拉的一些场景避免使用 父类添加一个伪类:after（推荐）----&gt; 写法稍微复杂，但是没有副作用，推荐使用 5.5、display与float对比 display：方向不可以控制float：浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题。 6、定位6.1、相对定位（relative） 相对于自身的位置，它仍然在标准文档流中h2.pos_left&#123; location:relative top:-20px; left:20px; bottom:-10px; right:20px; &#125; 6.2、绝对定位： /* 总结：相对一父级或浏览器的位置，进行指定的偏移， 绝对定位的话，它不在标准文档流中，原来的位置不会被保留 */ div:nth-of-type(1)&#123;/*绝对定位：没有相对的父级元素，所以相对于浏览器*/ width: 100px; height: 100px; background:red; position: absolute; right: 0; bottom: 0; &#125; 6.3、固定定位div:nth-of-type(2)&#123; /*始终在右下角*/ width: 50px; height: 50px; background: yellow; position: fixed; right: 0; bottom: 0; &#125; 6.4、图层 z-index：默认是0，最高无限~999(最顶层).tipText&#123; color: white; z-index: 999; &#125; 6.5、透明度.tipBg&#123; background: orange; opacity: 0.5; /*背景透明度*/ filter: alpha(opacity=50); /*原理同上，这里解决ie的兼容性问题*/ &#125; 2020年06月06日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"HTML5的简单回顾","slug":"HTML5的简单回顾","date":"2020-06-06T08:50:30.000Z","updated":"2020-08-04T13:50:30.000Z","comments":true,"path":"2020/06/06/HTML5的简单回顾/","link":"","permalink":"http://yoursite.com/2020/06/06/HTML5的简单回顾/","excerpt":"","text":"前言：教学视频参考：https://www.bilibili.com/video/BV1x4411V75C 网页基本标签&lt;!--meta描述性标签，用来描述我们网站的一些信息--&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"keywords\" content=\"跟狂神学Java\"&gt; &lt;meta name=\"description\" content=\"可以学习java\"&gt; 粗体：&lt;strong&gt;&lt;/strong&gt; 斜体：&lt;em&gt;&lt;/em&gt; 空 &amp;nbsp; 大于号 &amp;gt; 小于号 &amp;lt; 版权符号 &amp;copy; &lt;!--图像标签： alt:图片描述--&gt; &lt;img src=\"../resources/image/1.jpg\" alt=\"我的图片\" title=\"悬停文字\" width=\"1366\" height=\"768\"&gt; target=\"_blank\" ：在新标签中打开 target=\"_self\" ：在自己的网页中打开 target=\"#MarkName\"：即跳转到锚点 &lt;!--锚链接：指定跳转到页面的某个位置，需要定义name属性作为标记--&gt; &lt;a name=\"top\"&gt;顶部&lt;/a&gt; &lt;!--跳转到标记--&gt; &lt;a href=\"#top\"&gt;回到顶部&lt;/a&gt; &lt;!--邮件连接：mailto--&gt; &lt;a href=\"mailto:936681921@qq.com\"&gt;点击联系我&lt;/a&gt; 行内元素和块元素块元素：无论内容有多少，元素自己独占一行 行内元素：内容撑开宽度，左右都是行内元素的可以排在一行 列表标签有序列表 &lt;ol&gt; &lt;li&gt;语文&lt;/li&gt; 1.语文 &lt;li&gt;数学&lt;/li&gt; 2.数学 &lt;li&gt;英语&lt;/li&gt; 3.英语 &lt;/ol&gt; 无序列表 &lt;ul&gt; &lt;li&gt;语文&lt;/li&gt; ● 语文 &lt;li&gt;数学&lt;/li&gt; ● 数学 &lt;li&gt;英语&lt;/li&gt; ● 英语 &lt;/ul&gt; 自定义列表 &lt;dl&gt; &lt;dt&gt;科目&lt;/dt&gt; 科目 &lt;dd&gt;语文&lt;/dd&gt; 语文 &lt;dd&gt;数学&lt;/dd&gt; 数学 &lt;dd&gt;英语&lt;/dd&gt; 英语 &lt;/dl&gt; 表格标签&lt;table&gt; ...&lt;/table&gt; 表格标签。 &lt;tr&gt;...&lt;/tr&gt; 行标签，代表一行。 &lt;td&gt;...&lt;/td&gt; 列标签，代表一列。 border=\"\" 表示表格线条宽度。 colspan=\"3\" 表示这一单元跨几列。 rowspan=\"2\" 表示这一单元跨几行。 视频和音频controls：控制调 autoplay：自动播放 &lt;video src=\"../resources/video/2.mp4\" controls autoplay&gt;&lt;/video&gt; &lt;audio src=\"../resources/audio/3.mp3\" controls autoplay&gt;&lt;/audio&gt; 结构分析&lt;header&gt; &lt;h2&gt;网页头部&lt;/h2&gt; &lt;/header&gt; &lt;section&gt; &lt;h2&gt;网页主体&lt;/h2&gt; &lt;/section&gt; &lt;footer&gt; &lt;h2&gt;网页脚步&lt;/h2&gt; &lt;/footer&gt; &lt;nav&gt;导航&lt;/nav&gt; iframe内联框架&lt;body&gt; &lt;!--单独使用--&gt; &lt;iframe src=\"www.baidu.com\" name=\"go\" frameborder=\"0\" width=\"1000\" height=\"800\"&gt;&lt;/iframe&gt; &lt;!--配合a标签使用--&gt; &lt;iframe src=\"\" name=\"go\" frameborder=\"0\" width=\"1000\" height=\"800\"&gt;&lt;/iframe&gt; &lt;a href=\"https://www.baidu.com\" target=\"go\" &gt;点击打开百度&lt;/a&gt; &lt;/body&gt; 表单&lt;body&gt; &lt;form action=\"\" method=\"\"&gt; action:填写表单内数据提交给的地址。 是提交表单数据的方式，get可以在url看见提交的内容，post的保密性稍高。 &lt;input type=\"\"&gt; &lt;/form&gt; type=\"text\" 默认文本框。 type=\"password\" 密码框，输入不显示密码。 type=\"search\" 搜索框。 type=\"submit\" 提交按钮，网页中点击提交。 type=\"reset\" 重置按钮，网页中点击后表单重置。 hidden:隐藏。 单选框： type=\"radio\" name=\"\":填入组名，网页内在同一组内的单选框只能选中一个，不在同一组则 相当于多选框。 value=\"\"：提交时显示的名字。 checked:默认选择本项选中。 多选框： type=\"checkbox\" name=\"\":填入组名。 value=\"\"：提交时显示的名字。 checked:默认选择本项选中。 普通按钮： type=\"button\": name=\"\":提交时的按钮名。 value=\"\"：在网页显示在按钮中的字符。 下拉列表框： &lt;select name=\"\"&gt;:name中填写列表名。 &lt;option value=\"\"&gt;:value填写单元名 &lt;option value=\"\"&gt;:value填写单元名 &lt;/select&gt; selected:默认选择本项选中。 文本域： &lt;textarea name=\"\"cols=\"30\" rows=\"10\" placeholder=\"\"&gt; name=\"\" :文本域名。文本域网页。 cols=\"30\" :列数。 rows=\"10\" :行数。 placeholder=\"\":默认显示内容，所有文本框可用。 文件域： &lt;input type=\"file\" name=\"files\"&gt; 滑块： &lt;input type=\"range\" name=\"range\" min=\"0\" max=\"100\" step=\"5\"&gt;滑块网 页 type=\"range\" min：表示滑块底部的数值。 max：表示滑块顶端的数值。 step：表示每次拖动滑块改变的数值。 数字验证： &lt;input type=\"number\" name=\"number\" min=\"0\" max=\"100\" step=\"1\"&gt;数字 验证网页 min：表示最低数字。 max：表示最大数字。 step：表示每次增加时改变的数值。 &lt;label for=\"\"&gt;此处可任意填写&lt;/label&gt; 给其他标签添加id=\"\"属性，然后将id中的字符填入for=\"\",点击其产生的字符 可指向对应id的文本框。 初级验证 type=\"email\" 邮箱输入框，带有简单的邮箱格式验证。 type=\"url\" url连接输入框，带有简单的格式验证。 type=\"number\" &lt;input type=\"number\" name=\"num\" max=\"100\" min=\"1\" step=\"1\"&gt; pattern=\"正则表达式验证，使用正则表达式验证文本框填写是否正确\" &lt;/body&gt; 2020年06月06日 下午Guzhz","categories":[{"name":"学习类","slug":"学习类","permalink":"http://yoursite.com/categories/学习类/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"Github&Gitee使用教程","slug":"Github&Gitee使用教程","date":"2020-05-13T08:49:04.000Z","updated":"2020-08-04T06:56:47.000Z","comments":true,"path":"2020/05/13/Github&Gitee使用教程/","link":"","permalink":"http://yoursite.com/2020/05/13/Github&Gitee使用教程/","excerpt":"","text":"前言：注册GitHub有一段时间了，之前有按照教程操作过，不过后来一段时间不用又不熟练了。以至于后期突然使用时出现一些错误，导致本地文件一直提交不了。今天又熟悉了一次，这里做个笔记，以至于后面在忘记可以回顾一下。 一、操作前准备 Github环境搭建 配置共存Github/Gitee环境共存Github/Gitee环境，需要切换全局的 user.name 和 user.email git config - -global - -list（先查看变量）git config - -global user.name “账户名” （再修改变量）git config - -global user.email “邮箱” 二、Github/Gitee部署详细步骤【无仓库：新建远程仓库、初始化本地仓库、两者建立连接、添加并部署】 创建仓库，勾选上RENAME name -&gt; description -&gt; public -&gt; Init -&gt; create “+” -&gt; 介绍 -&gt; 使用Readme文件初始化这个仓库 -&gt; 创建 git init （初始化本地仓库） git add .（有空格） git status（可查看代码的状态） git commit -m “说明”（把文件提交的本地仓库） git remote add origin [url]（连接远程仓库，这个为新建的仓库地址） git pull - -rebase origin master （本地仓库为空，远程仓库不为空，需要pull合并同步，这里–为“双杠”） git push origin master（部署） 【有本地仓库/克隆操作（已建立连接）：在仓库文件夹下进行以下操作】 改动文件后 ↓ git add . git status git commit -m “说明” git push origin master 三、常用命令 git status git add . git commit -m “说明” git push origin master git clone [url] git pull （拉去远程库更新本地库） 2020年4月11日 下午Guzhz","categories":[{"name":"技术类","slug":"技术类","permalink":"http://yoursite.com/categories/技术类/"}],"tags":[{"name":"备份","slug":"备份","permalink":"http://yoursite.com/tags/备份/"},{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]},{"title":"Hexo的使用","slug":"Hexo的使用","date":"2020-05-08T16:31:04.000Z","updated":"2020-05-08T16:31:48.000Z","comments":true,"path":"2020/05/09/Hexo的使用/","link":"","permalink":"http://yoursite.com/2020/05/09/Hexo的使用/","excerpt":"","text":"前言：Hexo是一个主题框架，用于搭建博客，这里做个笔记，以至于后面忘记了可以回顾一下如何操作。 一、详细搭建参考 搭建参考一搭建参考二markdown语法参考主题推荐 二、域名的绑定与解绑绑定：免费一年的域名网 1、在myblog\\source（source目录下的文件为源文件)目录下新建CNAME(无后缀)2、把域名写进去即可，www加不加都行。 解绑： 1、只生效一次的解绑方法：直接删除github项目上的CNAME文件，但是更新后重新部署后又会生成2、永久解绑方法：删除主题source目录下的CNAME，删除/清空source目录下的CNAME文件后重新部署，setting里删除手动指定的域名。 三、我的博客详细分类操作步骤： 1. 在项目的根目录下（myblog) 2. 右键打开：Git Bash 3. 新文章 ：myblog\\source\\_posts 下编写md文件 hexo g (生成) hexo s (本地浏览) hexo d (部署到github) 博客一：VScode、有道云笔记 myblog → 主目录 myblog_bak → 主目录备份 Picture-bed → 图床仓库 博客二：有道云笔记编写，VScode编辑 虚拟机桌面的“blog”文件 已同步到坚果云 test = &gt; 测试仓库 blog\\source\\_posts =&gt; 源文件 blog\\themes\\diaspora\\source\\img =&gt; 图库(图床)，不需要额外的图床 source -&gt; MD File =&gt; md文件 2020年4月11日 凌晨Guzhz","categories":[{"name":"技术类","slug":"技术类","permalink":"http://yoursite.com/categories/技术类/"}],"tags":[{"name":"备份","slug":"备份","permalink":"http://yoursite.com/tags/备份/"}]},{"title":"新玩意儿","slug":"新玩意儿","date":"2020-03-26T13:50:30.000Z","updated":"2020-03-26T13:50:30.000Z","comments":true,"path":"2020/03/26/新玩意儿/","link":"","permalink":"http://yoursite.com/2020/03/26/新玩意儿/","excerpt":"","text":"耗时三天，搭建了人生的，第一个网站，感觉还不错。(#^.^#) Mood从郁闷到舒畅。 Weather阴天。 Date2019年3月26日 晚上 完结","categories":[{"name":"生活类","slug":"生活类","permalink":"http://yoursite.com/categories/生活类/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]},{"title":"一年了","slug":"一年了","date":"2020-02-24T16:49:04.000Z","updated":"2020-02-24T16:50:53.000Z","comments":true,"path":"2020/02/25/一年了/","link":"","permalink":"http://yoursite.com/2020/02/25/一年了/","excerpt":"","text":"时间飞逝，一眨眼，一年过去了。 好久没来，好久没写，其实心里一直想着，总要记录点什么，可是总是没能抽出时间过来。 有空再写吧，晚安。 Mood挺好的。 Weather晴天。 Date2020年2月24日 晚上 完结","categories":[{"name":"生活类","slug":"生活类","permalink":"http://yoursite.com/categories/生活类/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"}]}]}